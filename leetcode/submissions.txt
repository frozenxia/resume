[{"id": 290840938, "lang": "cpp", "time": "1\u00a0hour, 17\u00a0minutes", "timestamp": 1578069596, "status_display": "Accepted", "runtime": "12 ms", "url": "/submissions/detail/290840938/", "is_pending": "Not Pending", "title": "UTF-8 Validation", "memory": "9.5 MB", "code": "class Solution {\npublic:\n    bool validUtf8(vector<int>& data) {\n        if(data.size() == 0) return true;\n        int idx = 0;\n        while(idx < data.size()){\n            if(!checkValue(data[idx])) return false;\n            if((data[idx] & (1 << 7)) ==0){\n                idx ++;\n            }else{\n                int i = 0;\n                while(i <= 4 && (data[idx] & (1 << (7-i)))){\n                    i ++;\n                }\n                if((data[idx] & (1 << (7-i)))){\n                    return false;\n                }\n                if(i < 2 || i >= 5){\n                    return false;\n                }\n                // cout << i << endl;\n                //n-bytes\n                idx ++;\n                while(idx < data.size() && i > 1){\n                    if(!checkZeroOne(data[idx])){\n                        return false;\n                    }\n                    i --;\n                    idx ++;\n                }\n                if(i != 1){\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    bool checkZeroOne(int a){\n        return ((a&(1<<7)) && (!(a&(1<<6))));\n    }\n    \n    bool checkValue(int a){\n        return a >=0 && a <= 255;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111"}, {"id": 290840634, "lang": "cpp", "time": "1\u00a0hour, 18\u00a0minutes", "timestamp": 1578069505, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/290840634/", "is_pending": "Not Pending", "title": "UTF-8 Validation", "memory": "N/A", "code": "class Solution {\npublic:\n    bool validUtf8(vector<int>& data) {\n        if(data.size() == 0) return true;\n        int idx = 0;\n        while(idx < data.size()){\n            if(!checkValue(data[idx])) return false;\n            if((data[idx] & (1 << 7)) ==0){\n                idx ++;\n            }else{\n                int i = 0;\n                while(i <= 4 && (data[idx] & (1 << (7-i)))){\n                    i ++;\n                }\n                if((data[idx] & (1 << (7-i)))){\n                    return false;\n                }\n                if(i < 2){\n                    return false;\n                }\n                // cout << i << endl;\n                //n-bytes\n                idx ++;\n                while(idx < data.size() && i > 1){\n                    if(!checkZeroOne(data[idx])){\n                        return false;\n                    }\n                    i --;\n                    idx ++;\n                }\n                if(i != 1){\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    bool checkZeroOne(int a){\n        return ((a&(1<<7)) && (!(a&(1<<6))));\n    }\n    \n    bool checkValue(int a){\n        return a >=0 && a <= 255;\n    }\n};", "compare_result": "1111111111110111111111111111111111111111111111111"}, {"id": 290840301, "lang": "cpp", "time": "1\u00a0hour, 20\u00a0minutes", "timestamp": 1578069401, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/290840301/", "is_pending": "Not Pending", "title": "UTF-8 Validation", "memory": "N/A", "code": "class Solution {\npublic:\n    bool validUtf8(vector<int>& data) {\n        if(data.size() == 0) return true;\n        int idx = 0;\n        while(idx < data.size()){\n            if(!checkValue(data[idx])) return false;\n            if((data[idx] & (1 << 7)) ==0){\n                idx ++;\n            }else{\n                int i = 0;\n                while(i <= 4 && (data[idx] & (1 << (7-i)))){\n                    i ++;\n                }\n                if((data[idx] & (1 << (7-i)))){\n                    return false;\n                }\n                // cout << i << endl;\n                //n-bytes\n                idx ++;\n                while(idx < data.size() && i > 1){\n                    if(!checkZeroOne(data[idx])){\n                        return false;\n                    }\n                    i --;\n                    idx ++;\n                }\n                if(i != 1){\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    bool checkZeroOne(int a){\n        return ((a&(1<<7)) && (!(a&(1<<6))));\n    }\n    \n    bool checkValue(int a){\n        return a >=0 && a <= 255;\n    }\n};", "compare_result": "1111110110110111111111111111111101111111110000111"}, {"id": 290817330, "lang": "cpp", "time": "3\u00a0hours, 36\u00a0minutes", "timestamp": 1578061214, "status_display": "Accepted", "runtime": "44 ms", "url": "/submissions/detail/290817330/", "is_pending": "Not Pending", "title": "Pacific Atlantic Water Flow", "memory": "14.5 MB", "code": "class Solution {\npublic:\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix) {\n        vector<vector<int> > results;\n        if(matrix.size() <= 0) return results;\n        \n        vector<vector<int>> table(matrix.size(),vector<int>(matrix[0].size(),0));\n        for(int i = 0;i < matrix[0].size();i ++){\n            dfs(matrix,table,1,0,i);\n        }\n        for(int i = 0;i < matrix.size();i ++){\n            dfs(matrix,table,1,i,0);\n        }\n        \n        \n        for(int i = 0;i < matrix[0].size();i ++){\n            dfs(matrix,table,3,matrix.size()-1,i);\n        }\n        for(int i = 0;i < matrix.size();i ++){\n            dfs(matrix,table,3,i,matrix[0].size()-1);\n        }\n        \n        for(int i = 0;i < matrix.size();i ++){\n            for(int j = 0;j < matrix[0].size();j ++){\n                if(table[i][j] == 4){\n                    results.push_back({i,j});\n                }\n            }\n        }\n        return results;\n    }\n    void dfs(vector<vector<int>>& matrix,\n             vector<vector<int>>&table,\n             int label,\n             int i,\n             int j){\n        if(i < 0 || i >= matrix.size() || j <0 || j >= matrix[0].size()){\n            return;\n        }\n        if(table[i][j] < label){\n            table[i][j] += label;\n            if(i-1 >= 0 && matrix[i][j] <= matrix[i-1][j]){\n                dfs(matrix,table,label,i-1,j);\n            }\n            if(i+1 < matrix.size() && matrix[i][j] <= matrix[i+1][j]){\n                dfs(matrix,table,label,i+1,j);\n            }\n            if(j-1 >= 0 && matrix[i][j] <= matrix[i][j-1]){\n                dfs(matrix,table,label,i,j-1);\n            }if(j+1 < matrix[0].size() && matrix[i][j] <= matrix[i][j+1]){\n                dfs(matrix,table,label,i,j+1);\n            }\n        }\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 290814038, "lang": "cpp", "time": "3\u00a0hours, 59\u00a0minutes", "timestamp": 1578059835, "status_display": "Accepted", "runtime": "132 ms", "url": "/submissions/detail/290814038/", "is_pending": "Not Pending", "title": "Construct Quad Tree", "memory": "33.1 MB", "code": "/*\n// Definition for a QuadTree node.\nclass Node {\npublic:\n    bool val;\n    bool isLeaf;\n    Node* topLeft;\n    Node* topRight;\n    Node* bottomLeft;\n    Node* bottomRight;\n\n    Node() {}\n\n    Node(bool _val, bool _isLeaf, Node* _topLeft, Node* _topRight, Node* _bottomLeft, Node* _bottomRight) {\n        val = _val;\n        isLeaf = _isLeaf;\n        topLeft = _topLeft;\n        topRight = _topRight;\n        bottomLeft = _bottomLeft;\n        bottomRight = _bottomRight;\n    }\n};\n*/\nclass Solution {\npublic:\n    Node* construct(vector<vector<int>>& grid) {\n        if(grid.size() <= 0 )return NULL;\n        return construct(grid,0,0,grid.size()-1,grid[0].size()-1);\n    }\n    \n    Node * construct(vector<vector<int>>& grid,int topLeft,int topRight,int bottenLeft,int bottenRight){\n         // cout << topLeft << \" \" << topRight << \" \"<< bottenLeft << \" \" << bottenRight << endl;\n        \n        if(topLeft < 0 || topLeft > bottenLeft || topLeft >= grid.size() ||\n           topRight <0 || topRight > bottenRight ||  topRight >= grid[0].size() ||\n           bottenLeft >= grid.size() ||  bottenRight >= grid[0].size()){\n            return NULL;\n        }\n        \n       \n        \n        bool status = true;\n        int val = grid[topLeft][topRight];\n        for(int i = topLeft;i <= bottenLeft;i ++){\n            for(int j = topRight;j <= bottenRight;j ++){\n                if(grid[i][j] != val){\n                    status = false;\n                    break;\n                }\n            }\n        }\n        // cout <<\"status: \" <<  status << endl;\n        if(status){\n            return new Node(val,true,NULL,NULL,NULL,NULL);\n        }else{\n            int ml = (topLeft + bottenLeft) >> 1;\n            int mr = (topRight + bottenRight) >> 1;\n            return new Node(val,false,\n                            construct(grid,topLeft,topRight,ml,mr),\n                            construct(grid,topLeft,mr+1,ml,bottenRight),\n                            construct(grid,ml+1,topRight,bottenLeft,mr),\n                            construct(grid,ml+1,mr+1,bottenLeft,bottenRight));\n        }\n    }\n};", "compare_result": "11111111111111111111"}, {"id": 290810365, "lang": "cpp", "time": "4\u00a0hours, 27\u00a0minutes", "timestamp": 1578058201, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/290810365/", "is_pending": "Not Pending", "title": "Flatten a Multilevel Doubly Linked List", "memory": "9.8 MB", "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* prev;\n    Node* next;\n    Node* child;\n};\n*/\nclass Solution {\npublic:\n    Node* flatten(Node* head) {\n        if(head == NULL) return head;\n        Node *p = head;\n        Node *q = p->next;\n        if(head->child != NULL){\n            Node * child  = flatten(p->child);\n            p->next = child;\n            p->child = NULL;\n            child->prev = p;\n            while(p->next != NULL){\n                p = p->next;\n            }\n        }\n        q = flatten(q);\n        if(q != NULL){\n            p->next = q;\n            q->prev = p;\n        }\n        return head; \n    }\n};", "compare_result": "1111111111111111111111"}, {"id": 290786032, "lang": "cpp", "time": "7\u00a0hours, 48\u00a0minutes", "timestamp": 1578046128, "status_display": "Accepted", "runtime": "24 ms", "url": "/submissions/detail/290786032/", "is_pending": "Not Pending", "title": "Reconstruct Original Digits from English", "memory": "12 MB", "code": "class Solution {\npublic:\n    string originalDigits(string s) {\n        vector<int> table(26,0);\n        for(auto c : s){\n            table[c-'a'] ++;\n        }\n        vector<int> nums(10,0);\n        //zero \n        vector<string> name ={\n            \"zero\",\"wto\",\"ufor\",\"xis\",\"one\",\"five\",\"rthee\",\"vseen\",\"geiht\",\"inne\"\n        };\n        vector<int> ids = {\n            0,2,4,6,1,5,3,7,8,9\n        };\n        for(int i = 0;i < name.size();i ++){\n            auto &n = name[i];\n            nums[ids[i]] = table[n[0]-'a'];\n            for(auto &c : n){\n                table[c-'a'] -= nums[ids[i]];\n            }\n        }\n        string sret= \"\";\n        for(int i = 0;i < 10;i ++){\n            sret =  sret + string(nums[i],'0'+i);\n        }\n        return sret;\n    }\n};  ", "compare_result": "111111111111111111111111"}, {"id": 290785585, "lang": "cpp", "time": "7\u00a0hours, 52\u00a0minutes", "timestamp": 1578045892, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/290785585/", "is_pending": "Not Pending", "title": "Reconstruct Original Digits from English", "memory": "N/A", "code": "class Solution {\npublic:\n    string originalDigits(string s) {\n        vector<int> table(26,0);\n        for(auto c : s){\n            table[c-'a'] ++;\n        }\n        vector<int> nums(10,0);\n        //zero \n        vector<string> name ={\n            \"zero\",\"wto\",\"ufor\",\"xis\",\"one\",\"five\",\"rthee\",\"vseen\",\"eight\",\"night\"\n        };\n        vector<int> ids = {\n            0,2,4,6,1,5,3,7,8,9\n        };\n        for(int i = 0;i < name.size();i ++){\n            auto &n = name[i];\n            nums[ids[i]] = table[n[0]-'a'];\n            for(auto &c : n){\n                table[c-'a'] -= nums[ids[i]];\n            }\n        }\n        string sret= \"\";\n        for(int i = 0;i < 10;i ++){\n            sret =  sret + string(nums[i],'0'+i);\n        }\n        return sret;\n    }\n};  ", "compare_result": "111111111110100000000000"}, {"id": 290782672, "lang": "cpp", "time": "8\u00a0hours, 13\u00a0minutes", "timestamp": 1578044601, "status_display": "Accepted", "runtime": "116 ms", "url": "/submissions/detail/290782672/", "is_pending": "Not Pending", "title": "Find Right Interval", "memory": "24.6 MB", "code": "class Solution {\npublic:\n    vector<int> findRightInterval(vector<vector<int>>& intervals) {\n        map<int,int> table;\n        for(int i = 0;i < intervals.size();i ++){\n            if(table[intervals[i][0]] == 0){\n                table[intervals[i][0]] = i +1;\n            }\n        }\n        vector<int> results;\n        for(int i = 0;i < intervals.size();i ++){\n            auto p = table.upper_bound(intervals[i][1]-1);\n            if( p == table.end()){\n                results.push_back(-1);\n            }else{\n                results.push_back(p->second-1);\n            }\n        }\n        return results;\n    }\n};", "compare_result": "11111111111111111"}, {"id": 290780323, "lang": "cpp", "time": "8\u00a0hours, 28\u00a0minutes", "timestamp": 1578043690, "status_display": "Accepted", "runtime": "28 ms", "url": "/submissions/detail/290780323/", "is_pending": "Not Pending", "title": "Longest Repeating Character Replacement", "memory": "9.2 MB", "code": "class Solution {\npublic:\n    int characterReplacement(string s, int k) {\n        int mx = 0;\n        for(int i = 0;i < 26;i ++){\n            mx = max(getMaxLen(s,i+'A',k),mx);\n        }\n        return mx;\n    }\n    int getMaxLen(string &s,char ch,int k){\n        int left = 0;\n        int right = 0;\n        int other = 0;\n        int total = 0;\n        int mx = 0;\n        while(right < s.size()){\n            if(s[right] == ch){\n                total ++;\n                // right ++;\n            }else{\n                other ++;\n                while(other > k){\n                    if(s[left] == ch){\n                        total --;\n                    }else{\n                        other --;\n                    }\n                    left ++;\n                }\n            }\n            mx = max(mx,total + other);\n            right ++;\n        }\n        return mx ;\n    }\n};", "compare_result": "1111111111111111111111111111111111111"}, {"id": 290780219, "lang": "cpp", "time": "8\u00a0hours, 29\u00a0minutes", "timestamp": 1578043657, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/290780219/", "is_pending": "Not Pending", "title": "Longest Repeating Character Replacement", "memory": "N/A", "code": "class Solution {\npublic:\n    int characterReplacement(string s, int k) {\n        int mx = 0;\n        for(int i = 0;i < 26;i ++){\n            mx = max(getMaxLen(s,i+'A',k),mx);\n        }\n        return mx;\n    }\n    int getMaxLen(string &s,char ch,int k){\n        int left = 0;\n        int right = 0;\n        int other = 0;\n        int total = 0;\n        int mx = 0;\n        while(right < s.size()){\n            if(s[right] == ch){\n                total ++;\n                // right ++;\n                mx = max(mx,total + other);\n            }else{\n                other ++;\n                while(other > k){\n                    if(s[left] == ch){\n                        total --;\n                    }else{\n                        other --;\n                    }\n                    left ++;\n                }\n            }\n            right ++;\n        }\n        return mx ;\n    }\n};", "compare_result": "1111111111011111111111111111111111111"}, {"id": 290780062, "lang": "cpp", "time": "8\u00a0hours, 30\u00a0minutes", "timestamp": 1578043600, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/290780062/", "is_pending": "Not Pending", "title": "Longest Repeating Character Replacement", "memory": "N/A", "code": "class Solution {\npublic:\n    int characterReplacement(string s, int k) {\n        int mx = 0;\n        for(int i = 0;i < 26;i ++){\n            mx = max(getMaxLen(s,i+'A',k),mx);\n        }\n        return mx;\n    }\n    int getMaxLen(string &s,char ch,int k){\n        int left = 0;\n        int right = 0;\n        int other = 0;\n        int total = 0;\n        int mx = 0;\n        while(right < s.size()){\n            if(s[right] == ch){\n                total ++;\n                // right ++;\n                mx = max(mx,total);\n            }else{\n                other ++;\n                while(other > k){\n                    if(s[left] == ch){\n                        total --;\n                    }else{\n                        other --;\n                    }\n                    left ++;\n                }\n            }\n            right ++;\n        }\n        return mx + k;\n    }\n};", "compare_result": "1101111110110111111111111111111110110"}, {"id": 290777754, "lang": "cpp", "time": "8\u00a0hours, 44\u00a0minutes", "timestamp": 1578042769, "status_display": "Accepted", "runtime": "32 ms", "url": "/submissions/detail/290777754/", "is_pending": "Not Pending", "title": "Find All Anagrams in a String", "memory": "10.3 MB", "code": "class Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) {\n        vector<int> label(26,0);\n        for(auto c: p){\n            label[c-'a'] ++;\n        }\n        vector<int> tar(26,0);\n        int left = 0;\n        int right = 0;\n        vector<int> results;\n        while(right < s.size()){\n            tar[s[right] - 'a'] ++;\n            if(tar[s[right]-'a'] >= label[s[right]-'a']){\n                while(tar[s[right]-'a'] > label[s[right]-'a']){\n                    tar[s[left]-'a'] --;\n                    left ++;\n                }\n                bool status = true;\n                for(int i = 0;i < 26;i ++){\n                    if(label[i] != tar[i]){\n                        status = false;\n                        break;\n                    }\n                }\n                if(status){\n                    results.push_back(left);\n                }\n                \n            }\n            right ++;\n        }\n        return results;\n    }\n};", "compare_result": "111111111111111111111111111111111111"}, {"id": 290772709, "lang": "cpp", "time": "9\u00a0hours, 13\u00a0minutes", "timestamp": 1578041000, "status_display": "Accepted", "runtime": "12 ms", "url": "/submissions/detail/290772709/", "is_pending": "Not Pending", "title": "Elimination Game", "memory": "8.2 MB", "code": "class Solution {\npublic:\n    int lastRemaining(int n) {\n        int head = 1;\n        int steps = 1;\n        int remaining = n;\n        bool left = true;\n        while(remaining > 1){\n            if(left || remaining % 2 == 1){\n                head = head + steps;\n            }\n            remaining = remaining / 2;\n            steps  = steps * 2;\n            left = !left;\n        }\n        return head;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 290757633, "lang": "cpp", "time": "10\u00a0hours, 27\u00a0minutes", "timestamp": 1578036562, "status_display": "Accepted", "runtime": "12 ms", "url": "/submissions/detail/290757633/", "is_pending": "Not Pending", "title": "Rotate Function", "memory": "9.6 MB", "code": "class Solution {\npublic:\n    int maxRotateFunction(vector<int>& A) {\n        if(A.size() <= 0 ) return 0;\n        long sum = 0;\n        long cumSum = 0;\n        for(int i = 0;i < A.size();i++){\n            sum += i*1L * A[i];\n            cumSum += A[i];\n        }\n        long mv = sum;\n        long sz = A.size();\n        for(int i = 1;i < sz;i ++){\n            sum = sum + sz * A[i-1] - cumSum;\n            mv = max(sum,mv);\n        }\n        return mv;\n        \n    }\n};", "compare_result": "11111111111111111"}, {"id": 290757372, "lang": "cpp", "time": "10\u00a0hours, 28\u00a0minutes", "timestamp": 1578036499, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/290757372/", "is_pending": "Not Pending", "title": "Rotate Function", "memory": "N/A", "code": "class Solution {\npublic:\n    int maxRotateFunction(vector<int>& A) {\n        if(A.size() <= 0 ) return 0;\n        long sum = 0;\n        long cumSum = 0;\n        for(int i = 0;i < A.size();i++){\n            sum += i * A[i];\n            cumSum += A[i];\n        }\n        long mv = sum;\n        int sz = A.size();\n        for(int i = 1;i < sz;i ++){\n            sum = sum + sz * A[i-1] - cumSum;\n            mv = max(sum,mv);\n        }\n        return mv;\n        \n    }\n};", "compare_result": "11110000000000000"}, {"id": 290745740, "lang": "cpp", "time": "11\u00a0hours, 13\u00a0minutes", "timestamp": 1578033782, "status_display": "Accepted", "runtime": "0 ms", "url": "/submissions/detail/290745740/", "is_pending": "Not Pending", "title": "Nth Digit", "memory": "8.5 MB", "code": "class Solution {\npublic:\n    int findNthDigit(int n) {\n        long bits = 1;\n        long base = 9;\n        //get bits\n        while(n - base * bits > 0){\n            n = n - base * bits;\n            base = base * 10;\n            bits ++;\n        }\n        \n        //get which number\n        int idx = n / bits;\n        if(n % bits > 0){\n            idx += 1;\n        }\n        int tar = pow(10,bits-1) + idx-1;\n        \n        //git bits\n        idx = n % bits;\n        if(idx == 0){\n            idx = bits;\n        }\n        for(int i = idx;i < bits;i ++){\n            tar = tar / 10;\n        }\n        return tar%10;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 290745613, "lang": "cpp", "time": "11\u00a0hours, 14\u00a0minutes", "timestamp": 1578033757, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/290745613/", "is_pending": "Not Pending", "title": "Nth Digit", "memory": "N/A", "code": "class Solution {\npublic:\n    int findNthDigit(int n) {\n        int bits = 1;\n        int base = 9;\n        //get bits\n        while(n - base * bits > 0){\n            n = n - base * bits;\n            base = base * 10;\n            bits ++;\n        }\n        \n        //get which number\n        int idx = n / bits;\n        if(n % bits > 0){\n            idx += 1;\n        }\n        int tar = pow(10,bits-1) + idx-1;\n        \n        //git bits\n        idx = n % bits;\n        if(idx == 0){\n            idx = bits;\n        }\n        for(int i = idx;i < bits;i ++){\n            tar = tar / 10;\n        }\n        return tar%10;\n    }\n};", "compare_result": "1111111111111111111111111111111111111000000000000000000000000000000000"}, {"id": 290745120, "lang": "cpp", "time": "11\u00a0hours, 15\u00a0minutes", "timestamp": 1578033667, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/290745120/", "is_pending": "Not Pending", "title": "Nth Digit", "memory": "N/A", "code": "class Solution {\npublic:\n    int findNthDigit(int n) {\n        int bits = 1;\n        int base = 9;\n        //get bits\n        while(n - base * bits > 0){\n            n = n - base * bits;\n            base = base * 10;\n            bits ++;\n        }\n        \n        //get which number\n        int idx = n / bits;\n        if(n % bits > 0){\n            idx += 1;\n        }\n        int tar = pow(10,bits-1) + idx-1;\n        \n        //git bits\n        idx = n % bits;\n        for(int i = idx;i < bits;i ++){\n            tar = tar / 10;\n        }\n        return tar%10;\n    }\n};", "compare_result": "0100000000110101010101010101011111111000000000000000000000000000000000"}, {"id": 290714452, "lang": "cpp", "time": "13\u00a0hours, 9\u00a0minutes", "timestamp": 1578026867, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/290714452/", "is_pending": "Not Pending", "title": "Battleships in a Board", "memory": "9.5 MB", "code": "class Solution {\npublic:\n    int countBattleships(vector<vector<char>>& board) {\n        int counts = 0;\n        if(board.size() <= 0) return 0;\n        for(int i = 0;i < board.size();i ++){\n            for(int j = 0;j < board[0].size();j ++){\n                if(board[i][j] == 'X' && (i ==0 || board[i-1][j] != 'X' )&&(j ==0 || board[i][j-1] != 'X')){\n                    // cout /<< i << \" \" << j << endl;\n                    counts ++;\n                }\n            }\n        }\n        return counts;\n    }\n};", "compare_result": "1111111111111111111111111111"}, {"id": 290701620, "lang": "cpp", "time": "13\u00a0hours, 57\u00a0minutes", "timestamp": 1578023981, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/290701620/", "is_pending": "Not Pending", "title": "Minimum Genetic Mutation", "memory": "8.5 MB", "code": "class Solution {\npublic:\n    int minMutation(string start, string end, vector<string>& bank) {\n        set<string> bset;\n        for(auto s : bank){\n            bset.insert(s);\n        }\n        vector<string> next;\n        next.push_back(start);\n        int count  = 0;\n        vector<char> choices = {'A','C','G','T'};\n        while(next.size() > 0){\n            vector<string> tn;\n            for(auto p : next){\n                if(p == end){\n                    return count;\n                }\n                for(auto &c : p){\n                    for(auto ch : choices){\n                        if(c != ch){\n                            char t = c;\n                            c = ch;\n                            if(bset.find(p) != bset.end()){\n                                tn.push_back(p);\n                                bset.erase(p);\n                            }\n                            c = t;\n                        }\n                    }\n                }\n            }\n            next = tn;\n            count ++;\n        }\n        return -1;\n    }\n};", "compare_result": "11111111111111"}, {"id": 290691864, "lang": "cpp", "time": "14\u00a0hours, 32\u00a0minutes", "timestamp": 1578021860, "status_display": "Accepted", "runtime": "72 ms", "url": "/submissions/detail/290691864/", "is_pending": "Not Pending", "title": "N-ary Tree Level Order Traversal", "memory": "57.4 MB", "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(Node* root) {\n        vector<Node*> bash;\n        vector<vector<int>> results;\n        if(root == NULL){\n            return results;\n        }\n        bash.push_back(root);\n        while(bash.size() > 0){\n            vector<Node*> tbash;\n            vector<int> tr;\n            for(auto p  : bash){\n                tr.push_back(p->val);\n                tbash.insert(tbash.end(),p->children.begin(),p->children.end());\n            }\n            swap(bash,tbash);\n            results.push_back(tr);\n        }\n        return results;\n    }\n};", "compare_result": "1111111111111111111111111111111111111"}, {"id": 290667660, "lang": "cpp", "time": "16\u00a0hours, 3\u00a0minutes", "timestamp": 1578016432, "status_display": "Accepted", "runtime": "176 ms", "url": "/submissions/detail/290667660/", "is_pending": "Not Pending", "title": "Find All Duplicates in an Array", "memory": "20.6 MB", "code": "class Solution {\npublic:\n    vector<int> findDuplicates(vector<int>& nums) {\n        set<int> results;\n        int idx = 0;\n        while(idx < nums.size()){\n            if(idx + 1 != nums[idx]){\n                if(nums[idx] == nums[nums[idx]-1]){\n                    results.insert(nums[idx]);\n                    idx ++;\n                }else{\n                    swap(nums[idx],nums[nums[idx]-1]);\n                }\n            }else{\n                idx ++;\n            }\n        }\n        return vector<int>(results.begin(),results.end());\n    }\n};", "compare_result": "1111111111111111111111111111"}, {"id": 290510965, "lang": "cpp", "time": "1\u00a0day, 3\u00a0hours", "timestamp": 1577973980, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/290510965/", "is_pending": "Not Pending", "title": "Longest Absolute File Path", "memory": "8.8 MB", "code": "class Solution {\npublic:\n    int lengthLongestPath(string input) {\n        vector<string> svec;\n        stringstream ss(input);\n        string tmp;\n        int mxz = 0;\n        while(getline(ss,tmp,'\\n')){\n            int idx = 0;\n            while(idx < tmp.size() && tmp[idx]== '\\t'){\n                idx ++;\n            }\n            if(idx == svec.size()){\n                svec.push_back(tmp.substr(idx,tmp.size()-idx));\n            }else{\n                svec[idx] = tmp.substr(idx,tmp.size()-idx);\n            }\n            bool status = false;\n            for(auto c : tmp){\n                if(c == '.'){\n                    status=true;\n                    break;\n                }\n            }\n            if(status){\n                int tz = 0;\n                for(int i = 0;i <= idx;i ++){\n                    tz += svec[i].size();\n                }\n                mxz = max(mxz,tz+idx);\n            }\n        }\n        return mxz;\n    }\n};", "compare_result": "1111111111111111111111111"}, {"id": 290508809, "lang": "cpp", "time": "1\u00a0day, 4\u00a0hours", "timestamp": 1577973103, "status_display": "Accepted", "runtime": "0 ms", "url": "/submissions/detail/290508809/", "is_pending": "Not Pending", "title": "Evaluate Division", "memory": "9.1 MB", "code": "class Solution {\npublic:\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\n        map<string,pair<string,double> > table;\n        for(int i = 0;i < equations.size();i ++){\n            auto &eq = equations[i];\n            if(table.find(eq[0]) == table.end() && table.find(eq[1]) == table.end()){\n                table[eq[0]].first = eq[1];\n                table[eq[0]].second = values[i];\n                table[eq[1]].first = eq[1];\n                table[eq[1]].second = 1.0;\n            }else if (table.find(eq[0]) == table.end()){\n                auto pa = getParent(table,eq[1]);\n                table[eq[0]].first = pa.first;\n                table[eq[0]].second = values[i] * pa.second;\n            }else if (table.find(eq[1]) == table.end() && values[i] != 0.0){\n                auto pa = getParent(table,eq[0]);\n                table[eq[1]].first = pa.first;\n                table[eq[1]].second = pa.second /  values[i];\n            }else{\n                auto pa = getParent(table,eq[0]);\n                auto pb = getParent(table,eq[1]);\n                pa.second = pb.second * values[i]/pa.second;\n                table[pa.first] = pa;\n                table[pa.first].first = pb.first;\n            }\n        }\n        \n        vector<double> results;\n        for(auto &q : queries){\n            if(table.find(q[0]) == table.end () || table.find(q[1]) == table.end()){\n                results.push_back(-1.0);\n            }else{\n                auto pa = getParent(table,q[0]);\n                auto pb = getParent(table,q[1]);\n                // printP(pa);\n                // printP(pb);\n                if(pa.first != pb.first){\n                    results.push_back(-1.0);\n                }else{\n                    results.push_back(pa.second/pb.second);\n                }\n            }\n            \n        }\n        return results;\n    }\n    void printP(pair<string,double> &p){\n        cout << p.first << \" \" << p.second << endl;\n    }\n    pair<string,double> getParent(map<string,pair<string,double> >& table,string tar){\n        if(table[tar].first == tar){\n            return table[tar];\n        }\n        auto pa = table[tar];\n        table[tar] = getParent(table,table[tar].first);\n        table[tar].second *= pa.second;\n        return table[tar];\n    }\n};", "compare_result": "11111111111"}, {"id": 290480608, "lang": "cpp", "time": "1\u00a0day, 7\u00a0hours", "timestamp": 1577959423, "status_display": "Accepted", "runtime": "12 ms", "url": "/submissions/detail/290480608/", "is_pending": "Not Pending", "title": "Integer Replacement", "memory": "8.3 MB", "code": "class Solution {\npublic:\n    int integerReplacement(int n) {\n        return longReplacement(n);\n    }\n    \n    int longReplacement(long n) {\n        if(n == 1) return 0;\n        if(n %2 == 0) return longReplacement(n/2) +1;\n        return min(longReplacement(n-1),longReplacement(n+1))+1;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111"}, {"id": 290480382, "lang": "cpp", "time": "1\u00a0day, 7\u00a0hours", "timestamp": 1577959327, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/290480382/", "is_pending": "Not Pending", "title": "Integer Replacement", "memory": "N/A", "code": "class Solution {\npublic:\n    int integerReplacement(int n) {\n        if(n == 1) return 0;\n        if(n %2 == 0) return integerReplacement(n/2) +1;\n        if(n == INT_MAX){\n            return integerReplacement(n-1) +1 ;\n        }else if (n == INT_MIN){\n            return integerReplacement(n+1) +1;\n        }\n        return min(integerReplacement(n-1),integerReplacement(n+1))+1;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111110"}, {"id": 290480226, "lang": "cpp", "time": "1\u00a0day, 7\u00a0hours", "timestamp": 1577959254, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/290480226/", "is_pending": "Not Pending", "title": "Integer Replacement", "memory": "N/A", "code": "class Solution {\npublic:\n    int integerReplacement(int n) {\n        if(n == 1) return 0;\n        if(n %2 == 0) return integerReplacement(n/2) +1;\n        return min(integerReplacement(n-1),integerReplacement(n+1))+1;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111110"}, {"id": 290478458, "lang": "cpp", "time": "1\u00a0day, 8\u00a0hours", "timestamp": 1577958525, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/290478458/", "is_pending": "Not Pending", "title": "Longest Substring with At Least K Repeating Characters", "memory": "9.1 MB", "code": "class Solution {\npublic:\n    int longestSubstring(string s, int k) {      \n        if(k <= 0) return s.size();\n        if(s.size() < k) return 0;\n        vector<int> table(27,0);\n        for(auto c : s){\n            table[c-'a'] ++;\n        }\n        // cout << \" s\" << endl;\n        int left = 0;\n        int right = s.size();\n        right --;\n        while(left < right  && table[s[left] - 'a'] < k){\n            left ++;\n        }\n        while(right > left && table[s[right] - 'a'] < k)\n        {\n            right --;\n        }\n        // cout << left << \" \" << right << endl;\n        for(int i = left;i <= right;i ++){\n            if(table[s[i]-'a'] < k){\n                // cout << s.substr(left,i-left) << \" \\t\" << endl;\n                return max(longestSubstring(s.substr(left,i-left),k),longestSubstring(s.substr(i,right-i+1),k));\n            }\n        }\n        return right - left +1;\n    }\n};", "compare_result": "1111111111111111111111111111"}, {"id": 290467261, "lang": "cpp", "time": "1\u00a0day, 9\u00a0hours", "timestamp": 1577954184, "status_display": "Accepted", "runtime": "0 ms", "url": "/submissions/detail/290467261/", "is_pending": "Not Pending", "title": "Decode String", "memory": "9.4 MB", "code": "class Solution {\npublic:\n    string decodeString(string s) {\n        stack<string> stk;\n        int i = 0;\n        while(i  < s.size()){\n            if(s[i] <= '9' && s[i] >= '0'){\n                string tmp = \"\";\n                while(i < s.size() && (s[i] <= '9' && s[i] >= '0')){\n                    tmp += s[i];\n                    i ++;\n                }\n                stk.push(tmp);\n            }else if (s[i] == '['){\n                stk.push(\"[\");\n                i ++;\n            }else if (s[i] == ']'){\n                string tp = \"\";\n                while(stk.top() != \"[\"){\n                    tp = stk.top() + tp;\n                    stk.pop();\n                }\n                // pop [\n                stk.pop();\n                //\n                int repeat = stoi(stk.top());\n                stk.pop();\n                stk.push(repeatStr(tp,repeat));\n                i ++;\n            }else{\n                stk.push(string(1,s[i]));\n                i ++;\n            }\n        }\n        string sret= \"\";\n        while(!stk.empty()){\n            sret = stk.top()+sret;\n            stk.pop();\n        }\n        return sret;\n    }\n    string repeatStr(string & str,int times){\n        string s = \"\";\n        for(int i = 0;i < times;i ++){\n            s = s + str;\n        }\n        return s;\n    }\n};", "compare_result": "11111111111111111111111111111"}, {"id": 290464007, "lang": "cpp", "time": "1\u00a0day, 9\u00a0hours", "timestamp": 1577953131, "status_display": "Accepted", "runtime": "32 ms", "url": "/submissions/detail/290464007/", "is_pending": "Not Pending", "title": "Kth Smallest Element in a Sorted Matrix", "memory": "11.9 MB", "code": "class Solution {\npublic:\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\n        long minv = matrix[0][0];\n        long maxv = matrix[matrix.size()-1][matrix[0].size()-1];\n        while(minv <= maxv){\n            int mid  = (maxv + minv) >> 1;\n            int count = getLessEqual(matrix,mid);\n            if (count < k){\n                minv = mid +1;\n            }else{\n                maxv = mid -1;\n            }\n        }\n        return minv;\n    }\n    \n    int getLessEqual(vector<vector<int>>& matrix,int val){\n        int sz = matrix.size();\n        int row = sz - 1;\n        int col = 0;\n        int count = 0;\n        while (row >= 0 &&  col < sz){\n            if(matrix[row][col] <= val){\n                count += (row+1);\n                col ++;\n            }else{\n                row --;\n            }\n        }\n        return count;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 290463893, "lang": "cpp", "time": "1\u00a0day, 9\u00a0hours", "timestamp": 1577953098, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/290463893/", "is_pending": "Not Pending", "title": "Kth Smallest Element in a Sorted Matrix", "memory": "N/A", "code": "class Solution {\npublic:\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\n        int minv = matrix[0][0];\n        int maxv = matrix[matrix.size()-1][matrix[0].size()-1];\n        while(minv <= maxv){\n            int mid  = minv + (maxv -minv) >> 1;\n            int count = getLessEqual(matrix,mid);\n            if (count < k){\n                minv = mid +1;\n            }else{\n                maxv = mid -1;\n            }\n        }\n        return minv;\n    }\n    \n    int getLessEqual(vector<vector<int>>& matrix,int val){\n        int sz = matrix.size();\n        int row = sz - 1;\n        int col = 0;\n        int count = 0;\n        while (row >= 0 &&  col < sz){\n            if(matrix[row][col] <= val){\n                count += (row+1);\n                col ++;\n            }else{\n                row --;\n            }\n        }\n        return count;\n    }\n};", "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 290463805, "lang": "cpp", "time": "1\u00a0day, 9\u00a0hours", "timestamp": 1577953072, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/290463805/", "is_pending": "Not Pending", "title": "Kth Smallest Element in a Sorted Matrix", "memory": "N/A", "code": "class Solution {\npublic:\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\n        int minv = matrix[0][0];\n        int maxv = matrix[matrix.size()-1][matrix[0].size()-1];\n        while(minv <= maxv){\n            int mid  = (maxv + minv) >> 1;\n            int count = getLessEqual(matrix,mid);\n            if (count < k){\n                minv = mid +1;\n            }else{\n                maxv = mid -1;\n            }\n        }\n        return minv;\n    }\n    \n    int getLessEqual(vector<vector<int>>& matrix,int val){\n        int sz = matrix.size();\n        int row = sz - 1;\n        int col = 0;\n        int count = 0;\n        while (row >= 0 &&  col < sz){\n            if(matrix[row][col] <= val){\n                count += (row+1);\n                col ++;\n            }else{\n                row --;\n            }\n        }\n        return count;\n    }\n};", "compare_result": "1100000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 290438332, "lang": "cpp", "time": "1\u00a0day, 11\u00a0hours", "timestamp": 1577946128, "status_display": "Accepted", "runtime": "68 ms", "url": "/submissions/detail/290438332/", "is_pending": "Not Pending", "title": "Lexicographical Numbers", "memory": "11.7 MB", "code": "class Solution {\npublic:\n    vector<int> lexicalOrder(int n) {\n        vector<int> results;\n        int counts = 0;\n        int t = 1;\n        while(counts < n){\n            if(t <= n){\n                results.push_back(t);\n                counts ++;\n                t = t * 10;\n            }else{\n                t =t/ 10;\n                t = t +1;\n                while(t != 0 && t %10 == 0){\n                    t = t/10;\n                }\n            }\n        }\n        return results;\n    }\n};", "compare_result": "11111111111111111111111111"}, {"id": 289189631, "lang": "cpp", "time": "6\u00a0days, 7\u00a0hours", "timestamp": 1577530619, "status_display": "Accepted", "runtime": "16 ms", "url": "/submissions/detail/289189631/", "is_pending": "Not Pending", "title": "Find K Pairs with Smallest Sums", "memory": "9.8 MB", "code": "class Solution {\npublic:\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\n        vector<vector<int> > results;\n        if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n            return results;\n        }\n        \n        auto compare = [&nums1,&nums2](pair<int,int> &a,pair<int,int> &b){\n            return nums1[a.first] + nums2[a.second] >  nums1[b.first] + nums2[b.second];\n        };\n        priority_queue<pair<int,int>,vector<pair<int,int> > ,decltype(compare) > min_pq(compare);\n        \n        min_pq.emplace(0,0);\n        while(k -- > 0 && min_pq.size() > 0){\n            auto idx_pair = min_pq.top();\n            min_pq.pop();\n            \n            //\n            results.push_back({nums1[idx_pair.first],nums2[idx_pair.second]});\n            if(idx_pair.first +1 < nums1.size() ){\n                min_pq.emplace(idx_pair.first+1,idx_pair.second);\n            }\n            if(idx_pair.first == 0 && idx_pair.second +1 < nums2.size()){\n                min_pq.emplace(idx_pair.first,idx_pair.second+1);\n            }\n            \n        }\n        return results;\n        \n    }\n};", "compare_result": "111111111111111111111111111"}, {"id": 289173420, "lang": "cpp", "time": "6\u00a0days, 9\u00a0hours", "timestamp": 1577522566, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/289173420/", "is_pending": "Not Pending", "title": "Find K Pairs with Smallest Sums", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\n        vector<vector<int> > results;\n        int i = 0;\n        int j = 0;\n        int t = 0;\n        int sz1 = nums1.size();\n        int sz2 = nums2.size();\n        while(t < k && i < sz1 && j < sz2){\n            results.push_back({nums1[i],nums2[j]});\n            if((nums1[i] <= nums2[j] && i < (sz1-1)) || (j == (sz2-1))){\n                i ++;\n            }else{\n                j ++;\n            }\n            t ++;\n        }\n        return results;\n    }\n};", "compare_result": "011110000010000000010000000"}, {"id": 289172870, "lang": "cpp", "time": "6\u00a0days, 9\u00a0hours", "timestamp": 1577522368, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/289172870/", "is_pending": "Not Pending", "title": "Find K Pairs with Smallest Sums", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\n        vector<vector<int> > results;\n        int i = 0;\n        int j = 0;\n        int t = 0;\n        int sz1 = nums1.size();\n        int sz2 = nums2.size();\n        while(t < k && i < sz1 && j < sz2){\n            results.push_back({nums1[i],nums2[j]});\n            if(nums1[i] <= nums2[j] && j < (sz2-1)){\n                j ++;\n            }else{\n                i ++;\n            }\n            t ++;\n        }\n        return results;\n    }\n};", "compare_result": "111100000010000000010000000"}, {"id": 289161152, "lang": "cpp", "time": "6\u00a0days, 10\u00a0hours", "timestamp": 1577518320, "status_display": "Accepted", "runtime": "12 ms", "url": "/submissions/detail/289161152/", "is_pending": "Not Pending", "title": "Super Pow", "memory": "10 MB", "code": "class Solution {\npublic:\n    const int MD = 1337;\n    int bpow(int a,int b){\n        a = a% MD;\n        int result = 1;\n        for(int i = 0;i < b;i ++){\n            result = (result * a)%MD;\n        }\n        return result;\n    }\n    int superPow(int a, vector<int>& b) {\n        if(b.empty()) return 1;\n        int last = b.back();\n        b.pop_back();\n        \n        return bpow(superPow(a,b),10) * bpow(a,last) %MD;\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111"}, {"id": 289158519, "lang": "cpp", "time": "6\u00a0days, 10\u00a0hours", "timestamp": 1577517443, "status_display": "Accepted", "runtime": "20 ms", "url": "/submissions/detail/289158519/", "is_pending": "Not Pending", "title": "Flatten Nested List Iterator", "memory": "18.4 MB", "code": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * class NestedInteger {\n *   public:\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     bool isInteger() const;\n *\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\n *     // The result is undefined if this NestedInteger holds a nested list\n *     int getInteger() const;\n *\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\n *     // The result is undefined if this NestedInteger holds a single integer\n *     const vector<NestedInteger> &getList() const;\n * };\n */\nclass NestedIterator {\npublic:\n    stack<NestedInteger> stk;\n    NestedIterator(vector<NestedInteger> &nestedList) {\n        for(int i = nestedList.size()-1;i >=0;i --){\n            stk.push(nestedList[i]);\n        }\n    }\n\n    int next() {\n        int val = stk.top().getInteger();\n        stk.pop();\n        return val;\n    }\n\n    bool hasNext() {\n        while(!stk.empty() && !stk.top().isInteger()){\n            vector<NestedInteger> ni = stk.top().getList();\n            stk.pop();\n            for(int i = ni.size()-1;i >= 0;i--){\n                stk.push(ni[i]);\n            }\n        }\n        return !stk.empty();\n    }\n};\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * NestedIterator i(nestedList);\n * while (i.hasNext()) cout << i.next();\n */", "compare_result": "11111111111111111111111111111111111111111111"}, {"id": 289158145, "lang": "cpp", "time": "6\u00a0days, 10\u00a0hours", "timestamp": 1577517324, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/289158145/", "is_pending": "Not Pending", "title": "Flatten Nested List Iterator", "memory": "N/A", "code": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * class NestedInteger {\n *   public:\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     bool isInteger() const;\n *\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\n *     // The result is undefined if this NestedInteger holds a nested list\n *     int getInteger() const;\n *\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\n *     // The result is undefined if this NestedInteger holds a single integer\n *     const vector<NestedInteger> &getList() const;\n * };\n */\nclass NestedIterator {\npublic:\n    stack<NestedInteger> stk;\n    NestedIterator(vector<NestedInteger> &nestedList) {\n        for(int i = nestedList.size()-1;i >=0;i --){\n            stk.push(nestedList[i]);\n        }\n    }\n\n    int next() {\n        while(!stk.top().isInteger()){\n            vector<NestedInteger> ni = stk.top().getList();\n            stk.pop();\n            for(int i = ni.size()-1;i >= 0;i--){\n                stk.push(ni[i]);\n            }\n        }\n        int val = stk.top().getInteger();\n        stk.pop();\n        return val;\n    }\n\n    bool hasNext() {\n        return !stk.empty();\n    }\n};\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * NestedIterator i(nestedList);\n * while (i.hasNext()) cout << i.next();\n */", "compare_result": "11111111110000000000000000000000000000000000"}, {"id": 289155900, "lang": "cpp", "time": "6\u00a0days, 10\u00a0hours", "timestamp": 1577516652, "status_display": "Accepted", "runtime": "148 ms", "url": "/submissions/detail/289155900/", "is_pending": "Not Pending", "title": "Minimum Height Trees", "memory": "51.1 MB", "code": "class Solution {\npublic:\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n        if(n == 1) return vector<int>(1,0);\n        unordered_map<int,unordered_set<int> > table;\n        for(auto t : edges){\n            table[t[0]].insert(t[1]);\n            table[t[1]].insert(t[0]);\n        }\n        \n        set<int> remove1;\n        for(auto ky : table){\n            if(ky.second.size() == 1){\n                remove1.insert(ky.first);\n            }\n        }\n        set<int> remove2 = remove1;\n        \n        while(remove1.size() > 0){\n            remove2.clear();\n            for(auto t : remove1){\n                for(auto k : table[t]){\n                    if(table.find(k) != table.end())\n                    {\n                         table[k].erase(t);\n                    }\n                    if(table[k].size() == 1){\n                        remove2.insert(k);\n                    }\n                }\n                \n                // table.erase(t);\n            }\n            swap(remove2,remove1);\n        }\n        return vector<int>(remove2.begin(),remove2.end());\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 288951084, "lang": "cpp", "time": "1\u00a0week", "timestamp": 1577449370, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/288951084/", "is_pending": "Not Pending", "title": "Construct Binary Search Tree from Preorder Traversal", "memory": "10.8 MB", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\n        int sz  = preorder.size();\n        return bstFromPreorder(preorder,0,sz-1);\n    }\n    \n    TreeNode * bstFromPreorder(vector<int>&pre,int start,int end){\n        if(start > end){\n            return NULL;\n        }\n        int ky = pre[start];\n        int right = start+1;\n        while(right <= end && pre[right] < ky){\n            right ++;\n        }\n        TreeNode * root = new TreeNode(ky);\n        root->left = bstFromPreorder(pre,start+1,right-1);\n        root->right = bstFromPreorder(pre,right,end);\n        return root;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 288950543, "lang": "cpp", "time": "1\u00a0week", "timestamp": 1577449023, "status_display": "Accepted", "runtime": "20 ms", "url": "/submissions/detail/288950543/", "is_pending": "Not Pending", "title": "Top K Frequent Elements", "memory": "11.3 MB", "code": "class Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        if(nums.size() == 0 || k == 0){\n            return {};\n        }\n        unordered_map<int,int> frequency;\n        for(auto i : nums){\n            frequency[i] ++;\n        }\n        \n        auto compare = [&frequency](int &lhs,int &rhs){\n            return frequency[lhs] < frequency[rhs];\n        };\n        \n        priority_queue<int,vector<int>, decltype(compare)> pq(compare);\n        for(auto item: frequency){\n            pq.push(item.first);\n        }\n        vector<int> rets;\n        for(int i = 0;i < k;i ++){\n            rets.push_back(pq.top());\n            pq.pop();\n        }\n        return rets;\n        \n    }\n};", "compare_result": "111111111111111111111"}, {"id": 288931366, "lang": "cpp", "time": "1\u00a0week", "timestamp": 1577438758, "status_display": "Accepted", "runtime": "28 ms", "url": "/submissions/detail/288931366/", "is_pending": "Not Pending", "title": "House Robber III", "memory": "28 MB", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int rob(TreeNode* root) {\n        vector<int> rb = robOne(root);\n        return max(rb[0],rb[1]);\n        // return rob(root,false);\n    }\n    // int rob(TreeNode*root,bool status){\n    //     if(root==NULL) return 0;\n    //     if(status){\n    //         return rob(root->left,false) + rob(root->right,false);\n    //     }\n    //     return max(rob(root->left,false) + rob(root->right,false),rob(root->left,true) + rob(root->right,true) + root->val);\n    // }\n    \n    vector<int> robOne(TreeNode * root){\n        if(root == NULL) return {0,0};\n        vector<int> left = robOne(root->left);\n        vector<int> right = robOne(root->right);\n        \n        int robCur = root->val + left[1] + right[1];\n        int robChild = max(left[0],left[1]) + max(right[0],right[1]);\n        \n        return {robCur,robChild};\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 288928929, "lang": "cpp", "time": "1\u00a0week", "timestamp": 1577437717, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/288928929/", "is_pending": "Not Pending", "title": "House Robber III", "memory": "N/A", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int rob(TreeNode* root) {\n        return rob(root,false);\n    }\n    int rob(TreeNode*root,bool status){\n        if(root==NULL) return 0;\n        if(status){\n            return rob(root->left,false) + rob(root->right,false);\n        }\n        return max(rob(root->left,false) + rob(root->right,false),rob(root->left,true) + rob(root->right,true) + root->val);\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110"}, {"id": 288928281, "lang": "cpp", "time": "1\u00a0week", "timestamp": 1577437455, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/288928281/", "is_pending": "Not Pending", "title": "Increasing Triplet Subsequence", "memory": "9 MB", "code": "class Solution {\npublic:\n    bool increasingTriplet(vector<int>& nums) {\n        vector<int> arr(4,INT_MAX);\n        // int m1 = INT_MAX;\n        // int m2 = INT_MAX;\n        for(auto i : nums){\n            int j = 0;\n            while(j < 3){\n                if(i <= arr[j]){\n                    arr[j] = i;\n                    break;\n                }else{\n                    j ++;\n                }\n            }\n            if(j >= 2){\n                return true;\n            }\n            // if(i <= m1){\n            //     m1 = i;\n            // }else if ( i <= m2){\n            //     m2 = i;\n            // }else{\n            //     return true;\n            // }\n        }\n        \n        \n        \n        return false;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111"}, {"id": 288928165, "lang": "cpp", "time": "1\u00a0week", "timestamp": 1577437398, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/288928165/", "is_pending": "Not Pending", "title": "Increasing Triplet Subsequence", "memory": "N/A", "code": "class Solution {\npublic:\n    bool increasingTriplet(vector<int>& nums) {\n        vector<int> arr(4,INT_MAX);\n        // int m1 = INT_MAX;\n        // int m2 = INT_MAX;\n        for(auto i : nums){\n            int j = 0;\n            while(j < 3){\n                if(i <= arr[j]){\n                    arr[j] = i;\n                    break;\n                }else{\n                    j ++;\n                }\n            }\n            if(j >= 3){\n                return true;\n            }\n            // if(i <= m1){\n            //     m1 = i;\n            // }else if ( i <= m2){\n            //     m2 = i;\n            // }else{\n            //     return true;\n            // }\n        }\n        \n        \n        \n        return false;\n    }\n};", "compare_result": "11011111100010111001111111111111111111111111111111111111100011"}, {"id": 288928086, "lang": "cpp", "time": "1\u00a0week", "timestamp": 1577437359, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/288928086/", "is_pending": "Not Pending", "title": "Increasing Triplet Subsequence", "memory": "N/A", "code": "class Solution {\npublic:\n    bool increasingTriplet(vector<int>& nums) {\n        vector<int> arr(4,INT_MAX);\n        // int m1 = INT_MAX;\n        // int m2 = INT_MAX;\n        for(auto i : nums){\n            int j = 0;\n            while(j < 3){\n                if(i <= arr[j]){\n                    arr[j] = i;\n                }else{\n                    j ++;\n                }\n            }\n            if(j >= 3){\n                return true;\n            }\n            // if(i <= m1){\n            //     m1 = i;\n            // }else if ( i <= m2){\n            //     m2 = i;\n            // }else{\n            //     return true;\n            // }\n        }\n        \n        \n        \n        return false;\n    }\n};", "compare_result": "00000000000000000000000000000000000000000000000000000000000000"}, {"id": 288927779, "lang": "cpp", "time": "1\u00a0week", "timestamp": 1577437225, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/288927779/", "is_pending": "Not Pending", "title": "Increasing Triplet Subsequence", "memory": "8.9 MB", "code": "class Solution {\npublic:\n    bool increasingTriplet(vector<int>& nums) {\n        int m1 = INT_MAX;\n        int m2 = INT_MAX;\n        for(auto i : nums){\n            if(i <= m1){\n                m1 = i;\n            }else if ( i <= m2){\n                m2 = i;\n            }else{\n                return true;\n            }\n        }\n        return false;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111"}, {"id": 288927708, "lang": "cpp", "time": "1\u00a0week", "timestamp": 1577437189, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/288927708/", "is_pending": "Not Pending", "title": "Increasing Triplet Subsequence", "memory": "N/A", "code": "class Solution {\npublic:\n    bool increasingTriplet(vector<int>& nums) {\n        int m1 = INT_MAX;\n        int m2 = INT_MAX;\n        for(auto i : nums){\n            if(i < m1){\n                m1 = i;\n            }else if ( i < m2){\n                m2 = i;\n            }else{\n                return true;\n            }\n        }\n        return false;\n    }\n};", "compare_result": "11111100111111000110111000000000100000000010000000000000011101"}, {"id": 288926811, "lang": "cpp", "time": "1\u00a0week", "timestamp": 1577436827, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/288926811/", "is_pending": "Not Pending", "title": "Increasing Triplet Subsequence", "memory": "N/A", "code": "class Solution {\npublic:\n    bool increasingTriplet(vector<int>& nums) {\n        vector<int> arr(4,INT_MIN);\n        int index = 0;\n        for(auto i : nums){\n            int j = 0;\n            while(j < 3){\n                if(i > arr[j]){\n                    swap(i,arr[j]);\n                    j ++;\n                }else{\n                    swap(i,arr[j]);\n                    break;\n                }\n            }\n            if(j == 3){\n                return true;\n            }\n        }\n        return false;\n    }\n};", "compare_result": "11111111111111111011111111111111111111111111111111111111110011"}, {"id": 288922975, "lang": "cpp", "time": "1\u00a0week", "timestamp": 1577435462, "status_display": "Accepted", "runtime": "104 ms", "url": "/submissions/detail/288922975/", "is_pending": "Not Pending", "title": "Reconstruct Itinerary", "memory": "58.4 MB", "code": "class Solution {\npublic:\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\n        map<string,multiset<string> > table;\n        for(auto sts : tickets){\n            table[sts[0]].insert(sts[1]);\n        }\n        vector<string> rets;\n        string from = \"JFK\";\n        rets.push_back(from);\n        vector<string> r = getMinString(table,from);\n        rets.insert(rets.end(),r.begin(),r.end());\n        return rets;\n    }\n    \n    vector<string> getMinString(map<string,multiset<string> > &table,string from){\n        vector<string> rets;\n        if(table.find(from) == table.end()){\n            return rets;\n        }\n        multiset<string> tos = table[from];\n        for (auto  to : tos){\n            rets.push_back(to);\n            table[from].erase(table[from].lower_bound(to));\n            if(table[from].size() <=0){\n                table.erase(from);\n            }\n            if(table.size() > 0){\n                vector<string> r = getMinString(table,to);\n                if(r.size() == 0){\n                    //roll back\n                    rets.pop_back();\n                    table[from].insert(to);\n                }else{\n                    rets.insert(rets.end(),r.begin(),r.end());\n                    break;\n                }\n                \n            }else{\n                break;\n            }\n        }\n        return rets;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 288912852, "lang": "cpp", "time": "1\u00a0week", "timestamp": 1577432188, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/288912852/", "is_pending": "Not Pending", "title": "Reconstruct Itinerary", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\n        map<string,multiset<string> > table;\n        for(auto sts : tickets){\n            table[sts[0]].insert(sts[1]);\n        }\n        vector<string> rets;\n        string from = \"JFK\";\n        rets.push_back(from);\n        vector<string> r = getMinString(table,from);\n        rets.insert(rets.end(),r.begin(),r.end());\n        return rets;\n    }\n    \n    vector<string> getMinString(map<string,multiset<string> > &table,string from){\n        vector<string> rets;\n        if(table.find(from) == table.end()){\n            return rets;\n        }\n        auto tos = table[from];\n        for (auto to : tos){\n            rets.push_back(to);\n            table[from].erase(to);\n            if(table[from].size() <=0){\n                table.erase(from);\n            }\n            if(table.size() > 0){\n                vector<string> r = getMinString(table,to);\n                if(r.size() == 0){\n                    //roll back\n                    rets.pop_back();\n                    table[from].insert(to);\n                }else{\n                    rets.insert(rets.end(),r.begin(),r.end());\n                    break;\n                }\n                \n            }else{\n                break;\n            }\n        }\n        return rets;\n    }\n};", "compare_result": "11111111000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 288910389, "lang": "cpp", "time": "1\u00a0week", "timestamp": 1577431430, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/288910389/", "is_pending": "Not Pending", "title": "Reconstruct Itinerary", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\n        map<string,set<string> > table;\n        for(auto sts : tickets){\n            table[sts[0]].insert(sts[1]);\n        }\n        vector<string> rets;\n        string from = \"JFK\";\n        rets.push_back(from);\n        vector<string> r = getMinString(table,from);\n        rets.insert(rets.end(),r.begin(),r.end());\n        return rets;\n    }\n    \n    vector<string> getMinString(map<string,set<string> > &table,string from){\n        vector<string> rets;\n        if(table.find(from) == table.end()){\n            return rets;\n        }\n        auto tos = table[from];\n        for (auto to : tos){\n            rets.push_back(to);\n            table[from].erase(to);\n            if(table[from].size() <=0){\n                table.erase(from);\n            }\n            if(table.size() > 0){\n                vector<string> r = getMinString(table,to);\n                if(r.size() == 0){\n                    //roll back\n                    rets.pop_back();\n                    table[from].insert(to);\n                }else{\n                    rets.insert(rets.end(),r.begin(),r.end());\n                    break;\n                }\n                \n            }else{\n                break;\n            }\n        }\n        return rets;\n    }\n};", "compare_result": "11111111000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 288909984, "lang": "cpp", "time": "1\u00a0week", "timestamp": 1577431305, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/288909984/", "is_pending": "Not Pending", "title": "Reconstruct Itinerary", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\n        map<string,set<string> > table;\n        for(auto sts : tickets){\n            table[sts[0]].insert(sts[1]);\n        }\n        vector<string> rets;\n        string from = \"JFK\";\n        rets.push_back(from);\n        vector<string> r = getMinString(table,from);\n        rets.insert(rets.end(),r.begin(),r.end());\n        return rets;\n    }\n    \n    vector<string> getMinString(map<string,set<string> > &table,string from){\n        vector<string> rets;\n        if(table.find(from) == table.end()){\n            return rets;\n        }\n        auto tos = table[from];\n        for (auto to : tos){\n            rets.push_back(to);\n            table[from].erase(to);\n            if(table[from].size() <=0){\n                table.erase(from);\n            }\n            if(table.size() > 0){\n                vector<string> r = getMinString(table,to);\n                if(r.size() == 0){\n                    //roll back\n                    rets.pop_back();\n                    table[from].insert(to);\n                }else{\n                    rets.insert(rets.end(),r.begin(),r.end());\n                }\n                \n            }else{\n                break;\n            }\n        }\n        return rets;\n    }\n};", "compare_result": "10111010000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 288879605, "lang": "cpp", "time": "1\u00a0week", "timestamp": 1577423237, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/288879605/", "is_pending": "Not Pending", "title": "Reconstruct Itinerary", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\n        map<string,set<string> > table;\n        for(auto sts : tickets){\n            table[sts[0]].insert(sts[1]);\n        }\n        vector<string> rets;\n        string from = \"JFK\";\n        rets.push_back(from);\n        while(table.size() > 0){\n            string to = \"\";\n            if(table.find(from) == table.end()){\n                to = table.begin()->first;\n            }else{\n                to = *table[from].begin();\n                table[from].erase(to);\n                if(table[from].size() <=0){\n                    table.erase(from);\n                }\n            }\n            rets.push_back(to);\n            from = to;\n        }\n        return rets;\n    }\n};", "compare_result": "11110110000000000000000000000001000000000000000000000100000000010000000000000000"}, {"id": 288859808, "lang": "cpp", "time": "1\u00a0week", "timestamp": 1577417811, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/288859808/", "is_pending": "Not Pending", "title": "Verify Preorder Serialization of a Binary Tree", "memory": "9.2 MB", "code": "class Solution {\npublic:\n    bool isValidSerialization(string preorder) {\n        int nullCount = 0;\n        int nodeCount = 0;\n        stringstream ss(preorder);\n        string token;\n        bool status = false;\n        while(getline(ss,token,',')){\n            if(status){\n                return false;\n            }\n            if(token == \"#\"){\n                nullCount ++;\n            }else{\n                nodeCount ++;\n            }\n            if(nullCount >= nodeCount +1){\n                status = true;\n            }\n        }\n        \n        return nullCount == (nodeCount +1);\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 288689084, "lang": "cpp", "time": "1\u00a0week, 1\u00a0day", "timestamp": 1577362452, "status_display": "Accepted", "runtime": "24 ms", "url": "/submissions/detail/288689084/", "is_pending": "Not Pending", "title": "Odd Even Linked List", "memory": "9.6 MB", "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* oddEvenList(ListNode* head) {\n        ListNode * odd= NULL;\n        ListNode * even = NULL;\n        ListNode * teven = NULL;\n        ListNode *p = head;\n        \n        while(p != NULL){\n            ListNode * q = p->next;\n            p->next = NULL;\n            if(odd == NULL){\n                odd = p;\n            }else{\n                odd->next = p;\n                odd = p;\n            }\n            p = q;\n            if(p != NULL){\n                q = p->next;\n                p->next = NULL;\n                if(even == NULL){\n                    even = p;\n                    teven = p;\n                }else{\n                    teven->next = p;\n                    teven = p;\n                }\n                p = q;\n            }\n        }\n        if(odd != NULL){\n            odd->next = even;\n        }\n        return head;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 288673087, "lang": "cpp", "time": "1\u00a0week, 1\u00a0day", "timestamp": 1577354357, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/288673087/", "is_pending": "Not Pending", "title": "Bulb Switcher", "memory": "8.1 MB", "code": "class Solution {\npublic:\n    int bulbSwitch(int n) {\n        return sqrt(n);\n    }\n};", "compare_result": "11111111111111111111111111111111111"}, {"id": 288670246, "lang": "cpp", "time": "1\u00a0week, 1\u00a0day", "timestamp": 1577353178, "status_display": "Accepted", "runtime": "1604 ms", "url": "/submissions/detail/288670246/", "is_pending": "Not Pending", "title": "Maximum Product of Word Lengths", "memory": "18 MB", "code": "class Solution {\npublic:\n    int maxProduct(vector<string>& words) {\n        map<string,int> table;\n        for(auto wd : words){\n            int key = 0;\n            for(auto ch: wd){\n                int idx = 1 << (ch - 'a');\n                key = key | idx;\n            }\n            // cout << wd << \" \" <<  key << endl;\n            table[wd] = key;\n        }\n        int maxP = 0;\n        for(int i = 0;i < words.size();i ++){\n            for(int j = i+1;j < words.size();j ++){\n                // cout << (table[words[i]] & table[words[j]] )<< endl;\n                if((table[words[i]] & table[words[j]]) == 0){\n                    int len = words[i].size() * words[j].size();\n                    maxP = max(maxP,len);\n                }                \n            }\n        }\n        return maxP;\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 288657610, "lang": "cpp", "time": "1\u00a0week, 1\u00a0day", "timestamp": 1577348485, "status_display": "Accepted", "runtime": "52 ms", "url": "/submissions/detail/288657610/", "is_pending": "Not Pending", "title": "Super Ugly Number", "memory": "9.8 MB", "code": "class Solution {\npublic:\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\n        vector<long> index(primes.size(),0);\n        vector<long> ugly(n,INT_MAX);\n        ugly[0] = 1;\n        for(int i = 1;i <n;i ++){\n            for(int j = 0;j < primes.size();j ++){\n                ugly[i] = min(ugly[i],primes[j]*ugly[index[j]]);\n            }\n            for(int j = 0;j < primes.size();j ++){\n                index[j] += (ugly[i] == primes[j]*ugly[index[j]]);\n            }\n        }\n        return ugly[n-1];\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 288642182, "lang": "cpp", "time": "1\u00a0week, 1\u00a0day", "timestamp": 1577343639, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/288642182/", "is_pending": "Not Pending", "title": "Minimum Height Trees", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n        if(n == 1) return vector<int>(1,0);\n        unordered_map<int,unordered_set<int> > table;\n        for(auto t : edges){\n            table[t[0]].insert(t[1]);\n            table[t[1]].insert(t[0]);\n        }\n        set<int> removes;\n        while(table.size() > 0){\n            removes.clear();\n            for(auto t : table){\n                if(t.second.size() <= 1){\n                    removes.insert(t.first);\n                }\n            }\n            for(auto t : removes){\n                for(auto k : table[t]){\n                    // if(table.find(k) != table.end())\n                    {\n                         table[k].erase(t);\n                    }\n                }\n                table.erase(t);\n            }\n        }\n        return vector<int>(removes.begin(),removes.end());\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111000"}, {"id": 288640648, "lang": "cpp", "time": "1\u00a0week, 1\u00a0day", "timestamp": 1577343204, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/288640648/", "is_pending": "Not Pending", "title": "Minimum Height Trees", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n        if(n == 1) return vector<int>(1,0);\n        map<int,set<int> > table;\n        for(auto t : edges){\n            table[t[0]].insert(t[1]);\n            table[t[1]].insert(t[0]);\n        }\n        set<int> removes;\n        while(table.size() > 0){\n            removes.clear();\n            for(auto t : table){\n                if(t.second.size() <= 1){\n                    removes.insert(t.first);\n                }\n            }\n            for(auto t : removes){\n                for(auto k : table[t]){\n                    if(table.find(k) != table.end()){\n                         table[k].erase(t);\n                    }\n                }\n                table.erase(t);\n            }\n        }\n        return vector<int>(removes.begin(),removes.end());\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111000"}, {"id": 288640269, "lang": "cpp", "time": "1\u00a0week, 1\u00a0day", "timestamp": 1577343085, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/288640269/", "is_pending": "Not Pending", "title": "Minimum Height Trees", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n        map<int,set<int> > table;\n        for(auto t : edges){\n            table[t[0]].insert(t[1]);\n            table[t[1]].insert(t[0]);\n        }\n        set<int> removes;\n        while(table.size() > 0){\n            removes.clear();\n            for(auto t : table){\n                if(t.second.size() <= 1){\n                    removes.insert(t.first);\n                }\n            }\n            for(auto t : removes){\n                for(auto k : table[t]){\n                    if(table.find(k) != table.end()){\n                         table[k].erase(t);\n                    }\n                }\n                table.erase(t);\n            }\n            // cout << table.size() << endl;\n            // break;\n        }\n        return vector<int>(removes.begin(),removes.end());\n    }\n};", "compare_result": "110111111111111111111111111111111111111111111111111111111111111000"}, {"id": 288606091, "lang": "cpp", "time": "1\u00a0week, 1\u00a0day", "timestamp": 1577333006, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/288606091/", "is_pending": "Not Pending", "title": "Find the Duplicate Number", "memory": "9.9 MB", "code": "class Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        int i = 0;\n        while (i < nums.size()){\n            while(nums[i] != i+1){\n                if(nums[i] == nums[nums[i]-1]) return nums[i];\n                swap(nums[i],nums[nums[i]-1]);\n            }\n            i ++;\n        }\n        return 0;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111"}, {"id": 288605848, "lang": "cpp", "time": "1\u00a0week, 1\u00a0day", "timestamp": 1577332937, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/288605848/", "is_pending": "Not Pending", "title": "Find the Duplicate Number", "memory": "N/A", "code": "class Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        int i = 0;\n        while (i < nums.size()){\n            while(nums[i] != i+1){\n                if(nums[i] == nums[nums[i]]) return nums[i];\n                swap(nums[i],nums[nums[i]]);\n            }\n            i ++;\n        }\n        return 0;\n    }\n};", "compare_result": "11111111011111111111111111111111111111111111111111111"}, {"id": 288604547, "lang": "cpp", "time": "1\u00a0week, 1\u00a0day", "timestamp": 1577332550, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/288604547/", "is_pending": "Not Pending", "title": "Find the Duplicate Number", "memory": "N/A", "code": "class Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        int n = nums.size();\n        int sum = 1;\n        for(int i = 2;i <=n-1;i ++){\n            sum = sum ^ i;\n        }\n        for(auto i : nums){\n            sum = sum ^ i;\n        }\n        return sum;\n    }\n};", "compare_result": "11111110100010000100000000001100000000000000000000001"}, {"id": 288603869, "lang": "cpp", "time": "1\u00a0week, 1\u00a0day", "timestamp": 1577332356, "status_display": "Accepted", "runtime": "20 ms", "url": "/submissions/detail/288603869/", "is_pending": "Not Pending", "title": "H-Index II", "memory": "12.5 MB", "code": "class Solution {\npublic:\n    int hIndex(vector<int>& citations) {\n        if(citations.size() <= 0) return 0;\n        int left = 0;\n        int right = citations.size()-1;\n        int len = citations.size() ;\n        while(left <= right){\n            int mid = (left+right) >>1;\n            if(citations[mid] == (len - mid)) return citations[mid];\n            if (citations[mid] < (len - mid)){\n                left = mid +1;\n            }else{\n                right = mid -1;\n            }\n        }\n        return len - (right +1);\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 288601712, "lang": "cpp", "time": "1\u00a0week, 1\u00a0day", "timestamp": 1577331722, "status_display": "Accepted", "runtime": "56 ms", "url": "/submissions/detail/288601712/", "is_pending": "Not Pending", "title": "Search a 2D Matrix II", "memory": "12.9 MB", "code": "class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        if(matrix.size() <=0) return false;\n        \n        int i = 0,j = matrix[0].size()-1;\n        while(i < matrix.size() && j >= 0){\n            if(matrix[i][j] == target) return true;\n            if(matrix[i][j] < target){\n                i ++;\n            }else{\n                j --;\n            }\n        }\n        return false;\n        // return search(matrix,0,0,matrix.size()-1,matrix[0].size()-1,target);\n    }\n    \n    \n    bool search(vector<vector<int> >& matrix,int a,int b,int c,int d,int target){\n        if(a < 0 || a >= matrix.size() || b <0 || b>=matrix[0].size() \n           || c <0 || c>=matrix.size() || d <0 || d >=matrix[0].size())\n        {\n            return false;\n        }\n        if(a > c || b > d){\n            return false;\n        }\n        \n        int mi = (a+c)/2;\n        int mj = (b+d)/2;\n        if(matrix[mi][mj] == target){\n            return true;\n        }else if (matrix[mi][mj] < target){\n            return search(matrix,a,mj+1,mi,d,target) || search(matrix,mi+1,b,c,d,target);\n        }else{\n            return search(matrix,a,b,mi-1,d,target) || search(matrix,mi,b,c,mj-1,target);\n        }\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 288600963, "lang": "cpp", "time": "1\u00a0week, 1\u00a0day", "timestamp": 1577331499, "status_display": "Accepted", "runtime": "304 ms", "url": "/submissions/detail/288600963/", "is_pending": "Not Pending", "title": "Search a 2D Matrix II", "memory": "13 MB", "code": "class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        if(matrix.size() <=0) return false;\n        return search(matrix,0,0,matrix.size()-1,matrix[0].size()-1,target);\n    }\n    bool search(vector<vector<int> >& matrix,int a,int b,int c,int d,int target){\n        if(a < 0 || a >= matrix.size() || b <0 || b>=matrix[0].size() \n           || c <0 || c>=matrix.size() || d <0 || d >=matrix[0].size())\n        {\n            return false;\n        }\n        if(a > c || b > d){\n            return false;\n        }\n        \n        int mi = (a+c)/2;\n        int mj = (b+d)/2;\n        if(matrix[mi][mj] == target){\n            return true;\n        }else if (matrix[mi][mj] < target){\n            return search(matrix,a,mj+1,mi,d,target) || search(matrix,mi+1,b,c,d,target);\n        }else{\n            return search(matrix,a,b,mi-1,d,target) || search(matrix,mi,b,c,mj-1,target);\n        }\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 286831889, "lang": "cpp", "time": "2\u00a0weeks, 2\u00a0days", "timestamp": 1576654563, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/286831889/", "is_pending": "Not Pending", "title": "H-Index II", "memory": "N/A", "code": "class Solution {\npublic:\n    int hIndex(vector<int>& citations) {\n        int lo = 0;\n        if(citations.size() <= 0) return 0;\n        if(citations.size() == 1 ) return citations[0] >= 1;\n        int hi = citations.size()-1;\n        while(lo < hi){\n            int mid = (lo + hi)/2;\n            int h = citations.size() - mid+1;\n            // cout << h <<\" \" <<  citations[mid] << endl;\n            if(h <= citations[mid]){\n                hi = mid -1;\n            }else{\n                lo = mid + 1;\n            }\n        }\n        // cout<< hi << ' ' << lo << endl;\n        // if(hi)\n        return citations.size() - hi;\n    }\n};", "compare_result": "111110111110011111000001111110000000000111001100000111011011001010101011010101010001"}, {"id": 286831790, "lang": "cpp", "time": "2\u00a0weeks, 2\u00a0days", "timestamp": 1576654535, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/286831790/", "is_pending": "Not Pending", "title": "H-Index II", "memory": "N/A", "code": "class Solution {\npublic:\n    int hIndex(vector<int>& citations) {\n        int lo = 0;\n        if(citations.size() <= 0) return 0;\n        if(citations.size() == 1 && citations[0] >= 1) return 1;\n        int hi = citations.size()-1;\n        while(lo < hi){\n            int mid = (lo + hi)/2;\n            int h = citations.size() - mid+1;\n            // cout << h <<\" \" <<  citations[mid] << endl;\n            if(h <= citations[mid]){\n                hi = mid -1;\n            }else{\n                lo = mid + 1;\n            }\n        }\n        // cout<< hi << ' ' << lo << endl;\n        // if(hi)\n        return citations.size() - hi;\n    }\n};", "compare_result": "110110111110011111000001111110000000000111001100000111011011001010101011010101010001"}, {"id": 286831672, "lang": "cpp", "time": "2\u00a0weeks, 2\u00a0days", "timestamp": 1576654498, "status_display": "Compile Error", "runtime": "N/A", "url": "/submissions/detail/286831672/", "is_pending": "Not Pending", "title": "H-Index II", "memory": "N/A", "code": "class Solution {\npublic:\n    int hIndex(vector<int>& citations) {\n        int lo = 0;\n        if(citations.size() <= 0) return 0;\n        if(citations.size() == 1 && citations[0] > 1) return 1;\n        int hi = citations.size()-1;\n        while(lo < hi){\n            int mid = (lo + hi)/2;\n            int h = citations.size() - mid+1;\n            // cout << h <<\" \" <<  citations[mid] << endl;\n            if(h <= citations[mid]){\n                hi = mid -1;\n            }else{\n                lo = mid + 1;\n            }\n        }\n        // cout<< hi << ' ' << lo << endl;\n        if(hi)\n        return citations.size() - hi;\n    }\n};", "compare_result": null}, {"id": 286825903, "lang": "cpp", "time": "2\u00a0weeks, 2\u00a0days", "timestamp": 1576652839, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/286825903/", "is_pending": "Not Pending", "title": "H-Index II", "memory": "N/A", "code": "class Solution {\npublic:\n    int hIndex(vector<int>& citations) {\n        int lo = 0;\n        if(citations.size() <= 0) return 0;\n        int hi = citations.size()-1;\n        while(lo < hi){\n            int mid = (lo + hi)/2;\n            int h = citations.size() - mid+1;\n            // cout << h <<\" \" <<  citations[mid] << endl;\n            if(h <= citations[mid]){\n                hi = mid -1;\n            }else{\n                lo = mid + 1;\n            }\n        }\n        // cout<< hi << ' ' << lo << endl;\n        return citations.size() - hi;\n    }\n};", "compare_result": "110110111110011111000001111110000000000111001100000111011011001010101011010101010001"}, {"id": 286825801, "lang": "cpp", "time": "2\u00a0weeks, 2\u00a0days", "timestamp": 1576652810, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/286825801/", "is_pending": "Not Pending", "title": "H-Index II", "memory": "N/A", "code": "class Solution {\npublic:\n    int hIndex(vector<int>& citations) {\n        int lo = 0;\n        int hi = citations.size()-1;\n        while(lo < hi){\n            int mid = (lo + hi)/2;\n            int h = citations.size() - mid+1;\n            // cout << h <<\" \" <<  citations[mid] << endl;\n            if(h <= citations[mid]){\n                hi = mid -1;\n            }else{\n                lo = mid + 1;\n            }\n        }\n        // cout<< hi << ' ' << lo << endl;\n        return citations.size() - hi;\n    }\n};", "compare_result": "100110111110011111000001111110000000000111001100000111011011001010101011010101010001"}, {"id": 286822379, "lang": "cpp", "time": "2\u00a0weeks, 2\u00a0days", "timestamp": 1576651901, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/286822379/", "is_pending": "Not Pending", "title": "H-Index", "memory": "9 MB", "code": "class Solution {\npublic:\n    int hIndex(vector<int>& citations) {\n        sort(citations.begin(),citations.end(),greater<int>());\n        int i = 0;\n        int h = 0;\n        if(citations.size() <= 0) return 0;\n        while(i < citations.size() && citations[i] > h){\n            h ++;\n            i ++;\n        }\n        return h;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 286822272, "lang": "cpp", "time": "2\u00a0weeks, 2\u00a0days", "timestamp": 1576651873, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/286822272/", "is_pending": "Not Pending", "title": "H-Index", "memory": "N/A", "code": "class Solution {\npublic:\n    int hIndex(vector<int>& citations) {\n        sort(citations.begin(),citations.end(),greater<int>());\n        int i = 0;\n        int h = 0;\n        if(citations.size() <= 0) return 0;\n        while(citations[i] > h){\n            h ++;\n            i ++;\n        }\n        return h;\n    }\n};", "compare_result": "1110000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 286822172, "lang": "cpp", "time": "2\u00a0weeks, 2\u00a0days", "timestamp": 1576651849, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/286822172/", "is_pending": "Not Pending", "title": "H-Index", "memory": "N/A", "code": "class Solution {\npublic:\n    int hIndex(vector<int>& citations) {\n        sort(citations.begin(),citations.end(),greater<int>());\n        int i = 0;\n        int h = 0;\n        while(citations[i] > h){\n            h ++;\n            i ++;\n        }\n        return h;\n    }\n};", "compare_result": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 286813171, "lang": "cpp", "time": "2\u00a0weeks, 2\u00a0days", "timestamp": 1576649512, "status_display": "Accepted", "runtime": "12 ms", "url": "/submissions/detail/286813171/", "is_pending": "Not Pending", "title": "Rectangle Area", "memory": "8.3 MB", "code": "class Solution {\npublic:\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\n        long total = (C-A)*1L * (D - B) + (G - E) * (H - F);\n        if(C <= E || G <= A || D <= F || H <= B) {\n            return total;\n        }\n        int width = min(G,C) - max(E,A);\n        int height = min(D,H) - max(B,F);\n        return total - width*1L * height;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 286812222, "lang": "cpp", "time": "2\u00a0weeks, 2\u00a0days", "timestamp": 1576649268, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/286812222/", "is_pending": "Not Pending", "title": "Rectangle Area", "memory": "N/A", "code": "class Solution {\npublic:\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\n        long total = (C-A)*1L * (D - B) + (G - E) * (H - F);\n        if(C <= E || G <= A || D <= F || H <= A) {\n            return total;\n        }\n        int width = min(G,C) - max(E,A);\n        int height = min(D,H) - max(B,F);\n        return total - width*1L * height;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111101111111111110111111111111011111111111101111111111101111111111110111111111111011111111111101111111111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111111111111011111111111101111111111110111111111110111111111111011111111111101111111111110111111111111011111111111111111111111111111111111111111111111111110111111111111011111111111101111111111110111111111111011111111111101111111111110111111111111011111111111101111111111111111111111111111111111111111111111111111111111111111110000000001111000000000111100000000011110000000001111000000001111000000000111100000000011110000000001111000000000111111111111111111111111111111111111111111111111111111110000000001111000000000111100000000011110000000001111000000000111100000000011110000000001111000000000111100000000011111111111111111111111111111111111111111111111111111111111111111101111111111110111111111111011111111111101111111111101111111111110111111111111011111111111101111111111110111111111111111111111111111111111111111111111111111101111111111110111111111111011111111111101111111111110111111111111011111111111101111111111110111111111111011111111111111111111111111111111111111111111111111111111111111111111111111110111111111111011111111111101111111111110111111111110111111111111011111111111101111111111110111111111111011111111111111111111111111111111111111111111111111110111111111111011111111111101111111111110111111111111011111111111101111111111110111111111111011111111111101111111111111111111111111111111111111111111111111111111111111111111111111111011111111111101111111111110111111111111011111111111011111111111101111111111110111111111111011111111111101111111111111111111111111111111111111111111111111111011111111111101111111111110111111111111011111111111101111111111110111111111111011111111111101111111111110111111111111111111111111111111111111111111111111111111111111111111000000000111100000000011110000000001111000000000111100000000111100000000011110000000001111000000000111100000000011111111111111111111111111111111111111111111111111111111000000000111100000000011110000000001111000000000111100000000011110000000001111000000000111100000000011110000000001111111111111111111111111111111111111111111111111111111100000000011110000000001111000000000111100000000011110000000011110000000001111000000000111100000000011110000000001111111111111111111111111111111111111111111111111111111100000000011110000000001111000000000111100000000011110000000001111000000000111100000000011110000000001111000000000111111111111111111111111111111111111111111111111111111111111111111011111111111101111111111110111111111111011111111111011111111111101111111111110111111111111011111111111101111111111111111111111111111111111111111111111111111011111111111101111111111110111111111111011111111111101111111111110111111111111011111111111101111111111110111111111111111111111111111111111111111"}, {"id": 286812138, "lang": "cpp", "time": "2\u00a0weeks, 2\u00a0days", "timestamp": 1576649238, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/286812138/", "is_pending": "Not Pending", "title": "Rectangle Area", "memory": "N/A", "code": "class Solution {\npublic:\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\n        long total = (C-A) * (D - B) + (G - E) * (H - F);\n        if(C <= E || G <= A || D <= F || H <= A) {\n            return total;\n        }\n        int width = min(G,C) - max(E,A);\n        int height = min(D,H) - max(B,F);\n        return total - width * height;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 286811965, "lang": "cpp", "time": "2\u00a0weeks, 2\u00a0days", "timestamp": 1576649194, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/286811965/", "is_pending": "Not Pending", "title": "Rectangle Area", "memory": "N/A", "code": "class Solution {\npublic:\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\n        int total = (C-A) * (D - B) + (G - E) * (H - F);\n        if(C <= E || G <= A || D <= F || H <= A) {\n            return total;\n        }\n        int width = min(G,C) - max(E,A);\n        int height = min(D,H) - max(B,F);\n        return total - width * height;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 286805863, "lang": "cpp", "time": "2\u00a0weeks, 2\u00a0days", "timestamp": 1576647613, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/286805863/", "is_pending": "Not Pending", "title": "Different Ways to Add Parentheses", "memory": "13.8 MB", "code": "class Solution {\npublic:\n    vector<int> diffWaysToCompute(string input) {\n        bool status = false;\n        vector<int> ret;\n        for(int i =0;i < input.size();i ++){\n            if(input[i] == '+' || input[i] == '-' || input[i] == '*'){\n                // cout << input.substr(0,i) << \" \" <<  input[i] <<\" \" << input.substr(i+1,input.size()-i) << endl; \n                vector<int> left = diffWaysToCompute(input.substr(0,i));\n                vector<int> right = diffWaysToCompute(input.substr(i+1,input.size()-i));\n                for(auto t : left){\n                    for (auto p: right){\n                        if(input[i] == '+'){\n                            ret.push_back(t+p);\n                        }else if (input[i] == '-'){\n                            ret.push_back(t-p);\n                        }else{\n                            ret.push_back(t*p);\n                        }\n                    }\n                }\n            }\n        }\n        if(ret.size() ==0 && input.size() > 0){\n            ret.push_back(stoi(input));\n        }\n        return ret;\n    }\n    \n};", "compare_result": "1111111111111111111111111"}, {"id": 286801849, "lang": "cpp", "time": "2\u00a0weeks, 2\u00a0days", "timestamp": 1576646582, "status_display": "Accepted", "runtime": "44 ms", "url": "/submissions/detail/286801849/", "is_pending": "Not Pending", "title": "Product of Array Except Self", "memory": "12.6 MB", "code": "class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int left = 1;\n        vector<int> ret(nums.size(),1);\n        for (int i =0;i < nums.size();i ++){\n            ret[i] *= left;\n            left *= nums[i];\n        }\n        // int right = 1;\n        left = 1;\n        for(int i = nums.size()-1;i >=0;i --){\n            ret[i] *= left;\n            left *= nums[i];\n        }\n        return ret;\n    }\n};", "compare_result": "11111111111111111"}, {"id": 286801534, "lang": "cpp", "time": "2\u00a0weeks, 2\u00a0days", "timestamp": 1576646498, "status_display": "Accepted", "runtime": "40 ms", "url": "/submissions/detail/286801534/", "is_pending": "Not Pending", "title": "Product of Array Except Self", "memory": "12.8 MB", "code": "class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int left = 1;\n        vector<int> ret;\n        for (auto t : nums){\n            ret.push_back(left);\n            left *= t;\n        }\n        int right = 1;\n        for(int i = nums.size()-1;i >=0;i --){\n            ret[i] *= right;\n            right *= nums[i];\n        }\n        return ret;\n    }\n};", "compare_result": "11111111111111111"}, {"id": 286800449, "lang": "cpp", "time": "2\u00a0weeks, 2\u00a0days", "timestamp": 1576646209, "status_display": "Accepted", "runtime": "20 ms", "url": "/submissions/detail/286800449/", "is_pending": "Not Pending", "title": "Lowest Common Ancestor of a Binary Tree", "memory": "16.5 MB", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if(root == NULL) return NULL;\n        TreeNode *left = lowestCommonAncestor(root->left,p,q);\n        TreeNode *right = lowestCommonAncestor(root->right,p,q);\n        if(q == left && (p == right || p == root) || q == right && (p == left || p == root) || q== root && (p == left || p == right))\n            return root;\n        \n//         cout << root-> val << \" \";\n//         if(left){\n//             cout << left->val <<  \" \";\n//         }else{\n//             cout << \"NULL \";\n//         }\n        \n//         if(right){\n//             cout << right->val << \" \";\n//         }else{\n//             cout << \"NULL\";\n//         }\n//         cout << endl;\n        if(left) {\n            return left;\n        }\n        if(right){\n            return right;\n        }\n        if(root == p || root == q){\n            return root;\n        }\n        return NULL;\n    }\n};", "compare_result": "1111111111111111111111111111111"}, {"id": 286787306, "lang": "cpp", "time": "2\u00a0weeks, 2\u00a0days", "timestamp": 1576642547, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/286787306/", "is_pending": "Not Pending", "title": "Lowest Common Ancestor of a Binary Tree", "memory": "N/A", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if(root == NULL) return NULL;\n        TreeNode *left = lowestCommonAncestor(root->left,p,q);\n        TreeNode *right = lowestCommonAncestor(root->right,p,q);\n        if(q == left && (p == right || p == root) || q == right && (p == left || p == root) || q== root && (p == left || p == right))\n            return root;\n        \n        if(left == p || left == q) {\n            return left;\n        }\n        if(right == p || right == q){\n            return right;\n        }\n        if(root == p || root == q){\n            return root;\n        }\n        return NULL;\n    }\n};", "compare_result": "1111111111110110101110011100011"}, {"id": 286782599, "lang": "cpp", "time": "2\u00a0weeks, 2\u00a0days", "timestamp": 1576641276, "status_display": "Accepted", "runtime": "16 ms", "url": "/submissions/detail/286782599/", "is_pending": "Not Pending", "title": "Kth Smallest Element in a BST", "memory": "21.5 MB", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int kthSmallest(TreeNode* root, int k) {\n        int ret = 0;\n        bool status = false;\n        getK(root,k,ret,status);\n        return ret;\n    }\n    int getK(TreeNode* root,int k,int &tar,bool & status){\n        if(status ) return 0;\n        int left = 0;\n        if(root->left != NULL) {\n            left = getK(root->left,k,tar,status);\n        }\n        if(k == left +1){\n            tar = root->val;\n            status = true;\n        }\n        int right = 0;\n        if(root->right != NULL){\n            right = getK(root->right,k-left-1,tar,status);\n        }\n        return right + left +1;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 286777704, "lang": "cpp", "time": "2\u00a0weeks, 2\u00a0days", "timestamp": 1576640006, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/286777704/", "is_pending": "Not Pending", "title": "Summary Ranges", "memory": "8.4 MB", "code": "class Solution {\npublic:\n    vector<string> summaryRanges(vector<int>& nums) {\n        vector<string> ret;\n        if(nums.size() <= 0) return ret;\n        int a = nums[0];\n        int b = nums[0];\n        for(int i = 1;i < nums.size();i ++){\n            if(nums[i] != (b+1)){\n                ret.push_back(convert(a,b));\n                a = nums[i];\n                b = nums[i];\n            }else{\n                b ++;\n            }\n        }\n        ret.push_back(convert(a,b));\n        return ret;\n        \n    }\n    string convert(int a,int b){\n        if(a == b){\n            return to_string(a);\n        }\n        return to_string(a) + \"->\" +to_string(b);\n    }\n};", "compare_result": "1111111111111111111111111111"}, {"id": 286777606, "lang": "cpp", "time": "2\u00a0weeks, 2\u00a0days", "timestamp": 1576639984, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/286777606/", "is_pending": "Not Pending", "title": "Summary Ranges", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<string> summaryRanges(vector<int>& nums) {\n        vector<string> ret;\n        int a = nums[0];\n        int b = nums[0];\n        for(int i = 1;i < nums.size();i ++){\n            if(nums[i] != (b+1)){\n                ret.push_back(convert(a,b));\n                a = nums[i];\n                b = nums[i];\n            }else{\n                b ++;\n            }\n        }\n        ret.push_back(convert(a,b));\n        return ret;\n        \n    }\n    string convert(int a,int b){\n        if(a == b){\n            return to_string(a);\n        }\n        return to_string(a) + \"->\" +to_string(b);\n    }\n};", "compare_result": "1100000000000000000000000000"}, {"id": 285802167, "lang": "cpp", "time": "2\u00a0weeks, 6\u00a0days", "timestamp": 1576291478, "status_display": "Accepted", "runtime": "28 ms", "url": "/submissions/detail/285802167/", "is_pending": "Not Pending", "title": "Count Complete Tree Nodes", "memory": "29.3 MB", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int countNodes(TreeNode* root) {\n        if(root == NULL) return 0; \n        queue<TreeNode*> tnq;\n        tnq.push(root);\n        int tar = 1;\n        int count = 0;\n        while(tnq.size() > 0){\n            int tmpt = tar;\n            count += tar;\n            tar = tar * 2;\n            int tmpc = 0;\n            while(tmpt >0){\n                tmpt --;\n                TreeNode *r = tnq.front();\n                tnq.pop();\n                if(r->left != NULL){\n                    tnq.push(r->left);\n                    tmpc ++;\n                }\n                if(r->right != NULL){\n                    tnq.push(r->right);\n                    tmpc ++;\n                }\n            }\n            if(tmpc < tar){\n                count += tmpc;\n                break;\n            }\n        }\n        return count;\n        \n    }\n};", "compare_result": "111111111111111111"}, {"id": 284040238, "lang": "cpp", "time": "4\u00a0weeks", "timestamp": 1575601402, "status_display": "Accepted", "runtime": "20 ms", "url": "/submissions/detail/284040238/", "is_pending": "Not Pending", "title": "Contains Duplicate III", "memory": "11 MB", "code": "class Solution {\npublic:\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n        set<long> table;\n        long tt = t;\n        for(int i = 0;i < nums.size();i ++){\n            if(i > k){\n                table.erase(nums[i-k-1]);\n            }\n            auto lo = table.lower_bound(nums[i]-tt);\n            if(lo != table.end() && *lo - nums[i] <= tt){\n                return true;\n            }\n            table.insert(nums[i]);\n        }\n        return false;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111"}, {"id": 284040108, "lang": "cpp", "time": "4\u00a0weeks", "timestamp": 1575601359, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/284040108/", "is_pending": "Not Pending", "title": "Contains Duplicate III", "memory": "N/A", "code": "class Solution {\npublic:\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n        set<int> table;\n        for(int i = 0;i < nums.size();i ++){\n            if(i > k){\n                table.erase(nums[i-k-1]);\n            }\n            auto lo = table.lower_bound(nums[i]-t);\n            if(lo != table.end() && *lo - nums[i] <= t){\n                return true;\n            }\n            table.insert(nums[i]);\n        }\n        return false;\n    }\n};", "compare_result": "11111111111111111111111111111110000000000"}, {"id": 284034691, "lang": "cpp", "time": "4\u00a0weeks", "timestamp": 1575599686, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/284034691/", "is_pending": "Not Pending", "title": "Contains Duplicate III", "memory": "N/A", "code": "class Solution {\npublic:\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n        map<int,vector<int> > table;\n        for(int i = 0;i < nums.size();i ++){\n            if(t == 0){\n                if(table[nums[i]].size() >0) return true;\n            }\n            auto lo = table.lower_bound(nums[i]);\n            if(((lo != table.begin() && (nums[i] - (--lo)->first <= t) )) || (lo->first == nums[i] && lo->second.size() > 0)){\n                return true;\n            }\n            auto hi = table.upper_bound(nums[i]);\n            if(hi != table.end() && hi->first - nums[i] <= t ){\n                return true;\n            }\n            table[nums[i]].push_back(i);\n            if(i >= k){\n                table[nums[i-k]].erase(table[nums[i-k]].begin());\n                if(table[nums[i-k]].size() == 0){\n                    table.erase(nums[i-k]);\n                }\n            }\n        }\n        \n        return false;\n        \n        // return false;\n    }\n};", "compare_result": "11111110111111111111111111111000000000000"}, {"id": 284033904, "lang": "cpp", "time": "4\u00a0weeks", "timestamp": 1575599439, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/284033904/", "is_pending": "Not Pending", "title": "Contains Duplicate III", "memory": "N/A", "code": "class Solution {\npublic:\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n        map<int,vector<int> > table;\n        for(int i = 0;i < nums.size();i ++){\n            if(t == 0){\n                if(table[nums[i]].size() >0) return true;\n            }\n            auto lo = table.lower_bound(nums[i]);\n            if(((lo != table.begin() && nums[i] - (--lo)->first <= t) ) || lo->first == nums[i]){\n                return true;\n            }\n            auto hi = table.upper_bound(nums[i]);\n            if(hi != table.end() && hi->first - nums[i] <= t ){\n                return true;\n            }\n            table[nums[i]].push_back(i);\n            if(i >= k){\n                table[nums[i-k]].erase(table[nums[i-k]].begin());\n                if(table[nums[i-k]].size() == 0){\n                    table.erase(nums[i-k]);\n                }\n            }\n        }\n        \n        return false;\n        \n        // return false;\n    }\n};", "compare_result": "11110110111111111111111111111100000000000"}, {"id": 283909033, "lang": "cpp", "time": "4\u00a0weeks, 1\u00a0day", "timestamp": 1575549384, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/283909033/", "is_pending": "Not Pending", "title": "Contains Duplicate III", "memory": "N/A", "code": "class Solution {\npublic:\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n        map<int,vector<int> > table;\n        for(int i = 0;i < nums.size();i ++){\n            if(t == 0){\n                if(table[nums[i]].size() >0) return true;\n            }\n            auto lo = table.lower_bound(nums[i]);\n            if(lo != table.begin() && nums[i] - (--lo)->first <= t) {\n                return true;\n            }\n            auto hi = table.upper_bound(nums[i]);\n            if(hi != table.end() && hi->first - nums[i] <= t ){\n                return true;\n            }\n            table[nums[i]].push_back(i);\n            if(i >= k){\n                table[nums[i-k]].erase(table[nums[i-k]].begin());\n                if(table[nums[i-k]].size() == 0){\n                    table.erase(nums[i-k]);\n                }\n            }\n        }\n        \n        return false;\n        \n        // return false;\n    }\n};", "compare_result": "11111111111111111011111111111100000000000"}, {"id": 283908861, "lang": "cpp", "time": "4\u00a0weeks, 1\u00a0day", "timestamp": 1575549277, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/283908861/", "is_pending": "Not Pending", "title": "Contains Duplicate III", "memory": "N/A", "code": "class Solution {\npublic:\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n        map<int,vector<int> > table;\n        for(int i = 0;i < nums.size();i ++){\n            auto lo = table.lower_bound(nums[i]);\n            if(lo != table.begin() && nums[i] - (--lo)->first <= t) {\n                // cout << nums[i] << \" \" << lo->first << \" lo\" << endl;\n                return true;\n            }\n            auto hi = table.upper_bound(nums[i]);\n            if(hi != table.end() && hi->first - nums[i] <= t ){\n                // cout << nums[i] << \" \" << hi->first << \" hi \" << endl;\n                return true;\n            }\n            table[nums[i]].push_back(i);\n            if(i >= k){\n                table[nums[i-k]].erase(table[nums[i-k]].begin());\n                if(table[nums[i-k]].size() == 0){\n                    table.erase(nums[i-k]);\n                }\n            }\n        }\n        \n        return false;\n        \n        // return false;\n    }\n};", "compare_result": "01111101110111111011111111111100000000000"}, {"id": 283902558, "lang": "cpp", "time": "4\u00a0weeks, 1\u00a0day", "timestamp": 1575545314, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/283902558/", "is_pending": "Not Pending", "title": "Contains Duplicate III", "memory": "N/A", "code": "class Solution {\npublic:\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n        map<int,int> table;\n        for(auto i : nums){\n            table[i] ++;\n        }\n        if(k < t) return false;\n        for(auto i : nums){\n            int tar = i + t;\n            if(t == 0){\n                if(table[tar] > 1) return true;\n            }else{\n                auto uit  = table.upper_bound(tar);\n                if( uit != table.end()){\n                    if(uit->first - i <= k){\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n};", "compare_result": "10111110111001001100000010010011011010011"}, {"id": 283901073, "lang": "cpp", "time": "4\u00a0weeks, 1\u00a0day", "timestamp": 1575544289, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/283901073/", "is_pending": "Not Pending", "title": "Combination Sum III", "memory": "8.5 MB", "code": "class Solution {\npublic:\n    vector<vector<int>> combinationSum3(int k, int n) {\n        vector<vector<int> > iret;\n        if(k * 9 < n || k > 9 ){\n            return iret;\n        }\n        vector<int> candidates;\n        for(int i = 1;i <= 9;i ++){\n            candidates.push_back(i);\n        }\n        vector<int> path;\n        DFS(iret,candidates,0,k,path,n);\n        return iret;\n    }\n    void DFS(vector<vector<int> > &result,vector<int>& candidates,int idx,int steps,vector<int>&path,int res){\n        if(steps == 0)\n        {\n            if(res == 0){\n                result.push_back(path);\n            }\n            return;\n        }\n        for(int i = idx;i < candidates.size() -steps+1;i ++){\n            if(candidates[i] > res){\n                break;\n            }\n            path.push_back(candidates[i]);\n            DFS(result,candidates,i+1,steps -1,path,res-candidates[i]);\n            path.pop_back();\n        }\n        return;\n    }\n};", "compare_result": "111111111111111111"}, {"id": 283900835, "lang": "cpp", "time": "4\u00a0weeks, 1\u00a0day", "timestamp": 1575544147, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/283900835/", "is_pending": "Not Pending", "title": "Combination Sum III", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<vector<int>> combinationSum3(int k, int n) {\n        vector<vector<int> > iret;\n        if(k * 9 < n || k > 9 ){\n            return iret;\n        }\n        vector<int> candidates;\n        for(int i = 1;i <= 9;i ++){\n            candidates.push_back(i);\n        }\n        vector<int> path;\n        DFS(iret,candidates,0,k,path,n);\n        return iret;\n    }\n    void DFS(vector<vector<int> > &result,vector<int>& candidates,int idx,int steps,vector<int>&path,int res){\n        if(steps == 0)\n        {\n            if(res == 0){\n                result.push_back(path);\n            }\n            return;\n        }\n        for(int i = idx;i < candidates.size() -steps;i ++){\n            if(candidates[i] > res){\n                break;\n            }\n            path.push_back(candidates[i]);\n            DFS(result,candidates,i+1,steps -1,path,res-candidates[i]);\n            path.pop_back();\n        }\n        return;\n    }\n};", "compare_result": "111111111001100010"}, {"id": 283468441, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575390892, "status_display": "Accepted", "runtime": "64 ms", "url": "/submissions/detail/283468441/", "is_pending": "Not Pending", "title": "Kth Largest Element in an Array", "memory": "9 MB", "code": "class Solution {\npublic:\n     int partition(vector<int>&nums,int start,int end){\n         if(start == end) return start ;\n         int low = start -1;\n         int tar = nums[end];\n         for(int j = start;j < end;j ++){\n             if(nums[j] <= tar){\n                 swap(nums[++low],nums[j]);\n             }\n         }\n         swap(nums[++low],nums[end]);\n         return low;\n    }\n    int findKthLargest(vector<int>& nums, int k) {\n        int L = 0;\n        int R = nums.size() -1;\n        k = nums.size() - k;\n        // cout << k << endl;\n        while(L < R){\n            int par = partition(nums,L,R);\n            // cout << \"par \" << par << \"\\t\";\n            // for(auto i : nums){\n            //         cout << i << \"\\t\";\n            // }\n            // cout << endl;\n            if(par == k)\n            {\n                return nums[par];\n            }\n            if(par < k){\n                L = par+1;\n            }else {\n                R = par -1;\n            }\n        }\n        return nums[L];\n    }\n    \n   \n};", "compare_result": "11111111111111111111111111111111"}, {"id": 283464454, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575389501, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/283464454/", "is_pending": "Not Pending", "title": "Kth Largest Element in an Array", "memory": "N/A", "code": "class Solution {\npublic:\n     int partition(vector<int>&nums,int start,int end){\n        if(start == end) return start ;\n        int tar = nums[start];\n        int L = start;\n        int R = end;\n        while(L < R){\n            while( L < R && nums[R] > tar ){\n                R --;\n            }\n            swap(nums[L],nums[R]);\n            while(L < R && nums[L] <= tar){\n                L ++;\n            }\n        }\n        return L;\n    }\n    int findKthLargest(vector<int>& nums, int k) {\n        int L = 0;\n        int R = nums.size() -1;\n        k = nums.size() - k;\n        while(L < R){\n            int par = partition(nums,L,R);\n            if(par == k) return nums[par];\n            if(par < k){\n                L = par+1;\n            }else {\n                R = par -1;\n            }\n        }\n        return nums[L];\n    }\n    \n   \n};", "compare_result": "11111111111111110111111111101111"}, {"id": 283463166, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575389039, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/283463166/", "is_pending": "Not Pending", "title": "Minimum Size Subarray Sum", "memory": "10 MB", "code": "class Solution {\npublic:\n    int minSubArrayLen(int s, vector<int>& nums) {\n        int start = 0;\n        int cur = 0;\n        int sum = 0;\n        int mlen = INT_MAX;\n        while(cur < nums.size()){\n            sum += nums[cur];\n            while(sum >= s){\n                mlen = min(mlen,cur - start +1);\n                sum -= nums[start++];\n            }\n            cur += 1;\n        }\n        return mlen == INT_MAX ? 0 : mlen;\n    }\n};", "compare_result": "111111111111111"}, {"id": 283431008, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575373285, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/283431008/", "is_pending": "Not Pending", "title": "Minimum Size Subarray Sum", "memory": "N/A", "code": "class Solution {\npublic:\n    int minSubArrayLen(int s, vector<int>& nums) {\n        int start = 0;\n        int sum = 0;\n        int mlen = INT_MAX;\n        for(int i = 0;i < nums.size();i ++){\n            sum += nums[i];\n            if(sum >= s){\n                mlen = min(mlen,i-start+1);\n            }\n            while(sum >= s){\n                sum -= nums[start++];\n            }\n        }\n        if(start > 0 && sum + nums[start-1] >= s){\n            mlen = min(mlen,(int)nums.size()-start+1);\n        }\n        return mlen == INT_MAX  ? 0 : mlen;\n    }\n};", "compare_result": "111111110111101"}, {"id": 283430929, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575373238, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/283430929/", "is_pending": "Not Pending", "title": "Minimum Size Subarray Sum", "memory": "N/A", "code": "class Solution {\npublic:\n    int minSubArrayLen(int s, vector<int>& nums) {\n        int start = 0;\n        int sum = 0;\n        int mlen = INT_MAX;\n        for(int i = 0;i < nums.size();i ++){\n            sum += nums[i];\n            if(sum >= s){\n                mlen = min(mlen,i-start+1);\n            }\n            while(sum > s){\n                sum -= nums[start++];\n            }\n        }\n        if(start > 0 && sum + nums[start-1] >= s){\n            mlen = min(mlen,(int)nums.size()-start+1);\n        }\n        return mlen == INT_MAX  ? 0 : mlen;\n    }\n};", "compare_result": "010110110101101"}, {"id": 283430276, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575372835, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/283430276/", "is_pending": "Not Pending", "title": "Minimum Size Subarray Sum", "memory": "N/A", "code": "class Solution {\npublic:\n    int minSubArrayLen(int s, vector<int>& nums) {\n        int start = 0;\n        int sum = 0;\n        int mlen = INT_MAX;\n        for(int i = 0;i < nums.size();i ++){\n            sum += nums[i];\n            while(sum > s){\n                sum -= nums[start++];\n            }\n            if(sum == s){\n                mlen = min(mlen,i-start+1);\n            }\n        }\n        return mlen == INT_MAX  ? 0 : mlen;\n    }\n};", "compare_result": "111011001110100"}, {"id": 283430246, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575372814, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/283430246/", "is_pending": "Not Pending", "title": "Minimum Size Subarray Sum", "memory": "N/A", "code": "class Solution {\npublic:\n    int minSubArrayLen(int s, vector<int>& nums) {\n        int start = 0;\n        int sum = 0;\n        int mlen = INT_MAX;\n        for(int i = 0;i < nums.size();i ++){\n            sum += nums[i];\n            while(sum > s){\n                sum -= nums[start++];\n            }\n            if(sum == s){\n                mlen = min(mlen,i-start+1);\n            }\n        }\n        return mlen;\n    }\n};", "compare_result": "101011001110000"}, {"id": 283429702, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575372469, "status_display": "Accepted", "runtime": "76 ms", "url": "/submissions/detail/283429702/", "is_pending": "Not Pending", "title": "Implement Trie (Prefix Tree)", "memory": "44.7 MB", "code": "class Trie {\npublic:\n    bool status;\n    Trie *letters[26];\n    /** Initialize your data structure here. */\n    Trie() {\n        status = false;\n        for(int i = 0;i < 26;i ++){\n            letters[i] = NULL;\n        }\n    }\n    \n    /** Inserts a word into the trie. */\n    void insert(string word) {\n        Trie * root = this;\n        for(char& c: word){\n            if(root->letters[c-'a'] == NULL){\n                root->letters[c-'a'] = new Trie();\n            }\n            root = root->letters[c-'a'];\n        }\n        \n        root->status = true;\n    }\n    \n    /** Returns if the word is in the trie. */\n    bool search(string word) {\n        Trie * root = this;\n        for(char c: word){\n            if(root->letters[c-'a'] == NULL) return false;\n            root = root->letters[c-'a'];\n        }\n        return root->status;\n    }\n    \n    /** Returns if there is any word in the trie that starts with the given prefix. */\n    bool startsWith(string prefix) {\n        Trie * root = this;\n        for(char c: prefix){\n            if(root->letters[c-'a'] == NULL) return false;\n            root = root->letters[c-'a'];\n        }\n        return true;\n    }\n};\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie* obj = new Trie();\n * obj->insert(word);\n * bool param_2 = obj->search(word);\n * bool param_3 = obj->startsWith(prefix);\n */", "compare_result": "111111111111111"}, {"id": 283428311, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575371542, "status_display": "Accepted", "runtime": "52 ms", "url": "/submissions/detail/283428311/", "is_pending": "Not Pending", "title": "Binary Search Tree Iterator", "memory": "24 MB", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass BSTIterator {\npublic:\n    stack<TreeNode*> istk;\n    BSTIterator(TreeNode* root) {\n        TreeNode *p = root;\n        while(p != NULL){\n            istk.push(p);\n            p = p->left;\n        }\n    }\n    \n    /** @return the next smallest number */\n    int next() {\n        TreeNode * tn = istk.top();\n        istk.pop();\n        TreeNode * p = tn->right;\n        while(p != NULL){\n            istk.push(p);\n            p = p->left;\n        }\n        return tn->val;\n    }\n    \n    /** @return whether we have a next smallest number */\n    bool hasNext() {\n        if(istk.size() ==0) return false;\n        return true;\n    }\n};\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator* obj = new BSTIterator(root);\n * int param_1 = obj->next();\n * bool param_2 = obj->hasNext();\n */", "compare_result": "11111111111111111111111111111111111111111111111111111111111111"}, {"id": 283420929, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575367113, "status_display": "Accepted", "runtime": "12 ms", "url": "/submissions/detail/283420929/", "is_pending": "Not Pending", "title": "Bitwise AND of Numbers Range", "memory": "8.3 MB", "code": "class Solution {\npublic:\n    int rangeBitwiseAnd(int m, int n) {\n        return n > m ? (rangeBitwiseAnd(m/2,n/2) << 1):m;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 283417677, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575365537, "status_display": "Accepted", "runtime": "0 ms", "url": "/submissions/detail/283417677/", "is_pending": "Not Pending", "title": "Binary Tree Right Side View", "memory": "9.6 MB", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> rightSideView(TreeNode* root) {\n        queue<TreeNode*> tq;\n        vector<int> ret;\n        if(root == NULL) return ret;\n        tq.push(root);\n        int count = 1;\n        while(tq.size() > 0){\n            int tc = count;\n            count = 0;\n            int val = 0;\n            for(int i = 0;i < tc;i ++){\n                TreeNode *tn = tq.front();\n                tq.pop();\n                val = tn->val;\n                if(tn->left){\n                    tq.push(tn->left);\n                    count ++;\n                }\n                if(tn->right){\n                    tq.push(tn->right);\n                    count ++;\n                }\n            }\n            ret.push_back(val);\n        }\n        return ret;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 283414405, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575364044, "status_display": "Accepted", "runtime": "64 ms", "url": "/submissions/detail/283414405/", "is_pending": "Not Pending", "title": "Repeated DNA Sequences", "memory": "24.6 MB", "code": "class Solution {\npublic:\n    vector<string> findRepeatedDnaSequences(string s) {\n        vector<string> sret;\n        if(s.size() < 10) return sret;\n        unordered_map<string,int> table;\n        string stmp = s.substr(0,10);\n        table[stmp] = 1;\n        for(int i = 10;i < s.size();i ++){\n            string ns = stmp.substr(1,9) + s[i];\n            table[ns] += 1;\n            if(table[ns] == 2){\n                sret.push_back(ns);\n            }\n            stmp = ns;\n        }\n        return sret;\n    }\n};", "compare_result": "11111111111111111111111111111111"}, {"id": 283413442, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575363637, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/283413442/", "is_pending": "Not Pending", "title": "Largest Number", "memory": "9.2 MB", "code": "class Solution {\npublic:\n    static int mycomp(string&a,string &b){\n        return a+b>b+a;\n    }\n    string largestNumber(vector<int>& nums) {\n        vector<string> snums;\n        for(auto i : nums){\n            snums.push_back(to_string(i));\n        }\n        sort(snums.begin(),snums.end(),mycomp);\n        string sret = \"\";\n        for(auto &s : snums){\n            sret += s;\n        }\n        while(sret[0] == '0' && sret.size() >1){\n            sret.erase(0,1);\n        }\n        return sret;\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 283413257, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575363565, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/283413257/", "is_pending": "Not Pending", "title": "Largest Number", "memory": "N/A", "code": "class Solution {\npublic:\n    static int mycomp(string&a,string &b){\n        return a+b>b+a;\n    }\n    string largestNumber(vector<int>& nums) {\n        vector<string> snums;\n        for(auto i : nums){\n            snums.push_back(to_string(i));\n        }\n        sort(snums.begin(),snums.end(),mycomp);\n        string sret = \"\";\n        for(auto &s : snums){\n            sret += s;\n        }\n        return sret;\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111010110011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 283410448, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575362391, "status_display": "Accepted", "runtime": "1552 ms", "url": "/submissions/detail/283410448/", "is_pending": "Not Pending", "title": "Word Ladder", "memory": "26.1 MB", "code": "class Solution {\npublic:\n    int ladderLength(string beginWord, string endWord, \n                     vector<string>& wordList) {\n        \n        unordered_set<string> dict(wordList.begin(),wordList.end());\n        queue<string> qu;\n        qu.push(beginWord);\n        int ladder = 1;\n        if(dict.find(endWord) == dict.end()) return 0;\n        while(qu.size() > 0){\n            int n = qu.size();\n            for(int i = 0;i < n;i ++){\n                string word = qu.front();\n                qu.pop();\n                dict.erase(word);\n                if(word == endWord) return ladder;\n                //get change\n                for(int j = 0;j < word.size();j ++){\n                    char c = word[j];\n                    for(int i = 0;i < 26;i ++){\n                        word[j] = 'a' + i;\n                        if(dict.find(word) != dict.end()){\n                            qu.push(word);\n                        }\n                    }\n                    word[j] = c;\n                }\n            }\n            ladder ++;\n        }\n        return 0;\n    }\n    \n    \n    \n    \n};", "compare_result": "1111111111111111111111111111111111111111"}, {"id": 283410181, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575362300, "status_display": "Accepted", "runtime": "1356 ms", "url": "/submissions/detail/283410181/", "is_pending": "Not Pending", "title": "Word Ladder", "memory": "25.9 MB", "code": "class Solution {\npublic:\n    int ladderLength(string beginWord, string endWord, \n                     vector<string>& wordList) {\n        \n        unordered_set<string> dict(wordList.begin(),wordList.end());\n        queue<string> qu;\n        qu.push(beginWord);\n        int ladder = 1;\n        while(qu.size() > 0){\n            int n = qu.size();\n            for(int i = 0;i < n;i ++){\n                string word = qu.front();\n                qu.pop();\n                dict.erase(word);\n                if(word == endWord) return ladder;\n                //get change\n                for(int j = 0;j < word.size();j ++){\n                    char c = word[j];\n                    for(int i = 0;i < 26;i ++){\n                        word[j] = 'a' + i;\n                        if(dict.find(word) != dict.end()){\n                            qu.push(word);\n                        }\n                    }\n                    word[j] = c;\n                }\n            }\n            ladder ++;\n        }\n        return 0;\n    }\n    \n    \n    \n    \n};", "compare_result": "1111111111111111111111111111111111111111"}, {"id": 283407740, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575361380, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/283407740/", "is_pending": "Not Pending", "title": "Linked List Cycle II", "memory": "9.7 MB", "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if(head == NULL || head->next == NULL) return NULL;\n        ListNode *p = head;\n        ListNode *q = head;\n        ListNode *e  = head;\n        while(q != NULL && q->next != NULL){\n            p = p->next;\n            q = q->next->next;\n            if(p == q){//cycle\n                while(e != q){\n                    q = q->next;\n                    e = e->next;\n                }\n                return e;\n            }\n        }\n        return NULL;\n    }\n};", "compare_result": "1111111111111111"}, {"id": 283210133, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575299092, "status_display": "Accepted", "runtime": "0 ms", "url": "/submissions/detail/283210133/", "is_pending": "Not Pending", "title": "Compare Version Numbers", "memory": "8.5 MB", "code": "class Solution {\npublic:\n    int compareVersion(string version1, string version2) {\n        for(auto& w : version1) if (w == '.') w=' ';\n        for(auto& w : version2) if (w == '.') w=' ';\n        stringstream ss1(version1);\n        stringstream ss2(version2);\n        while(1){\n            int n1 = 0;\n            int n2 = 0;\n            if(not (ss1>> n1) ) n1 = 0;\n            if(not (ss2>> n2) ) n2 = 0;\n            if(not ss1 && not ss2) return 0;\n            if(n1 < n2 ) return -1;\n            if (n1 > n2) return 1;\n        }\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 283209243, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575298743, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/283209243/", "is_pending": "Not Pending", "title": "Compare Version Numbers", "memory": "N/A", "code": "class Solution {\npublic:\n    int compareVersion(string version1, string version2) {\n        vector<int> vs1;\n        vector<int> vs2;\n        stringstream ss1(version1);\n        stringstream ss2(version2);\n        string ts1,ts2;\n        while(getline(ss1,ts1,'.')){\n            int ia = stoi(ts1);\n            if(ia > 0){\n                vs1.push_back(ia);\n            }\n        }\n        while(getline(ss2,ts2,'.')){\n            int ia = stoi(ts2);\n            if(ia > 0){\n                vs2.push_back(ia);\n            }\n        }\n        \n        for(int i = 0;i < min(vs1.size(),vs2.size());i ++){\n            if(vs1[i] < vs2[i]) return -1;\n            if(vs1[i] > vs2[i]) return 1;\n        }\n        if(vs1.size() < vs2.size()) return -1;\n        if(vs1.size() > vs2.size()) return 1;\n        \n        return 0;\n    }\n};", "compare_result": "111111111111111111111000011111110111111101111111111111111111111111111111"}, {"id": 283208230, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575298317, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/283208230/", "is_pending": "Not Pending", "title": "Compare Version Numbers", "memory": "N/A", "code": "class Solution {\npublic:\n    int compareVersion(string version1, string version2) {\n        int idx1 = 0;\n        int idx2 = 0;\n        int k1 = 0;\n        int k2 = 0;\n        int maxsize = max(version1.size(),version2.size());\n        vector<int> vs1;\n        vector<int> vs2;\n        string ts1 = \"\";\n        string ts2 = \"\";\n        \n        while(idx1 <version1.size() && version1[idx1] == '0') idx1 ++;\n        while(idx1 < version1.size()){\n            if(version1[idx1] == '.'){\n                if(ts1.size() > 0){\n                    vs1.push_back(stoi(ts1));\n                }\n                ts1 = \"\";\n                idx1 ++;\n                while(idx1 <version1.size() && version1[idx1] == '0') idx1 ++;\n            }else{\n                ts1 = ts1 + version1[idx1++];\n            }\n        }\n        while(idx2 <version2.size() && version2[idx2] == '0') idx2 ++;\n        while(idx2 < version2.size()){\n            if(version2[idx2] == '.'){\n                if(ts2.size() > 0){\n                    vs2.push_back(stoi(ts2));\n                }\n                ts1 = \"\";\n                idx2 ++;\n                while(idx2 <version2.size() && version2[idx2] == '0') idx2 ++;\n            }else{\n                ts2 = ts2 + version2[idx2++];\n            }\n        }\n        for(int i  = 0;i < min(vs1.size(),vs2.size());i ++){\n            if(ts1[i] < ts2[i]) return -1;\n            if(ts1[i] > ts2[i]) return 1;\n        }\n        if(ts1.size() > ts2.size()) return 1;\n        if(ts1.size() < ts2.size()) return -1;\n        return 0;\n    }\n};", "compare_result": "111111010101010101011100101100101000101011111001011110111010101100000000"}, {"id": 283207373, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575297934, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/283207373/", "is_pending": "Not Pending", "title": "Compare Version Numbers", "memory": "N/A", "code": "class Solution {\npublic:\n    int compareVersion(string version1, string version2) {\n        int idx1 = 0;\n        int idx2 = 0;\n        int k1 = 0;\n        int k2 = 0;\n        int maxsize = max(version1.size(),version2.size());\n        string ts1(maxsize,' ');\n        string ts2(maxsize,' ');\n        while(idx1 <version1.size() && version1[idx1] == '0') idx1 ++;\n        \n        while(idx1 < version1.size()){\n            if(version1[idx1] == '.'){\n                idx1 ++;\n                while(idx1 <version1.size() && version1[idx1] == '0') idx1 ++;\n            }else{\n                ts1[k1++] = version1[idx1++];\n            }\n        }\n        while(idx2 <version2.size() && version2[idx2] == '0') idx2 ++;\n        while(idx2 < version2.size()){\n            if(version2[idx2] == '.'){\n                idx2 ++;\n                while(idx2 <version2.size() && version2[idx2] == '0') idx2 ++;\n            }else{\n                ts2[k2++] = version2[idx2++];\n            }\n        }\n        \n        return ts1 == ts2 ? 0 : (ts1 < ts2 ? -1: 1);\n    }\n};", "compare_result": "111111111111100111111000011111110111110001110011111011110110111111111111"}, {"id": 283207276, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575297892, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/283207276/", "is_pending": "Not Pending", "title": "Compare Version Numbers", "memory": "N/A", "code": "class Solution {\npublic:\n    int compareVersion(string version1, string version2) {\n        int idx1 = 0;\n        int idx2 = 0;\n        int k1 = 0;\n        int k2 = 0;\n        int maxsize = max(version1.size(),version2.size());\n        string ts1(maxsize,' ');\n        string ts2(maxsize,' ');\n        while(idx1 < version1.size()){\n            if(version1[idx1] == '.'){\n                idx1 ++;\n                while(idx1 <version1.size() && version1[idx1] == '0') idx1 ++;\n            }else{\n                ts1[k1++] = version1[idx1++];\n            }\n        }\n        while(idx2 < version2.size()){\n            if(version2[idx2] == '.'){\n                idx2 ++;\n                while(idx2 <version2.size() && version2[idx2] == '0') idx2 ++;\n            }else{\n                ts2[k2++] = version2[idx2++];\n            }\n        }\n        \n        return ts1 == ts2 ? 0 : (ts1 < ts2 ? -1: 1);\n    }\n};", "compare_result": "111001111111100111111110011111110111110011110011111011110110111111110111"}, {"id": 282599358, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575085426, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/282599358/", "is_pending": "Not Pending", "title": "Next Permutation", "memory": "8.5 MB", "code": "class Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        int k =nums.size() -2;\n        while( k >= 0  ){\n            if(nums[k] < nums[k+1]){\n                break;\n            }\n            k --;\n        }\n        if(k < 0){\n            reverse(nums.begin(),nums.end());\n        }else{\n            int l = nums.size() -1;\n            while(l > k){\n                if(nums[l] > nums[k]){\n                    break;\n                }\n                l --;\n            }\n            swap(nums[k],nums[l]);\n            reverse(nums.begin()+k+1,nums.end());\n        }\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 282599000, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575085309, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/282599000/", "is_pending": "Not Pending", "title": "Next Permutation", "memory": "N/A", "code": "class Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        int k =nums.size() -2;\n        while( k >= 0  ){\n            if(nums[k] < nums[k+1]){\n                break;\n            }\n            k --;\n        }\n        if(k < 0){\n            reverse(nums.begin(),nums.end());\n        }else{\n            int l = nums.size() -1;\n            while(l > 0){\n                if(nums[l] > nums[l-1]){\n                    break;\n                }\n                l --;\n            }\n            swap(nums[k],nums[l]);\n            reverse(nums.begin()+k+1,nums.begin()+l);\n        }\n    }\n};", "compare_result": "1111010111110010101010101010101010111011111101101011101111000010111011000100000101111111111110100001111010011010001110001000110111110000100111001111100011010011000011000111101111011100101011011010100100010011111110101001011011111111011100010011110101011011001110001"}, {"id": 282596314, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575084386, "status_display": "Accepted", "runtime": "32 ms", "url": "/submissions/detail/282596314/", "is_pending": "Not Pending", "title": "Permutations II", "memory": "10.5 MB", "code": "class Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        vector<vector<int>>  result;\n        DFS(result,0,nums);\n        return result;\n    }\n    \n    void DFS(vector<vector<int>> & result,int idx,vector<int>nums){\n        if(idx >= nums.size()){\n            result.push_back(nums);\n            return;\n        }\n        for(int i = idx;i < nums.size();i ++){\n            if(i > idx && nums[i] == nums[idx]) continue;\n            swap(nums[i],nums[idx]);\n            DFS(result,idx+1,nums);\n            // swap(nums[i],nums[idx]);\n        }\n    }\n};", "compare_result": "111111111111111111111111111111"}, {"id": 282593259, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575083304, "status_display": "Accepted", "runtime": "24 ms", "url": "/submissions/detail/282593259/", "is_pending": "Not Pending", "title": "Permutations II", "memory": "10.6 MB", "code": "class Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        vector<vector<int>>  result;\n        DFS(result,0,nums);\n        return result;\n    }\n    \n    void DFS(vector<vector<int>> & result,int idx,vector<int> nums){\n        if(idx >= nums.size()){\n            result.push_back(nums);\n            return;\n        }\n        for(int i = idx;i < nums.size();i ++){\n            if(i > idx && nums[i] == nums[idx]) continue;\n            swap(nums[i],nums[idx]);\n            DFS(result,idx+1,nums);\n            // swap(nums[i],nums[idx]);\n        }\n    }\n};", "compare_result": "111111111111111111111111111111"}, {"id": 282592425, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575083011, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/282592425/", "is_pending": "Not Pending", "title": "Permutations II", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        vector<vector<int>>  result;\n        DFS(result,0,nums);\n        return result;\n    }\n    \n    void DFS(vector<vector<int>> & result,int idx,vector<int>& nums){\n        if(idx >= nums.size()){\n            result.push_back(nums);\n            return;\n        }\n        for(int i = idx;i < nums.size();i ++){\n            if(i > idx && nums[i] == nums[idx]) continue;\n            swap(nums[i],nums[idx]);\n            DFS(result,idx+1,nums);\n            swap(nums[i],nums[idx]);\n        }\n    }\n};", "compare_result": "111110001101001111100000101000"}, {"id": 282592102, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575082884, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/282592102/", "is_pending": "Not Pending", "title": "Permutations II", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        vector<vector<int>>  result;\n        DFS(result,0,nums);\n        return result;\n    }\n    \n    void DFS(vector<vector<int>> & result,int idx,vector<int>& nums){\n        if(idx >= nums.size()){\n            result.push_back(nums);\n            return;\n        }\n        for(int i = idx;i < nums.size();i ++){\n            if(i > idx && nums[i] == nums[idx]) continue;\n            swap(nums[i],nums[idx]);\n            DFS(result,i+1,nums);\n            swap(nums[i],nums[idx]);\n        }\n    }\n};", "compare_result": "111100101001001101100000001010"}, {"id": 282471270, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575031255, "status_display": "Accepted", "runtime": "56 ms", "url": "/submissions/detail/282471270/", "is_pending": "Not Pending", "title": "Sort List", "memory": "28.6 MB", "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n        if(head == NULL  || head->next == NULL) return head;\n        \n        ListNode *p = head;\n        ListNode *q = head->next->next;\n        while(q != NULL){\n            if(q->next == NULL){\n                break;\n            }\n            q = q->next->next;\n            p = p->next;\n        }\n        ListNode * secondHead = p->next;\n        p->next = NULL;\n        ListNode * first = sortList(head);\n        ListNode * second = sortList(secondHead);\n        return mergeList(first,second);\n        \n    }\n    ListNode * mergeList(ListNode * ah,ListNode *bh){\n        if(ah == NULL) return bh;\n        if(bh == NULL) return ah;\n        ListNode *fake = new ListNode(0);\n        ListNode *p = fake;\n        while( ah != NULL && bh != NULL){\n            if(ah->val < bh->val){\n                p->next = ah;\n                ah = ah->next;\n                p = p->next;\n                p->next = NULL;\n            }else{\n                p->next = bh;\n                bh = bh->next;\n                p = p->next;\n                p->next = NULL;\n            }\n        }\n        if(ah != NULL){\n            p->next = ah;\n        }\n        if(bh != NULL){\n            p->next = bh;\n        }\n        \n        p = fake->next;\n        delete fake;\n        return p;\n    }\n};", "compare_result": "1111111111111111"}, {"id": 282467352, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575027951, "status_display": "Accepted", "runtime": "16 ms", "url": "/submissions/detail/282467352/", "is_pending": "Not Pending", "title": "Evaluate Reverse Polish Notation", "memory": "11.6 MB", "code": "class Solution {\npublic:\n    int evalRPN(vector<string>& tokens) {\n        stack<int> istk;\n        int ret = 0;\n        for(auto t : tokens){\n            if(t == \"+\"){\n                int a = istk.top();\n                istk.pop();\n                int b = istk.top();\n                istk.pop();\n                istk.push(a + b);\n                \n            }else if (t == \"-\"){\n                int a = istk.top();\n                istk.pop();\n                int b = istk.top();\n                istk.pop();\n                istk.push(b - a);\n            }else if (t == \"*\"){\n                int a = istk.top();\n                istk.pop();\n                int b = istk.top();\n                istk.pop();\n                istk.push(a * b);\n            }else if (t == \"/\"){\n                int a = istk.top();\n                istk.pop();\n                int b = istk.top();\n                istk.pop();\n                istk.push(b / a);\n            }else{\n                istk.push(stoi(t));\n            }\n        }\n        return istk.empty() ? 0 : istk.top();\n    }\n};", "compare_result": "11111111111111111111"}, {"id": 282467238, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575027854, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/282467238/", "is_pending": "Not Pending", "title": "Evaluate Reverse Polish Notation", "memory": "N/A", "code": "class Solution {\npublic:\n    int evalRPN(vector<string>& tokens) {\n        stack<int> istk;\n        int ret = 0;\n        for(auto t : tokens){\n            if(t == \"+\"){\n                int a = istk.top();\n                istk.pop();\n                int b = istk.top();\n                istk.pop();\n                istk.push(a + b);\n                \n            }else if (t == \"-\"){\n                int a = istk.top();\n                istk.pop();\n                int b = istk.top();\n                istk.pop();\n                istk.push(a - b);\n            }else if (t == \"*\"){\n                int a = istk.top();\n                istk.pop();\n                int b = istk.top();\n                istk.pop();\n                istk.push(a * b);\n            }else if (t == \"/\"){\n                int a = istk.top();\n                istk.pop();\n                int b = istk.top();\n                istk.pop();\n                istk.push(a / b);\n            }else{\n                istk.push(stoi(t));\n            }\n        }\n        return istk.empty() ? 0 : istk.top();\n    }\n};", "compare_result": "10010000000000000000"}, {"id": 282466919, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575027587, "status_display": "Accepted", "runtime": "36 ms", "url": "/submissions/detail/282466919/", "is_pending": "Not Pending", "title": "Reverse Words in a String", "memory": "255.4 MB", "code": "class Solution {\npublic:\n    string reverseWords(string s) {\n        stringstream ss(s);\n        string ts;\n        vector<string> svec;\n        while(getline(ss,ts,' ')){\n            if(ts.size() > 0){\n                svec.push_back(ts);\n            }\n        }\n        reverse(svec.begin(),svec.end());\n        string sret = \"\";\n        for(auto t : svec){\n            if(sret != \"\"){\n                sret  = sret + \" \";\n            }\n            sret = sret + t;\n        }\n        return sret;\n    }\n};", "compare_result": "1111111111111111111111111"}, {"id": 282466850, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575027528, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/282466850/", "is_pending": "Not Pending", "title": "Reverse Words in a String", "memory": "N/A", "code": "class Solution {\npublic:\n    string reverseWords(string s) {\n        stringstream ss(s);\n        string ts;\n        vector<string> svec;\n        while(getline(ss,ts,' ')){\n            svec.push_back(ts);\n        }\n        reverse(svec.begin(),svec.end());\n        string sret = \"\";\n        for(auto t : svec){\n            if(sret != \"\"){\n                sret  = sret + \" \";\n            }\n            sret = sret + t;\n        }\n        return sret;\n    }\n};", "compare_result": "1001111010000111011111111"}, {"id": 282464800, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575025811, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/282464800/", "is_pending": "Not Pending", "title": "Find Minimum in Rotated Sorted Array", "memory": "8.7 MB", "code": "class Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int L = 0;\n        int R = nums.size() -1;\n        while(L < R){\n            int mid = L + (R - L)/2;\n            if(nums[mid] < nums[R]){\n                R = mid;\n            }else{\n                L = mid+1;\n            }\n        }\n        return nums[L];\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 282464235, "lang": "cpp", "time": "1\u00a0month", "timestamp": 1575025305, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/282464235/", "is_pending": "Not Pending", "title": "Find Peak Element", "memory": "8.7 MB", "code": "class Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n        \n        int L = 0;\n        int R = nums.size()-1;\n        while(L < R){\n            int mid = L + (R -L)/2;\n            if(nums[mid] > nums[mid+1]){\n                R = mid;\n            }else {\n                L = mid +1;\n            }\n        }\n        return L;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111"}, {"id": 282017003, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574840426, "status_display": "Accepted", "runtime": "52 ms", "url": "/submissions/detail/282017003/", "is_pending": "Not Pending", "title": "Insertion Sort List", "memory": "9.5 MB", "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* insertionSortList(ListNode* head) {\n        if(head == NULL || head->next == NULL) return head;\n        ListNode * fake = new ListNode(0);\n        ListNode *p = head;\n        while(p != NULL){\n            ListNode *q = fake;\n            while(q->next != NULL){\n                if(q->next->val < p->val){\n                    break;\n                }\n                q = q->next;\n            }\n            ListNode * tq = q->next;\n            q->next = p;\n            ListNode *tp = p->next;\n            p->next = tq;\n            p = tp;\n        }\n        return reverseList(fake->next);\n    }\n    ListNode * reverseList(ListNode *head){\n        if(head == NULL || head->next == NULL) return head;\n        ListNode *p = head;\n        ListNode *q = head->next;\n        p->next = NULL;\n        while(q != NULL){\n            ListNode *tmp = q->next;\n            q->next = p;\n            p = q;\n            q = tmp;\n        }\n        return p;\n    }\n};", "compare_result": "1111111111111111111111"}, {"id": 282014196, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574839548, "status_display": "Accepted", "runtime": "0 ms", "url": "/submissions/detail/282014196/", "is_pending": "Not Pending", "title": "Binary Tree Preorder Traversal", "memory": "9 MB", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> preorderTraversal(TreeNode* root) {\n        vector<int> ret;\n        if(root==NULL) return ret;\n        stack<TreeNode*> tstk;\n        tstk.push(root);\n        while(tstk.size() > 0){\n            TreeNode *p = tstk.top();\n            tstk.pop();\n            if(p->right != NULL){\n                tstk.push(p->right);\n            }\n            \n            if(p->left != NULL){\n                tstk.push(p->left);\n            }\n            ret.push_back(p->val);\n        }\n        return ret;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 282013484, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574839338, "status_display": "Accepted", "runtime": "40 ms", "url": "/submissions/detail/282013484/", "is_pending": "Not Pending", "title": "Reorder List", "memory": "12 MB", "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    void reorderList(ListNode* head) {\n        if(head == NULL || head->next == NULL) return ;\n        ListNode *p = head;\n        ListNode *q = head->next->next;\n        while(q != NULL){\n            if(q->next == NULL) break;\n            q = q->next->next;\n            p = p->next;\n        }\n        ListNode *secondHead = p->next;\n        p->next = NULL;\n        cout << p->val << endl;\n        p = head;\n        q = reverseList(secondHead);\n        while(q != NULL && p != NULL){\n            ListNode * tp = p->next;\n            ListNode *tq = q->next;\n            p->next = q;\n            if(tp != NULL){\n                q->next = tp;\n            }\n            p = tp;\n            q = tq;\n        }\n        return;\n    }\n    \n    ListNode* reverseList(ListNode *head){\n        if(head == NULL || head->next == NULL) return head;\n        ListNode *p = head;\n        ListNode *q = head->next;\n        p->next = NULL;\n        \n        while(q != NULL){\n            ListNode * tq = q->next;\n            q->next = p;\n            p = q;\n            q = tq;\n        }\n        return p;\n    }\n};", "compare_result": "1111111111111"}, {"id": 282011139, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574838635, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/282011139/", "is_pending": "Not Pending", "title": "Reorder List", "memory": "N/A", "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    void reorderList(ListNode* head) {\n        if(head == NULL || head->next == NULL) return ;\n        ListNode *p = head;\n        ListNode *q = head->next->next;\n        while(q != NULL){\n            if(q->next == NULL) break;\n            q = q->next->next;\n            p = p->next;\n        }\n        ListNode *secondHead = p->next;\n        p->next = NULL;\n        // cout << p->val << endl;\n        p = head;\n        q = reverseList(secondHead);\n        while(q != NULL && p != NULL){\n            ListNode * tp = p->next;\n            ListNode *tq = q->next;\n            p->next = q;\n            q->next = tp;\n            p = tp;\n            q = tq;\n        }\n        return;\n    }\n    \n    ListNode* reverseList(ListNode *head){\n        if(head == NULL || head->next == NULL) return head;\n        ListNode *p = head;\n        ListNode *q = head->next;\n        while(q != NULL){\n            ListNode * tq = q->next;\n            q->next = p;\n            p = q;\n            q = tq;\n        }\n        return p;\n    }\n};", "compare_result": "1011100000110"}, {"id": 281943033, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574818652, "status_display": "Accepted", "runtime": "16 ms", "url": "/submissions/detail/281943033/", "is_pending": "Not Pending", "title": "Unique Binary Search Trees II", "memory": "17.3 MB", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<TreeNode*> generateTrees(int n) {\n        vector<int> elements(n,0);\n        for(int i = 0;i < n;i ++){\n            elements[i] = i+1;\n        }\n        if(n == 0){\n            return vector<TreeNode*>();\n        }\n        return gT(elements,0,n-1);\n    }\n    \n    vector<TreeNode*> gT(vector<int>& eles,int start,int end){\n        vector<TreeNode*> ret;\n        if(start > end){\n            ret.push_back(NULL);\n            return ret;\n        }\n        // if(start == end ){\n        //     ret.push_back(new TreeNode(eles[start]));\n        //     return ret;\n        // }\n        for(int i = start;i <= end;i ++){\n            vector<TreeNode*> lt = gT(eles,start,i-1);\n            vector<TreeNode*> rt = gT(eles,i+1,end);\n            for(auto &p : lt){\n                for(auto &q: rt){\n                    TreeNode * root = new TreeNode(eles[i]);\n                    root->left = p;\n                    root->right = q;\n                    ret.push_back(root);\n                }\n            }\n        }\n        return ret;\n    }\n    \n};", "compare_result": "111111111"}, {"id": 281816799, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574772843, "status_display": "Accepted", "runtime": "0 ms", "url": "/submissions/detail/281816799/", "is_pending": "Not Pending", "title": "Gray Code", "memory": "8.5 MB", "code": "class Solution {\npublic:\n    vector<int> grayCode(int n) {\n        vector<int> ret;\n        ret.push_back(0);\n        for(int i = 0;i < n;i ++){\n            int sz = ret.size();\n            for(int k = sz-1;k >= 0;k --){\n                ret.push_back(ret[k] | 1 << i);\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "111111111111"}, {"id": 281814999, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574771768, "status_display": "Accepted", "runtime": "28 ms", "url": "/submissions/detail/281814999/", "is_pending": "Not Pending", "title": "Clone Graph", "memory": "16.5 MB", "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> neighbors;\n\n    Node() {}\n\n    Node(int _val, vector<Node*> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n};\n*/\nclass Solution {\npublic:\n    Node* cloneGraph(Node* node) {\n        if(node == NULL) return NULL;\n        map<Node*,Node*> table;\n        queue<Node*> nq;\n        nq.push(node);\n        \n        while(nq.size() > 0){\n            Node * t = nq.front();\n            nq.pop();\n            if(table[t] != NULL) continue;\n            table[t] = new Node(t->val,vector<Node*>());\n            for(Node * q : t->neighbors){\n                nq.push(q);\n            }\n        }\n        for(auto it : table){\n            Node * t = it.first;\n            Node * sec = it.second;\n            for(Node * q : t->neighbors){\n                sec->neighbors.push_back(table[q]);\n            }\n        }\n        return table[node];\n    }\n};", "compare_result": "11111111111111111111"}, {"id": 281814046, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574771161, "status_display": "Accepted", "runtime": "16 ms", "url": "/submissions/detail/281814046/", "is_pending": "Not Pending", "title": "Palindrome Partitioning", "memory": "12.9 MB", "code": "class Solution {\npublic:\n    vector<vector<string>> partition(string s) {\n        vector<vector<int> > table(s.size(),vector<int>(s.size(),0));\n        for(int i = 0;i < s.size();i ++){\n            table[i][i] = 1;\n        }\n        \n        for(int i = 1;i < s.size();i ++){\n            for(int j = i-1;j >= 0;j --){\n                if(s[j] == s[i]){\n                    if(j+1 <= i-1){\n                        table[j][i] = table[j+1][i-1];\n                    }else{\n                        table[j][i] = 1;\n                    }\n                }else{\n                    table[j][i] = 0;\n                }\n            }\n        }\n        \n        vector<vector<string> > splits;\n        vector<string> path;\n        dfs(splits,table,s,0,path);\n        return splits;\n    }\n    \n    void dfs(vector<vector<string> > &splits,\n             vector<vector<int> > &table,\n             string &s,int idx,\n             vector<string>&path){\n        if(idx >= s.size()){\n            splits.push_back(path);\n            return;\n        }\n        for(int i = idx;i < s.size();i ++){\n            if(table[idx][i] == 1){\n                path.push_back(s.substr(idx,i-idx+1));\n                dfs(splits,table,s,i+1,path);\n                path.pop_back();\n            }\n        }\n    }\n};", "compare_result": "1111111111111111111111"}, {"id": 281811234, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574769458, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/281811234/", "is_pending": "Not Pending", "title": "Gas Station", "memory": "9.1 MB", "code": "class Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int loss = 0;\n        int sum = 0;\n        int idx = 0;\n        for(int i = 0;i < gas.size();i ++){\n            sum += gas[i] - cost[i];\n            if(sum < 0){\n                sum = 0;\n                idx = i+1;\n            }\n            loss += gas[i] - cost[i];\n        }\n        \n        return loss < 0 ? -1 : idx;\n    }\n};", "compare_result": "1111111111111111111111111111111"}, {"id": 281800610, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574762463, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/281800610/", "is_pending": "Not Pending", "title": "Reverse Linked List II", "memory": "8.6 MB", "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\n        if(m == n || head == NULL) return head;\n        ListNode *fake = new ListNode(0);\n        fake->next = head;\n        int count = 0;\n        ListNode *p = fake;\n        while(count < m-1){\n            count ++;\n            p = p->next;\n        }\n        ListNode * firstEnd = p;\n        ListNode * secondHead = p->next;\n        while(count < n){\n            count ++;\n            p = p->next;\n        }\n        ListNode * secondEnd = p;\n        ListNode * thirdHead = p->next;\n        p->next = NULL;\n        \n        // cout << secondHead->val <<\" \" << secondEnd->val<< endl;\n        ListNode *r = reverseList(secondHead);\n        \n        firstEnd->next = r;\n        secondHead->next = thirdHead;\n        return fake->next;\n    }\n    \n    ListNode *reverseList(ListNode * head){\n        if(head == NULL || head->next == NULL) return head;\n        ListNode *p = head;\n        ListNode *q = head->next;\n        p->next = NULL;\n        \n        while(q != NULL){\n            ListNode * tmp = q->next;\n            q->next = p;\n            p = q;\n            q = tmp;\n        }\n        // cout << p->next->val << p->next->next->val << endl;\n        return p;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111"}, {"id": 281793482, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574758963, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/281793482/", "is_pending": "Not Pending", "title": "Restore IP Addresses", "memory": "8.5 MB", "code": "class Solution {\npublic:\n    vector<string> restoreIpAddresses(string s) {\n        // int a=0,b=0,c=0,d=0\n        vector<string> ret;\n        for(int i =1 ;i <=3;i ++){\n            string a = s.substr(0,i);\n            if(a.size() <=0 || stoi2(a) > 255) break;\n            for(int j =1;j <= 3;j ++){\n                if(i+j > s.size()) continue;\n                string b = s.substr(i,j);\n                if(b.size() <=0 || stoi2(b) > 255) break;\n                for(int k = 1;k <=3;k ++){\n                    if(i+j+k > s.size()) continue;\n                    string c = s.substr(i+j,k);\n                    if(c.size() <=0 || stoi2(c) > 255) break;\n                    for(int p = 1;p <=3;p ++){\n                        if(i+j+k+p != s.size()){\n                            continue;\n                        }\n                        string d = s.substr(i+j+k,p);\n                        if(stoi2(d) > 255) break;\n                        ret.push_back(a+\".\"+b+\".\"+c+\".\"+d);\n                    }\n                }\n            }\n        }\n        return ret;\n    }\n    int stoi2(string s){\n        if(s[0] == '0' && s.size() >1) return 256;\n        return stoi(s);\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 281792925, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574758711, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/281792925/", "is_pending": "Not Pending", "title": "Restore IP Addresses", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<string> restoreIpAddresses(string s) {\n        // int a=0,b=0,c=0,d=0\n        vector<string> ret;\n        for(int i =1 ;i <=3;i ++){\n            string a = s.substr(0,i);\n            if(a.size() <=0 || stoi(a) > 255) break;\n            for(int j =1;j <= 3;j ++){\n                if(i+j > s.size()) continue;\n                string b = s.substr(i,j);\n                if(b.size() <=0 || stoi(b) > 255) break;\n                for(int k = 1;k <=3;k ++){\n                    if(i+j+k > s.size()) continue;\n                    string c = s.substr(i+j,k);\n                    if(c.size() <=0 || stoi(c) > 255) break;\n                    for(int p = 1;p <=3;p ++){\n                        if(i+j+k+p != s.size()){\n                            continue;\n                        }\n                        string d = s.substr(i+j+k,p);\n                        if(stoi(c) > 255) break;\n                        ret.push_back(a+\".\"+b+\".\"+c+\".\"+d);\n                    }\n                }\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "111000011111000011111001111000010011000010101010010010101101110011011010101100010101011111100101000001010101101111100111001110011110110111001111101"}, {"id": 281792523, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574758545, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/281792523/", "is_pending": "Not Pending", "title": "Restore IP Addresses", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<string> restoreIpAddresses(string s) {\n        // int a=0,b=0,c=0,d=0\n        vector<string> ret;\n        for(int i =1 ;i <=3;i ++){\n            string a = s.substr(0,i);\n            if(stoi(a) > 255) break;\n            for(int j =1;j <= 3;j ++){\n                string b = s.substr(i,j);\n                if(stoi(b) > 255) break;\n                for(int k = 1;k <=3;k ++){\n                    string c = s.substr(i+j,k);\n                    if(stoi(c) > 255) break;\n                    for(int p = 1;p <=3;p ++){\n                        if(i+j+k+p != s.size()){\n                            continue;\n                        }\n                        string d = s.substr(i+j+k,p);\n                        if(stoi(c) > 255) break;\n                        ret.push_back(a+\".\"+b+\".\"+c+\".\"+d);\n                    }\n                }\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 281788741, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574757066, "status_display": "Accepted", "runtime": "16 ms", "url": "/submissions/detail/281788741/", "is_pending": "Not Pending", "title": "Surrounded Regions", "memory": "14 MB", "code": "class Solution {\npublic:\n    void solve(vector<vector<char>>& board) {\n        if(board.size() <= 0) return;\n        for(int i = 0;i < board.size();i ++){\n            dfs(board,i,0);\n            dfs(board,i,board[0].size()-1);\n        }\n        \n        for(int i = 0;i < board[0].size();i ++){\n            dfs(board,0,i);\n            dfs(board,board.size()-1,i);\n        }\n        \n        for(int i = 0;i < board.size();i ++){\n            for(int j = 0;j < board[0].size(); j ++){\n                if(board[i][j] == 'O'){\n                    board[i][j] = 'X';\n                }else if (board[i][j] == '#'){\n                    board[i][j] = 'O';\n                }\n            }\n        }\n        \n    }\n    void dfs(vector<vector<char>>& board,int i,int j){\n        if(i <0 || j < 0 || i >= board.size() || j >= board[0].size() || board[i][j] != 'O'){\n            return;\n        }\n        board[i][j] = '#';\n        dfs(board,i-1,j);\n        dfs(board,i+1,j);\n        dfs(board,i,j-1);\n        dfs(board,i,j+1);\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111"}, {"id": 281787715, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574756673, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/281787715/", "is_pending": "Not Pending", "title": "Sum Root to Leaf Numbers", "memory": "12.3 MB", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        if(root == NULL) return 0;\n        int total = 0;\n        sumNumbers(root,0,total);\n        return total;\n    }\n    \n    void sumNumbers(TreeNode*root,int cur,int &total){\n        cur = cur *10 + root->val;\n        if(root->left == NULL && root->right == NULL){\n            total += cur;\n            return;\n        }\n        \n        if(root->left){\n            sumNumbers(root->left,cur,total);\n        }\n        if(root->right){\n            sumNumbers(root->right,cur,total);\n        }\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 281786666, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574756283, "status_display": "Accepted", "runtime": "56 ms", "url": "/submissions/detail/281786666/", "is_pending": "Not Pending", "title": "Populating Next Right Pointers in Each Node", "memory": "27.2 MB", "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n    Node* next;\n\n    Node() {}\n\n    Node(int _val, Node* _left, Node* _right, Node* _next) {\n        val = _val;\n        left = _left;\n        right = _right;\n        next = _next;\n    }\n};\n*/\nclass Solution {\npublic:\n    Node* connect(Node* root) {\n        if(root == NULL)  return root;\n        queue< Node* > nq;\n        int count = 1;\n        nq.push(root);\n        while(nq.size() > 0){\n            int tc = count;\n            count = 0;\n            Node *prev = nq.front();\n            nq.pop();\n            if(prev->left != NULL){\n                count ++;\n                nq.push(prev->left);\n            }\n            if(prev->right != NULL){\n                count ++;\n                nq.push(prev->right);\n            }\n            for(int i = 0;i < tc-1;i ++){\n                Node * tmp = nq.front();\n                nq.pop();\n                prev->next = tmp;\n                if(tmp->left != NULL){\n                    count ++;\n                    nq.push(tmp->left);\n                }\n                if(tmp->right != NULL){\n                    count ++;\n                    nq.push(tmp->right);\n                }\n                prev = tmp;\n            }\n        }\n        return root;\n    }\n};", "compare_result": "111111111111"}, {"id": 281786526, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574756228, "status_display": "Accepted", "runtime": "412 ms", "url": "/submissions/detail/281786526/", "is_pending": "Not Pending", "title": "Populating Next Right Pointers in Each Node II", "memory": "66.8 MB", "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n    Node* next;\n\n    Node() {}\n\n    Node(int _val, Node* _left, Node* _right, Node* _next) {\n        val = _val;\n        left = _left;\n        right = _right;\n        next = _next;\n    }\n};\n*/\nclass Solution {\npublic:\n    Node* connect(Node* root) {\n        if(root == NULL)  return root;\n        queue< Node* > nq;\n        int count = 1;\n        nq.push(root);\n        while(nq.size() > 0){\n            int tc = count;\n            count = 0;\n            Node *prev = nq.front();\n            nq.pop();\n            if(prev->left != NULL){\n                count ++;\n                nq.push(prev->left);\n            }\n            if(prev->right != NULL){\n                count ++;\n                nq.push(prev->right);\n            }\n            for(int i = 0;i < tc-1;i ++){\n                Node * tmp = nq.front();\n                nq.pop();\n                prev->next = tmp;\n                if(tmp->left != NULL){\n                    count ++;\n                    nq.push(tmp->left);\n                }\n                if(tmp->right != NULL){\n                    count ++;\n                    nq.push(tmp->right);\n                }\n                prev = tmp;\n            }\n        }\n        return root;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111"}, {"id": 281785169, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574755712, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/281785169/", "is_pending": "Not Pending", "title": "Flatten Binary Tree to Linked List", "memory": "9.9 MB", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        if(root == NULL) return;\n        if(root->left != NULL) flatten(root->left);\n        if(root->right != NULL) flatten(root->right);\n        TreeNode *right = root->right;\n        if(root->left != NULL){\n            TreeNode *q = root->left;\n            while(q->right != NULL){\n                q = q->right;\n            }\n            q->right = right;\n            root->right = root->left;\n            root->left = NULL;\n        }\n    }\n    \n    \n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 281777030, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574753103, "status_display": "Accepted", "runtime": "16 ms", "url": "/submissions/detail/281777030/", "is_pending": "Not Pending", "title": "Path Sum II", "memory": "19.6 MB", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> pathSum(TreeNode* root, int sum) {\n        vector<vector<int>>ret;\n        vector<int> path;\n        DFS(ret,root,sum,path,0);\n        return ret;\n    }\n    \n    void DFS(vector<vector<int>>&ret,TreeNode* root, int sum,vector<int>&path,int cur){\n        if(root == NULL){\n            return;\n        }\n        cur += root->val;\n        path.push_back(root->val);\n        if(root->left == NULL && root->right == NULL){\n            if(cur == sum){\n                ret.push_back(path);\n            }\n        }\n        \n        if(root->left != NULL){\n            DFS(ret,root->left,sum,path,cur);\n        }\n        if(root->right != NULL){\n            DFS(ret,root->right,sum,path,cur);\n        }\n        path.pop_back();\n        return;\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 281776863, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574753059, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/281776863/", "is_pending": "Not Pending", "title": "Path Sum II", "memory": "N/A", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> pathSum(TreeNode* root, int sum) {\n        vector<vector<int>>ret;\n        vector<int> path;\n        DFS(ret,root,sum,path,0);\n        return ret;\n    }\n    \n    void DFS(vector<vector<int>>&ret,TreeNode* root, int sum,vector<int>&path,int cur){\n        if(root == NULL){\n            if(cur == sum){\n                ret.push_back(path);\n            }\n            return;\n        }\n        cur += root->val;\n        path.push_back(root->val);\n        if(root->left == NULL && root->right == NULL){\n            if(cur == sum){\n                ret.push_back(path);\n            }\n        }\n        \n        if(root->left != NULL){\n            DFS(ret,root->left,sum,path,cur);\n        }\n        if(root->right != NULL){\n            DFS(ret,root->right,sum,path,cur);\n        }\n        path.pop_back();\n        return;\n    }\n};", "compare_result": "110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 281776685, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574753001, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/281776685/", "is_pending": "Not Pending", "title": "Path Sum II", "memory": "N/A", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> pathSum(TreeNode* root, int sum) {\n        vector<vector<int>>ret;\n        vector<int> path;\n        DFS(ret,root,sum,path,0);\n        return ret;\n    }\n    \n    void DFS(vector<vector<int>>&ret,TreeNode* root, int sum,vector<int>&path,int cur){\n        if(root == NULL){\n            if(cur == sum){\n                ret.push_back(path);\n            }\n        }\n        cur += root->val;\n        path.push_back(root->val);\n        if(root->left == NULL && root->right == NULL){\n            if(cur == sum){\n                ret.push_back(path);\n            }\n        }\n        \n        if(root->left != NULL){\n            DFS(ret,root->left,sum,path,cur);\n        }\n        if(root->right != NULL){\n            DFS(ret,root->right,sum,path,cur);\n        }\n        path.pop_back();\n        return;\n    }\n};", "compare_result": "100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 281775384, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574752629, "status_display": "Accepted", "runtime": "32 ms", "url": "/submissions/detail/281775384/", "is_pending": "Not Pending", "title": "Convert Sorted List to Binary Search Tree", "memory": "24.3 MB", "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if(head == NULL) return NULL;\n        if(head->next == NULL) return new TreeNode(head->val);\n        ListNode *slow = head;\n        ListNode *fast = head->next->next;\n        while(fast != NULL){\n            if(fast->next == NULL) break;\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        TreeNode *root = new TreeNode(slow->next->val);\n        ListNode *second = slow->next->next;\n        slow->next = NULL;\n        root->left = sortedListToBST(head);\n        root->right = sortedListToBST(second);\n        return root;\n    }\n};", "compare_result": "11111111111111111111111111111111"}, {"id": 281773275, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574752036, "status_display": "Accepted", "runtime": "16 ms", "url": "/submissions/detail/281773275/", "is_pending": "Not Pending", "title": "Construct Binary Tree from Inorder and Postorder Traversal", "memory": "16.4 MB", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n         return buildTree(inorder,postorder,0,postorder.size()-1,0,inorder.size()-1);\n    }\n    \n    TreeNode* buildTree(vector<int>& inorder, \n                        vector<int>& postorder,\n                        int ps,int pe,\n                        int is,int ie) {\n        if(ps > pe || is > ie) return NULL;\n        int val = postorder[pe];\n        int i = is;\n        while(i <= ie){\n            if(inorder[i] == val) break;\n            i++;\n        }\n        int leftSize = i - is;\n        TreeNode * root = new TreeNode(val);\n        root->left = buildTree(inorder,postorder,ps,ps+leftSize-1,is,i-1);\n        root->right = buildTree(inorder,postorder,ps+leftSize,pe-1,i+1,ie);\n        return root;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 281772362, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574751781, "status_display": "Accepted", "runtime": "20 ms", "url": "/submissions/detail/281772362/", "is_pending": "Not Pending", "title": "Construct Binary Tree from Preorder and Inorder Traversal", "memory": "16.4 MB", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        return buildTree(preorder,inorder,0,preorder.size()-1,0,inorder.size()-1);\n    }\n    \n    TreeNode* buildTree(vector<int>& preorder, \n                        vector<int>& inorder,\n                        int ps,int pe,\n                        int is,int ie) {\n        if(ps > pe || is > ie) return NULL;\n        int val = preorder[ps];\n        int i = is;\n        while(i <= ie){\n            if(inorder[i] == val) break;\n            i++;\n        }\n        int leftSize = i - is;\n        TreeNode * root = new TreeNode(val);\n        root->left = buildTree(preorder,inorder,ps+1,ps+leftSize,is,i-1);\n        root->right = buildTree(preorder,inorder,ps+1+leftSize,pe,i+1,ie);\n        return root;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 281770125, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574751194, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/281770125/", "is_pending": "Not Pending", "title": "Binary Tree Zigzag Level Order Traversal", "memory": "13.1 MB", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n        vector<vector<int>> ret;\n        if(root == NULL) return ret;\n        int count = 1;\n        queue<TreeNode*> tq;\n        tq.push(root);\n        bool status = false;\n        \n        while(tq.size() > 0){\n            vector<int> tmp;\n            int tc = count;\n            count = 0;\n            for(int i = 0;i < tc;i ++){\n                TreeNode *q = tq.front();\n                tq.pop();\n                if(q->left != NULL){\n                    tq.push(q->left);\n                    count ++;\n                }\n                if(q->right != NULL){\n                    tq.push(q->right);\n                    count ++;\n                }\n                tmp.push_back(q->val);\n            }\n            if(status){\n                reverse(tmp.begin(),tmp.end());\n            }\n            status = !status;\n            ret.push_back(tmp);\n        }\n        return ret;\n    }\n};", "compare_result": "111111111111111111111111111111111"}, {"id": 281769659, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574751077, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/281769659/", "is_pending": "Not Pending", "title": "Binary Tree Level Order Traversal", "memory": "13.8 MB", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> ret;\n        if(root == NULL) return ret;\n        int count = 1;\n        queue<TreeNode*> tq;\n        tq.push(root);\n        \n        while(tq.size() > 0){\n            vector<int> tmp;\n            int tc = count;\n            count = 0;\n            for(int i = 0;i < tc;i ++){\n                TreeNode *q = tq.front();\n                tq.pop();\n                if(q->left != NULL){\n                    tq.push(q->left);\n                    count ++;\n                }\n                if(q->right != NULL){\n                    tq.push(q->right);\n                    count ++;\n                }\n                tmp.push_back(q->val);\n            }\n            ret.push_back(tmp);\n        }\n        return ret;\n    }\n};", "compare_result": "1111111111111111111111111111111111"}, {"id": 281767086, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574750409, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/281767086/", "is_pending": "Not Pending", "title": "Search in Rotated Sorted Array II", "memory": "8.7 MB", "code": "class Solution {\npublic:\n    bool search(vector<int>& nums, int target) {\n        if(nums.size() <= 0) return false;\n        int L = 0;\n        int R = nums.size() -1;\n        while(L <= R){\n            int mid = L + (R-L)/2;\n            // cout << L << \" \" << R << endl;\n            if(nums[mid] == target){\n                return true;\n            }\n            while(nums[L] == nums[mid] && L != mid){\n                L ++;\n            }\n            while(nums[R] == nums[mid] && R != mid){\n                R --;\n            }\n            \n            if (nums[mid] > target){\n                if(nums[L] <=  nums[mid] && nums[L] > target){\n                    L = mid+1;\n                }else{\n                    R = mid -1;\n                }\n            }else{\n                if(nums[R] >= nums[mid] && nums[R] < target){\n                    R = mid -1;   \n                }else{\n                    L = mid+1;\n                }\n            }\n        }\n        return false;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 281766320, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574750189, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/281766320/", "is_pending": "Not Pending", "title": "Search in Rotated Sorted Array II", "memory": "N/A", "code": "class Solution {\npublic:\n    bool search(vector<int>& nums, int target) {\n        if(nums.size() <= 0) return false;\n        int L = 0;\n        int R = nums.size() -1;\n        while(L <= R){\n            int mid = L + (R-L)/2;\n            // cout << L << \" \" << R << endl;\n            if(nums[mid] == target){\n                return true;\n            }else if (nums[mid] > target){\n                if(nums[L] <=  nums[mid] && nums[L] > target){\n                    L = mid+1;\n                }else{\n                    R = mid -1;\n                }\n            }else{\n                if(nums[R] >= nums[mid] && nums[R] < target){\n                    R = mid -1;   \n                }else{\n                    L = mid+1;\n                }\n            }\n        }\n        return false;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111110111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111011111"}, {"id": 281766043, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574750121, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/281766043/", "is_pending": "Not Pending", "title": "Search in Rotated Sorted Array II", "memory": "N/A", "code": "class Solution {\npublic:\n    bool search(vector<int>& nums, int target) {\n        if(nums.size() <= 0) return false;\n        int L = 0;\n        int R = nums.size() -1;\n        while(L <= R){\n            int mid = L + (R-L)/2;\n            cout << L << \" \" << R << endl;\n            if(nums[mid] == target){\n                return true;\n            }else if (nums[mid] > target){\n                if(nums[L] <= nums[mid] && nums[L] > target){\n                    L = mid+1;\n                }else{\n                    R = mid -1;\n                }\n            }else{\n                if(nums[R] > nums[mid] && nums[R] < target){\n                    R = mid -1;   \n                }else{\n                    L = mid+1;\n                }\n            }\n        }\n        return false;\n    }\n};", "compare_result": "11111111111111111111111111111111111101111111111111111111111111111111111111111011111111111111111110111101111111111111101111111111111111111111111111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111011111"}, {"id": 281763344, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574749435, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/281763344/", "is_pending": "Not Pending", "title": "Search in Rotated Sorted Array II", "memory": "N/A", "code": "class Solution {\npublic:\n    bool search(vector<int>& nums, int target) {\n        if(nums.size() <= 0) return false;\n        int L = 0;\n        int R = nums.size() -1;\n        while(L <= R){\n            int mid = L + (R-L)/2;\n            if(nums[mid] == target){\n                return true;\n            }else if (nums[mid] > target){\n                if(nums[L] < nums[mid] && nums[L] <= target){\n                    R = mid-1;\n                }else{\n                    L = mid +1;\n                }\n            }else{\n                if(nums[R] > nums[mid] && nums[R] >=target){\n                    L = mid+1;\n                }else{\n                    R = mid -1;\n                }\n            }\n        }\n        return false;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111110111111111111111111101111111111111111111111111101111111111111111111111111111111111011111111111111111111111111111111110111111111111111111111111111111101111111111111111111111111111111111111111100101110011011111"}, {"id": 281735619, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574742218, "status_display": "Accepted", "runtime": "12 ms", "url": "/submissions/detail/281735619/", "is_pending": "Not Pending", "title": "Simplify Path", "memory": "14 MB", "code": "class Solution {\npublic:\n    string simplifyPath(string path) {\n        vector<string> stk;\n        string tmp,ret;\n        stringstream ss(path);\n        while(getline(ss,tmp,'/')){\n            if(tmp == \"\" || tmp == \".\") continue;\n            if(tmp == \"..\" && !stk.empty()) {\n                stk.pop_back();\n            }\n            else if(tmp != \"..\"){\n                stk.push_back(tmp);\n            }\n        }\n        for(auto s: stk){\n            ret = ret +\"/\" + s ;\n        }\n        return ret.empty()? \"/\": ret;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 281735485, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574742182, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/281735485/", "is_pending": "Not Pending", "title": "Simplify Path", "memory": "N/A", "code": "class Solution {\npublic:\n    string simplifyPath(string path) {\n        vector<string> stk;\n        string tmp,ret;\n        stringstream ss(path);\n        while(getline(ss,tmp,'/')){\n            if(tmp == \"\" || tmp == \".\") continue;\n            if(tmp == \"..\" && !stk.empty()) {\n                stk.pop_back();\n            }\n            else if(tmp != \"..\"){\n                stk.push_back(tmp);\n            }\n        }\n        for(auto s: stk){\n            ret = \"/\" + s + ret;\n        }\n        return ret.empty()? \"/\": ret;\n    }\n};", "compare_result": "11011011111110111111001000000000001110010000001000001101001110101110001000001010000010110100010100000000001000000000000000100000100001000100000000000000000000000000000000000000000001000000000010000000000000000000000000000000000000000000000000000000000000"}, {"id": 281735103, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574742078, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/281735103/", "is_pending": "Not Pending", "title": "Simplify Path", "memory": "N/A", "code": "class Solution {\npublic:\n    string simplifyPath(string path) {\n        vector<string> stk;\n        string tmp,ret;\n        stringstream ss(path);\n        while(getline(ss,tmp,'/')){\n            if(tmp == \"\" || tmp == \".\") continue;\n            else if(tmp == \"..\" && !stk.empty()) stk.pop_back();\n            else{\n                stk.push_back(tmp);\n            }\n        }\n        for(auto s: stk){\n            ret = \"/\" + s + ret;\n        }\n        return ret.empty()? \"/\": ret;\n    }\n};", "compare_result": "10010011110110111111001000000000000110000000000000000101001110000100000000000000000010100100000100000000000000000000000000000000100001000000000000000000000000000000000000000000000001000000000010000000000000000000000000000000000000000000000000000000000000"}, {"id": 281586569, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574696122, "status_display": "Accepted", "runtime": "16 ms", "url": "/submissions/detail/281586569/", "is_pending": "Not Pending", "title": "Search a 2D Matrix", "memory": "9.8 MB", "code": "class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        if(matrix.size() <= 0) return false;\n        return searchMatrix(matrix,target,0,0,matrix.size()-1,matrix[0].size()-1);\n    }\n    \n    bool searchMatrix(vector<vector<int>>& matrix, int target,int li,int lj,int ri,int rj){\n        if(li > ri || lj > rj || li < 0 || lj < 0  || rj >= matrix[0].size() || ri >= matrix.size() ){\n            return false;\n        }\n        \n        int mi = (li + ri)/2;\n        int mj = (lj + rj)/2;\n        // cout << mi << \" \" << mj << endl;\n        if(matrix[mi][mj] == target) return true;\n        if(matrix[mi][mj] > target){\n            return searchMatrix(matrix,target,mi,lj,ri,mj-1) ||searchMatrix(matrix,target,li,lj,mi-1,rj);\n        }else{\n            return searchMatrix(matrix,target,mi+1,lj,ri,rj) ||searchMatrix(matrix,target,li,mj+1,mi,rj);\n        }\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 281586510, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574696101, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/281586510/", "is_pending": "Not Pending", "title": "Search a 2D Matrix", "memory": "N/A", "code": "class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        return searchMatrix(matrix,target,0,0,matrix.size()-1,matrix[0].size()-1);\n    }\n    \n    bool searchMatrix(vector<vector<int>>& matrix, int target,int li,int lj,int ri,int rj){\n        if(li > ri || lj > rj || li < 0 || lj < 0  || rj >= matrix[0].size() || ri >= matrix.size() ){\n            return false;\n        }\n        \n        int mi = (li + ri)/2;\n        int mj = (lj + rj)/2;\n        // cout << mi << \" \" << mj << endl;\n        if(matrix[mi][mj] == target) return true;\n        if(matrix[mi][mj] > target){\n            return searchMatrix(matrix,target,mi,lj,ri,mj-1) ||searchMatrix(matrix,target,li,lj,mi-1,rj);\n        }else{\n            return searchMatrix(matrix,target,mi+1,lj,ri,rj) ||searchMatrix(matrix,target,li,mj+1,mi,rj);\n        }\n    }\n};", "compare_result": "1100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 281564639, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574685640, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/281564639/", "is_pending": "Not Pending", "title": "Subsets II", "memory": "9.4 MB", "code": "class Solution {\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        vector<vector<int> > ret;\n        ret.push_back(vector<int>());\n        int idx = 0;\n        while(idx < nums.size()){\n            int sz = ret.size();\n            int val = nums[idx];\n            int cur = idx;\n            while(idx < nums.size() && nums[idx] == nums[cur]){\n                idx ++;\n            }\n            for(int i =0;i < sz;i ++){\n                vector<int> tmp = ret[i];\n                for(int j = cur;j < idx;j ++){\n                    tmp.push_back(val);\n                    ret.push_back(tmp);\n                }\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "1111111111111111111"}, {"id": 281563864, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574685141, "status_display": "Accepted", "runtime": "80 ms", "url": "/submissions/detail/281563864/", "is_pending": "Not Pending", "title": "Combinations", "memory": "11.8 MB", "code": "class Solution {\npublic:\n    vector<vector<int>> combine(int n, int k) {\n        vector<vector<int> > ret;\n        vector<int> tmp;\n        dfs(ret,n,k,1,tmp);\n        return ret;\n    }\n    void dfs(vector<vector<int> >&ret,int n,int k,int cur,vector<int> &path){\n        if(k == 0){\n            ret.push_back(path);\n            return;\n        }\n        \n        for(int i = cur;i <= n;i ++){\n            path.push_back(i);\n            dfs(ret,n,k-1,i+1,path);\n            path.pop_back();\n        }\n    }\n};", "compare_result": "111111111111111111111111111"}, {"id": 281562036, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574684046, "status_display": "Accepted", "runtime": "12 ms", "url": "/submissions/detail/281562036/", "is_pending": "Not Pending", "title": "Remove Duplicates from Sorted Array II", "memory": "8.8 MB", "code": "class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int iret = 0;\n        int idx = 0;\n        int k = 0;\n        while(idx < nums.size()){\n            int cur = idx;\n            idx += 1;\n            while(idx < nums.size() && nums[idx] == nums[cur]) idx ++;\n            iret += min(2,idx-cur);\n            for(int j = 0;j <min(2,idx-cur);j ++){\n                nums[k++] = nums[cur+j];\n            }\n        }\n        return iret;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 281561474, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574683706, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/281561474/", "is_pending": "Not Pending", "title": "Remove Duplicates from Sorted List II", "memory": "9.1 MB", "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        if(head == NULL) return head;\n        ListNode *nhead = NULL;\n        ListNode *ntail = NULL;\n        ListNode *p = head;\n        while(p != NULL){\n            ListNode *q = p;\n            p = p->next;\n            while(p != NULL && p->val == q->val){\n                p = p->next;\n            }\n            if(p == q->next){\n                if(nhead == NULL){\n                    nhead = q;\n                    ntail = q;\n                }else{\n                    ntail->next = q;\n                    ntail = q;\n                }\n                ntail->next = NULL;\n            }\n        }\n        return nhead;\n        \n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 281560401, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574683040, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/281560401/", "is_pending": "Not Pending", "title": "Partition List", "memory": "8.7 MB", "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        ListNode *firstHead = NULL;\n        ListNode *firstEnd = NULL;\n        ListNode *secondHead = NULL;\n        ListNode *secondEnd = NULL;\n        ListNode *p = head;\n        \n        while(p != NULL){\n            if(p->val < x){\n                if(firstHead == NULL){\n                    firstHead = p;\n                    firstEnd = p;\n                }else{\n                    firstEnd->next = p;\n                    firstEnd = p;\n                }\n                p = p->next;\n                firstEnd->next = NULL;\n            }else{\n                if(secondHead == NULL){\n                    secondHead = p;\n                    secondEnd = p;\n                }else{\n                    secondEnd->next = p;\n                    secondEnd = p;\n                }\n                p = p->next;\n                secondEnd->next = NULL;\n            }\n        }\n        \n        if(firstHead == NULL){\n            return secondHead;\n        }\n        if(secondHead == NULL){\n            return firstHead;\n        }\n        \n        firstEnd->next = secondHead;\n        return firstHead;\n        \n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 281558200, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574681584, "status_display": "Accepted", "runtime": "60 ms", "url": "/submissions/detail/281558200/", "is_pending": "Not Pending", "title": "Set Matrix Zeroes", "memory": "11.4 MB", "code": "class Solution {\npublic:\n    void setZeroes(vector<vector<int>>& matrix) {\n        int row0 = 1;\n        for(int i = 0;i < matrix.size();i ++){\n            for(int j = 0;j < matrix[0].size();j ++){\n                if(matrix[i][j] == 0){\n                   if(i == 0){\n                       row0 = 0;\n                   }else{\n                       matrix[i][0] = 0;\n                   }\n                   matrix[0][j] = 0; \n                }\n                \n\n            }\n        }\n        //row\n        for(int i = 1;i < matrix.size();i ++){\n            if(matrix[i][0] == 0){\n                for(int j = 0;j < matrix[0].size(); j ++){\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n        \n        //column\n        for(int i = 0;i < matrix[0].size();i ++){\n            if(matrix[0][i] == 0){\n                for(int j = 0;j < matrix.size(); j ++){\n                    matrix[j][i] = 0;\n                }\n            }\n        }\n        \n        //\n        // cout << row0 << endl;\n        if(row0 == 0){\n            for(int j = 0;j < matrix[0].size(); j ++){\n                matrix[0][j] = 0;\n            }\n        }\n    \n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 281558060, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574681505, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/281558060/", "is_pending": "Not Pending", "title": "Set Matrix Zeroes", "memory": "N/A", "code": "class Solution {\npublic:\n    void setZeroes(vector<vector<int>>& matrix) {\n        int row0 = 1;\n        for(int i = 0;i < matrix.size();i ++){\n            for(int j = 0;j < matrix[0].size();j ++){\n                if(matrix[i][j] == 0){\n                   if(i == 0){\n                       row0 = 0;\n                   }else{\n                       matrix[i][0] = 0;\n                   }\n                   matrix[0][j] = 0; \n                }\n                \n                // if(i == 0 && matrix[i][j] ==0){\n                //     row0 == 0;\n                // }else if(matrix[i][j] ==0){\n                //     matrix[i][0] = 0;\n                //     matrix[0][j] = 0;\n                // }\n            }\n        }\n        //row\n        for(int i = 1;i < matrix.size();i ++){\n            if(matrix[i][0] == 0){\n                for(int j = 0;j < matrix[0].size(); j ++){\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n        \n        //column\n        for(int i = 0;i < matrix[0].size();i ++){\n            if(matrix[0][i] == 0){\n                for(int j = 0;j < matrix.size(); j ++){\n                    matrix[j][i] = 0;\n                }\n            }\n        }\n        \n        //\n        if(row0 == 0){\n            for(int j = 0;j < matrix.size(); j ++){\n                matrix[0][j] = 0;\n            }\n        }\n    \n    }\n};", "compare_result": "111101000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 281550941, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574676586, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/281550941/", "is_pending": "Not Pending", "title": "Rotate List", "memory": "9 MB", "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        int count = 0;\n        ListNode *p = head;\n        while(p != NULL){\n            count ++;\n            p = p->next;\n        }\n        if(count <= 1) return head;\n        \n        k = k % count;\n        if(k == 0) return head;\n        int left = count - k;\n        p = head;\n        while(p != NULL && left > 1){\n            left --;\n            p = p->next;\n        }\n        ListNode * secondhead = p->next;\n        p->next = NULL;\n        p = secondhead;\n        while(p != NULL && p->next != NULL){\n            p = p->next;\n        }\n        p->next = head;\n        return secondhead;\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 281548686, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574675342, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/281548686/", "is_pending": "Not Pending", "title": "Spiral Matrix II", "memory": "8.8 MB", "code": "class Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        vector<vector<int> > ret(n,vector<int>(n,0));\n        int L = 0, R = n-1;\n        int U = 0, D = n-1;\n        int K = 1;\n        while(L <= R && U <= D){\n            for(int i = L;i <= R;i ++){\n                ret[U][i] = K ++;\n            }\n            U ++;\n            for(int i = U;i <= D;i ++){\n                ret[i][R] = K ++;\n            }\n            R --;\n            if(L <= R && U <= D){\n                for(int i = R;i >=L;i --){\n                    ret[D][i] = K ++;\n                }\n                D --;\n            }\n            \n            if(L <= R && U <= D){\n                for(int i = D;i >=U;i --){\n                    ret[i][L] = K ++;\n                }\n                L ++;\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "11111111111111111111"}, {"id": 281544629, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574673253, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/281544629/", "is_pending": "Not Pending", "title": "Spiral Matrix", "memory": "8.5 MB", "code": "class Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        vector<pair<int,int> > actions;\n        vector<int> ret;\n        if(matrix.size() <= 0) return ret;\n        int L = 0;\n        int U = 0;\n        int R = matrix[0].size()-1;\n        int D = matrix.size()-1;\n        while(L <=R && U <= D){\n            for(int i = L;i <= R;i ++){\n                ret.push_back(matrix[U][i]);\n            }\n            U ++;\n            for(int i = U;i <= D;i ++){\n                ret.push_back(matrix[i][R]);\n            }\n            R --;\n            \n            if(U <= D && L <= R){\n                for(int i = R;i >= L;i --){\n                    ret.push_back(matrix[D][i]);\n                }\n                D --;\n            }\n            if(U <= D && L <= R){\n                for(int i = D;i >= U;i --){\n                    ret.push_back(matrix[i][L]);\n                }\n                L ++;\n            }\n        }\n        return ret;\n        \n    }\n};", "compare_result": "1111111111111111111111"}, {"id": 281544567, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574673227, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/281544567/", "is_pending": "Not Pending", "title": "Spiral Matrix", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        vector<pair<int,int> > actions;\n        vector<int> ret;\n        int L = 0;\n        int U = 0;\n        int R = matrix[0].size()-1;\n        int D = matrix.size()-1;\n        while(L <=R && U <= D){\n            for(int i = L;i <= R;i ++){\n                ret.push_back(matrix[U][i]);\n            }\n            U ++;\n            for(int i = U;i <= D;i ++){\n                ret.push_back(matrix[i][R]);\n            }\n            R --;\n            \n            if(U <= D && L <= R){\n                for(int i = R;i >= L;i --){\n                    ret.push_back(matrix[D][i]);\n                }\n                D --;\n            }\n            if(U <= D && L <= R){\n                for(int i = D;i >= U;i --){\n                    ret.push_back(matrix[i][L]);\n                }\n                L ++;\n            }\n        }\n        return ret;\n        \n    }\n};", "compare_result": "1100000000000000000000"}, {"id": 281536413, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574669729, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/281536413/", "is_pending": "Not Pending", "title": "Spiral Matrix", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        vector<pair<int,int> > actions;\n        actions.push_back(pair<int,int>(0,1));\n        actions.push_back(pair<int,int>(1,0));\n        actions.push_back(pair<int,int>(0,-1));\n        actions.push_back(pair<int,int>(-1,0));\n        vector<int> ret;\n        int x = 0;\n        int y = 0;\n        int idx = 0;\n        int L = 0;\n        int R = matrix[0].size()-1;\n        int U = 0;\n        int D = matrix.size()-1;\n        while(L <=R && U <= D){\n            //L-> R\n            pair<int,int> action = actions[idx];\n            while(y <= R){\n                ret.push_back(matrix[x][y]);\n                x += action.first;\n                y += action.second;\n            }\n            U ++;\n            y --;\n            x++;\n            \n            idx = (idx +1) %4;\n            action = actions[idx];\n            // U -> D\n            while(x <= D){\n                ret.push_back(matrix[x][y]);\n                x += action.first;\n                y += action.second;\n                \n            }\n            R --;\n            x --;\n            y --;\n            idx = (idx +1) %4;\n            \n            action = actions[idx];\n            // R -> L\n            while(y >= L){\n                ret.push_back(matrix[x][y]);\n                x += action.first;\n                y += action.second;\n                \n            }\n            D --;\n            y ++;\n            x --;\n            idx = (idx +1) %4;\n            \n            action = actions[idx];\n            // R -> L\n            while(x >= U){\n                ret.push_back(matrix[x][y]);\n                x += action.first;\n                y += action.second;\n                \n            }\n            L ++;\n            x ++;\n            y ++;\n            idx = (idx +1) %4;\n        }\n        return ret;\n        \n    }\n};", "compare_result": "1000000000000000000000"}, {"id": 281527683, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574666747, "status_display": "Accepted", "runtime": "12 ms", "url": "/submissions/detail/281527683/", "is_pending": "Not Pending", "title": "Merge Intervals", "memory": "12.4 MB", "code": "class Solution {\npublic:\n    static int mycomp(vector<int> & a,vector<int> &b){\n        return a[0] < b[0];\n    }\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(),intervals.end(),mycomp);\n        vector<vector<int> > ret;\n        if(intervals.size() <= 0) return ret;\n        int start = intervals[0][0];\n        int end = intervals[0][1];\n        // cout << start << \" \" << end<< endl;\n        for(int i = 1;i < intervals.size(); i ++){\n            if(intervals[i][0] > end){\n                vector<int> tmp;\n                tmp.push_back(start);\n                tmp.push_back(end);\n                ret.push_back(tmp);\n                start = intervals[i][0];\n                end = intervals[i][1];\n            }else{\n                end = max(end,intervals[i][1]);\n            }\n        }\n        \n        vector<int> tmp;\n        tmp.push_back(start);\n        tmp.push_back(end);\n        ret.push_back(tmp);\n        \n        return ret;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 281526708, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574666429, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/281526708/", "is_pending": "Not Pending", "title": "Merge Intervals", "memory": "N/A", "code": "class Solution {\npublic:\n    static int mycomp(vector<int> & a,vector<int> &b){\n        return a[0] < b[0];\n    }\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        vector<vector<int> > ret;\n        if(intervals.size() <= 0) return ret;\n        int start = intervals[0][0];\n        int end = intervals[0][1];\n        for(int i = 1;i < intervals.size(); i ++){\n            if(intervals[i][0] > end){\n                vector<int> tmp;\n                tmp.push_back(start);\n                tmp.push_back(end);\n                ret.push_back(tmp);\n                start = intervals[i][0];\n                end = intervals[i][1];\n            }else{\n                end = max(end,intervals[i][1]);\n            }\n        }\n        vector<int> tmp;\n        tmp.push_back(start);\n        tmp.push_back(end);\n        ret.push_back(tmp);\n        \n        return ret;\n    }\n};", "compare_result": "1111111100010000000000000000000000100000000000000000000000000000000000000000000000000000000100000000000100000001011000000000000000000100000100010100000000000000000000000"}, {"id": 281523609, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574665491, "status_display": "Accepted", "runtime": "44 ms", "url": "/submissions/detail/281523609/", "is_pending": "Not Pending", "title": "Group Anagrams", "memory": "20 MB", "code": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<string,vector<string>> tables;\n        for(string s: strs){\n            string tmp = s;\n            sort(tmp.begin(),tmp.end());\n            tables[tmp].push_back(s);\n        }\n        \n        vector<vector<string>> ret;\n        for(auto it : tables){\n            ret.push_back(it.second);\n        }\n        return ret;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 281471854, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574651624, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/281471854/", "is_pending": "Not Pending", "title": "Rotate Image", "memory": "9.1 MB", "code": "class Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        \n        if(matrix.size() <= 1) return ;\n        int L = 0;\n        int H = matrix.size() -1;\n        //flip matrix\n        while(L < H){\n            for(int i = 0;i < matrix.size();i ++){\n                swap(matrix[L][i],matrix[H][i]);\n            }\n            L ++;\n            H --;\n        }\n        // for(int i =0;i < matrix.size();i ++){\n        //     for(int j = 0;j < matrix.size();j ++){\n        //         cout << matrix[i][j] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        \n        //\n        for(int i =0;i < matrix.size();i ++){\n            for(int j = 0;j < i;j ++){\n                // cout << matrix[i][j] << \" \" << matrix[j][i] << endl;\n                swap(matrix[i][j],matrix[j][i]);\n            }\n        }\n    }\n};", "compare_result": "111111111111111111111"}, {"id": 281460343, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574648794, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/281460343/", "is_pending": "Not Pending", "title": "Combination Sum II", "memory": "9 MB", "code": "class Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        sort(candidates.begin(),candidates.end());\n        vector<vector<int>>  result;\n        vector<int> path;\n        DFS(result,candidates,target,0,0,path);\n        return result;\n    }\n    void DFS(vector<vector<int>> & result,vector<int>& candidates, int target,int idx,int cur,vector<int> &path){\n        if(target == cur){\n            result.push_back(path);\n            return;\n        }\n        \n        for(int i = idx;i < candidates.size();i ++){\n            if(i > idx && candidates[i] == candidates[i-1]){\n                continue;\n            }\n            if(cur + candidates[i] <= target){\n                path.push_back(candidates[i]);\n                DFS(result,candidates,target,i+1,cur+candidates[i],path);\n                path.pop_back();\n            }\n        }\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 281322839, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574608961, "status_display": "Accepted", "runtime": "12 ms", "url": "/submissions/detail/281322839/", "is_pending": "Not Pending", "title": "Combination Sum", "memory": "9.2 MB", "code": "class Solution {\npublic:\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        sort(candidates.begin(),candidates.end());\n        vector<vector<int> > result;\n        vector<int> path;\n        dfs(result,candidates,target,0,0,path);\n        return result;\n    }\n    void dfs(vector<vector<int>>& result,vector<int>& candidates, int target,int idx,int cur,vector<int> &path){\n        if(cur == target){\n            result.push_back(path);\n            return;\n        }\n        for(int i = idx;i < candidates.size();i ++){\n            if(candidates[i] + cur <= target){\n                path.push_back(candidates[i]);\n                dfs(result,candidates,target,i,cur+candidates[i],path);\n                path.pop_back();\n            }else{\n                break;\n            }\n        }\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 281321693, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574608419, "status_display": "Accepted", "runtime": "24 ms", "url": "/submissions/detail/281321693/", "is_pending": "Not Pending", "title": "Multiply Strings", "memory": "14.4 MB", "code": "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        if(num1 == \"0\" || num2 == \"0\") return \"0\";\n        string last = \"\";\n        string result = \"\";\n        reverse(num1.begin(),num1.end());\n        reverse(num2.begin(),num2.end());\n        // cout << num1 << \" \" << num2 << endl;\n        for(int i = 0;i < num1.size();i ++){\n            if(num1[i] != '0'){\n                string t1 = multiplyChar(num1[i],num2) + last ;\n                // cout << t1 << endl;\n                result = addString(result,t1);\n            }\n            last = last + \"0\";\n        }\n        return result;\n    }\n    \n    string multiplyChar(char a,string b){\n        // reverse(b.begin(),b.end());\n        int c = 0;\n        int ia = a-'0';\n        string result  = \"\";\n        for(int i = 0;i < b.size();i ++){\n            char cur = ((b[i] -'0' ) * ia + c )%10 + '0';\n            c = ((b[i] -'0' ) * ia + c )/10;\n            result.push_back(cur);\n        }\n        if(c != 0){\n            result.push_back(c + '0');\n        }\n        reverse(result.begin(),result.end());\n        return result;\n    }\n    \n    string addString(string a,string b){\n        if(a == \"0\" ){\n            return b; \n        }\n        if(b == \"0\"){\n            return a;\n        }\n        int c = 0;\n        int idx = 0;\n        string result = \"\";\n        reverse(a.begin(),a.end());\n        reverse(b.begin(),b.end());\n        while(idx < min(a.size(),b.size())){\n            char cur = (a[idx] - '0' + b[idx] - '0' + c)%10 + '0';\n            c = (a[idx] - '0' + b[idx] - '0' + c)/10 ;\n            result.push_back(cur);\n            idx ++;\n        }\n        while(idx < a.size()){\n            char cur = (a[idx] - '0' + c)%10 + '0';\n            c = (a[idx] - '0' + c)/10 ;\n            result.push_back(cur);\n            idx ++;\n        }\n        \n        while(idx < b.size()){\n            char cur = (b[idx] - '0' + c)%10 + '0';\n            c = (b[idx] - '0' + c)/10 ;\n            result.push_back(cur);\n            idx ++;\n        }\n        \n        if(c != 0){\n            result.push_back(c + '0');\n        }\n        reverse(result.begin(),result.end());\n        return result;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 281321568, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574608360, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/281321568/", "is_pending": "Not Pending", "title": "Multiply Strings", "memory": "N/A", "code": "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        if(num1 == \"0\" || num2 == \"0\") return \"0\";\n        string last = \"\";\n        string result = \"\";\n        reverse(num1.begin(),num1.end());\n        reverse(num2.begin(),num2.end());\n        // cout << num1 << \" \" << num2 << endl;\n        for(int i = 0;i < num1.size();i ++){\n            if(num1[i] != '0'){\n                string t1 = multiplyChar(num1[i],num2) + last ;\n                // cout << t1 << endl;\n                result = addString(result,t1);\n            }\n            last = last + \"0\";\n        }\n        return result;\n    }\n    \n    string multiplyChar(char a,string b){\n        // reverse(b.begin(),b.end());\n        int c = 0;\n        int ia = a-'0';\n        string result  = \"\";\n        for(int i = 0;i < b.size();i ++){\n            char cur = ((b[i] -'0' ) * ia + c )%10 + '0';\n            c = ((b[i] -'0' ) * ia + c )/10;\n            result.push_back(cur);\n        }\n        reverse(result.begin(),result.end());\n        return result;\n    }\n    \n    string addString(string a,string b){\n        if(a == \"0\" ){\n            return b; \n        }\n        if(b == \"0\"){\n            return a;\n        }\n        int c = 0;\n        int idx = 0;\n        string result = \"\";\n        reverse(a.begin(),a.end());\n        reverse(b.begin(),b.end());\n        while(idx < min(a.size(),b.size())){\n            char cur = (a[idx] - '0' + b[idx] - '0' + c)%10 + '0';\n            c = (a[idx] - '0' + b[idx] - '0' + c)/10 ;\n            result.push_back(cur);\n            idx ++;\n        }\n        while(idx < a.size()){\n            char cur = (a[idx] - '0' + c)%10 + '0';\n            c = (a[idx] - '0' + c)/10 ;\n            result.push_back(cur);\n            idx ++;\n        }\n        \n        while(idx < b.size()){\n            char cur = (b[idx] - '0' + c)%10 + '0';\n            c = (b[idx] - '0' + c)/10 ;\n            result.push_back(cur);\n            idx ++;\n        }\n        \n        if(c != 0){\n            result.push_back(c + '0');\n        }\n        reverse(result.begin(),result.end());\n        return result;\n    }\n};", "compare_result": "10111000010001010001101001000010001000010000110000010000000000100000000000001000010001000001100000001000100000000000000000000010000000000000100000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000010000000000000000000000000000000000000000000000000"}, {"id": 281317879, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574606670, "status_display": "Accepted", "runtime": "540 ms", "url": "/submissions/detail/281317879/", "is_pending": "Not Pending", "title": "4Sum", "memory": "36.3 MB", "code": "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n        map<int,int> table;\n        for(int i : nums){\n            table[i] ++;\n        }\n        \n        map<int,vector<pair<int,int> > > conbines;\n        for(int i = 0;i < nums.size();i ++){\n            for(int j = i+1;j < nums.size();j ++){\n                conbines[nums[i] + nums[j]].push_back(pair<int,int>(i,j));\n            }\n        }\n        \n        set<vector<int>> result;\n        \n        for(auto i  = conbines.begin(); i != conbines.end();i ++){\n            for(auto j  = i ;j != conbines.end();j ++){\n                if(i->first + j->first >  target){\n                    break;\n                }\n                if(i->first + j->first == target){\n                    for(auto k : i->second){\n                        for(auto m : j->second){\n                            set<int> keys;\n                            keys.insert(k.first);\n                            keys.insert(k.second);\n                            keys.insert(m.first);\n                            keys.insert(m.second);\n                            if(keys.size() == 4){\n                                vector<int> tmp;\n                                for(auto idx: keys){\n                                    tmp.push_back(nums[idx]);\n                                }\n                                result.insert(tmp);\n                            }\n                            \n                        }\n                    }\n                }\n                \n            }\n        }\n        \n        return vector<vector<int>> (result.begin(),result.end());\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 281291463, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574591583, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/281291463/", "is_pending": "Not Pending", "title": "3Sum Closest", "memory": "8.8 MB", "code": "class Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n        int diff = INT_MAX;\n        int theOne = 0;\n        for(int i = 0;i < nums.size() -2;i ++){\n            int L = i+1;\n            int R = nums.size() -1;\n            while(L < R){\n                int sum = nums[i] + nums[L] + nums[R];\n                if(sum == target) return target;\n                if(diff > abs(target - sum)){\n                    diff = abs(target - sum);\n                    theOne = sum;\n                }\n                if(sum < target){\n                    L ++;\n                }else{\n                    R --;\n                }\n            }\n        }\n        return theOne;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 281291243, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574591451, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/281291243/", "is_pending": "Not Pending", "title": "3Sum Closest", "memory": "N/A", "code": "class Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n        int diff = INT_MAX;\n        int theOne = 0;\n        for(int i = 0;i < nums.size() -2;i ++){\n            int L = i+1;\n            int R = nums.size() -1;\n            int sum = nums[i] + nums[L] + nums[R];\n            while(L < R){\n                if(sum == target) return target;\n                if(diff > abs(target - sum)){\n                    diff = abs(target - sum);\n                    theOne = sum;\n                }\n                if(sum < target){\n                    L ++;\n                }else{\n                    R --;\n                }\n            }\n        }\n        return theOne;\n    }\n};", "compare_result": "11111111111111010111001010000100110000000010001010001001000000000010010000000001000010000001011010000101110001010100001010010"}, {"id": 281287951, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574589638, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/281287951/", "is_pending": "Not Pending", "title": "Swap Nodes in Pairs", "memory": "8.8 MB", "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == NULL || head->next == NULL) return head;\n        ListNode * ret = head->next;\n        ListNode *p = head;\n        ListNode *prev = NULL;\n        while(p != NULL && p->next != NULL){\n            ListNode *q = p->next->next;\n            if(prev != NULL){\n                prev->next = p->next;\n            }\n            p->next->next = p;\n            p->next = q;\n            prev = p;\n            p = q;\n        }\n        return ret;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111"}, {"id": 281205167, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574565383, "status_display": "Accepted", "runtime": "20 ms", "url": "/submissions/detail/281205167/", "is_pending": "Not Pending", "title": "Container With Most Water", "memory": "9.8 MB", "code": "class Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        if(height.size() <= 1) return 0;\n        int L = 0;\n        int R = height.size() -1;\n        int mx = 0;\n        while(L < R){\n            mx = max(mx,(R-L)*min(height[L],height[R]));\n            if(height[L] < height[R]){\n                L ++;\n            }else if (height[L] > height[R]){\n                R --;\n            }else if (height[L] == height[R]){\n                L ++;\n                R --;\n            }\n        }\n        return mx;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111"}, {"id": 280756982, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574392966, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/280756982/", "is_pending": "Not Pending", "title": "ZigZag Conversion", "memory": "10 MB", "code": "class Solution {\npublic:\n    string convert(string s, int numRows) {\n        if(numRows <= 1) return s;\n        string sret(s.size(),' ');\n        int k = 0;\n        int seasonality = 2*numRows-2;\n        for(int i = 0;i < numRows;i ++){\n            int index = i;\n            while(index < s.size()){\n                sret[k++] = s[index];\n                if(i > 0 && i < numRows-1 && (index + 2*(numRows-i-1)) < s.size()){\n                    sret[k++] = s[index + 2*(numRows-i-1)];\n                }\n                index  += seasonality;\n            }\n        }\n        return sret;\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 280570839, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574322698, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/280570839/", "is_pending": "Not Pending", "title": "Monotone Increasing Digits", "memory": "8.3 MB", "code": "class Solution {\npublic:\n    int monotoneIncreasingDigits(int N) {\n        string n_str = to_string(N);\n        int maker=  n_str.size();\n        for(int i = n_str.size()-1;i >0;i --){\n            if(n_str[i] < n_str[i-1]){\n                maker = i;\n                n_str[i-1] = n_str[i-1] -1; \n            }\n        }\n        \n        for(int i = maker;i < n_str.size();i ++){\n            n_str[i] = '9';\n        }\n        \n        return stoi(n_str);\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 280569538, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574322296, "status_display": "Accepted", "runtime": "80 ms", "url": "/submissions/detail/280569538/", "is_pending": "Not Pending", "title": "Queue Reconstruction by Height", "memory": "13.1 MB", "code": "class Solution {\npublic:\n    static int mycomp(vector<int> &a,vector<int>&b){\n        if(a[0] == b[0]) return a[1] < b[1];\n        return a[0] > b[0];\n    }\n    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {\n        sort(people.begin(),people.end(),mycomp);\n        vector<vector<int> > ret;\n        for(auto it: people ){\n            ret.insert(ret.begin() + it[1],it);\n        }\n        return ret;\n    }\n};", "compare_result": "1111111111111111111111111111111111111"}, {"id": 280568082, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574321888, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/280568082/", "is_pending": "Not Pending", "title": "Largest Values From Labels", "memory": "N/A", "code": "class Solution {\npublic:\n    int largestValsFromLabels(vector<int>& values, vector<int>& labels, int num_wanted, int use_limit) {\n        map<int,int> table;\n        for(int i =0; i < values.size();i ++){\n            table[values[i]] = labels[i];\n        }\n        \n        sort(values.begin(),values.end());\n        int sum = 0;\n        int take = 0;\n        map<int,int> lmp ;\n        for(int i = values.size()-1;i >=0;i --){\n            if(take >= num_wanted){\n                break;\n            }\n            if(lmp[table[values[i]]] < use_limit){\n                sum += values[i];\n                lmp[table[values[i]]] ++;\n                take ++;\n            }\n        }\n        return sum;\n    }\n};", "compare_result": "111111111101111111111011111111111111110011011110101111011101111101011111110101100"}, {"id": 280566226, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574321353, "status_display": "Accepted", "runtime": "112 ms", "url": "/submissions/detail/280566226/", "is_pending": "Not Pending", "title": "Previous Permutation With One Swap", "memory": "12.7 MB", "code": "class Solution {\npublic:\n    vector<int> prevPermOpt1(vector<int>& A) {\n        //find largest A[i] < A[i+1]\n        if(A.size() <= 1) return A;\n        int idx = -1;\n        \n        for(int i = A.size()-1; i >  0;i --){\n            if(A[i] < A[i-1]){\n                idx = i-1;\n                break;\n            }\n        }\n        if(idx == -1) return A;\n        \n        for(int i = A.size()-1;i > idx;i --){\n            if(A[i] < A[idx] && A[i] != A[i-1]){\n                swap(A[i],A[idx]);\n                break;\n            }\n        }\n        return A;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111"}, {"id": 280563838, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574320757, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/280563838/", "is_pending": "Not Pending", "title": "Previous Permutation With One Swap", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<int> prevPermOpt1(vector<int>& A) {\n        map<int,int> table;\n        for(int i =0;i < A.size();i ++){\n            if(table[A[i]] <= 0 ){\n                table[A[i]] = i +1;\n            }\n        }\n        for(int i = A.size()-1; i >= 0;i --){\n            auto it = table.upper_bound(A[i]);\n            if( it != table.end() && i > (it->second-1)){\n                swap(A[i],A[it->second-1]);\n                break;\n            }\n        }\n        return A;\n    }\n};", "compare_result": "1110101010000000000000000000000000000000000000000000"}, {"id": 280563653, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574320705, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/280563653/", "is_pending": "Not Pending", "title": "Previous Permutation With One Swap", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<int> prevPermOpt1(vector<int>& A) {\n        map<int,int> table;\n        for(int i =0;i < A.size();i ++){\n            if(table[A[i]] <= 0 ){\n                table[A[i]] = i +1;\n            }\n        }\n        for(int i = A.size()-1; i >= 0;i --){\n            auto it = table.upper_bound(A[i]);\n            if( it != table.end()){\n                swap(A[i],A[it->second-1]);\n                break;\n            }\n        }\n        return A;\n    }\n};", "compare_result": "1010101010000000000000000000000000000000000000000000"}, {"id": 280559305, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574319591, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/280559305/", "is_pending": "Not Pending", "title": "Reorganize String", "memory": "8.5 MB", "code": "class Solution {\npublic:\n    string reorganizeString(string S) {\n        vector<int> hash(26,0);\n        for(char c:S){\n            hash[c-'a'] ++;\n        }\n        int imx = 0;\n        int letter = 0;\n        for(int i = 0;i < 26;i ++){\n            if(imx < hash[i]){\n                imx = hash[i];\n                letter= i;\n            }\n        }\n        \n        if(imx > (S.size()+1)/2) {\n            return \"\";\n        }\n        string rets(S.size(),' ');\n        int idx = 0;\n        while(hash[letter] >0){\n            rets[idx] = letter + 'a';\n            hash[letter] --;\n            idx += 2;\n        }\n        \n        for(int i = 0;i < 26;i ++){\n            while(hash[i] > 0){\n                if(idx >= S.size()){\n                    idx = 1;\n                }\n                rets[idx] = i + 'a';\n                idx += 2;\n                hash[i]--;\n            }\n        }\n        return rets;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111"}, {"id": 280556531, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574318886, "status_display": "Accepted", "runtime": "124 ms", "url": "/submissions/detail/280556531/", "is_pending": "Not Pending", "title": "Boats to Save People", "memory": "13.7 MB", "code": "class Solution {\npublic:\n    int numRescueBoats(vector<int>& people, int limit) {\n        sort(people.begin(),people.end());\n        int ans = 0;\n        for(int hi = people.size()-1,lo = 0; hi >= lo; hi--,ans ++){\n            if(people[hi] + people[lo] <= limit) {\n                lo ++;\n            }\n        }\n        return ans;\n        // map<int,int> table;\n        // for(int i : people){\n        //     table[i] ++;\n        // }\n        // int count = 0;\n        // while(table.size() > 0){\n        //     int sum = table.rbegin()->first;\n        //     table[sum] --;\n        //     if(table[sum] ==0){\n        //         table.erase(sum);\n        //     }\n        //     count ++;\n        //     while(table.size() > 0){\n        //         int x = table.begin()->first;\n        //         if(x+sum <= limit){\n        //             sum += x;\n        //             table[x] --;\n        //             if(table[x] == 0){\n        //                 table.erase(x);\n        //             }\n        //         }else{\n        //             break;\n        //         }\n        //     }\n        // }\n        // return count;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 280555429, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574318612, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/280555429/", "is_pending": "Not Pending", "title": "Boats to Save People", "memory": "N/A", "code": "class Solution {\npublic:\n    int numRescueBoats(vector<int>& people, int limit) {\n        // sort(people.begin(),people.end());\n        map<int,int> table;\n        for(int i : people){\n            table[i] ++;\n        }\n        int count = 0;\n        while(table.size() > 0){\n            int sum = table.rbegin()->first;\n            table[sum] --;\n            if(table[sum] ==0){\n                table.erase(sum);\n            }\n            count ++;\n            while(table.size() > 0){\n                int x = table.begin()->first;\n                if(x+sum <= limit){\n                    sum += x;\n                    table[x] --;\n                    if(table[x] == 0){\n                        table.erase(x);\n                    }\n                }else{\n                    break;\n                }\n            }\n        }\n        return count;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111110111110111101111110011111110111111"}, {"id": 280554846, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574318460, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/280554846/", "is_pending": "Not Pending", "title": "Boats to Save People", "memory": "N/A", "code": "class Solution {\npublic:\n    int numRescueBoats(vector<int>& people, int limit) {\n        // sort(people.begin(),people.end());\n        map<int,int> table;\n        for(int i : people){\n            table[i] ++;\n        }\n        int count = 0;\n        while(table.size() > 0){\n            int sum = table.rbegin()->first;\n            table[sum] --;\n            if(table[sum] ==0){\n                table.erase(sum);\n            }\n            while(table.size() > 0){\n                int x = table.begin()->first;\n                if(x+sum < limit){\n                    sum += x;\n                    table[x] --;\n                    if(table[x] == 0){\n                        table.erase(x);\n                    }\n                }else{\n                    count ++;\n                    // sum = 0;\n                    break;\n                }\n                \n            }\n        }\n        return count;\n    }\n};", "compare_result": "11000000000000100000000000000000000000000000000000010000000000000000000000100"}, {"id": 280552053, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574317791, "status_display": "Accepted", "runtime": "204 ms", "url": "/submissions/detail/280552053/", "is_pending": "Not Pending", "title": "Advantage Shuffle", "memory": "21.7 MB", "code": "class Solution {\npublic:\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\n        map<int,int> table;\n        for(auto i : A){\n            table[i] ++;\n        }\n        vector<int> res;\n        for(int i : B){\n            auto ti = table.upper_bound(i);\n            int x = (ti == table.end() ? table.begin()->first: ti->first);\n            table[x] --;\n            if(table[x] ==0){\n                table.erase(x);\n            }\n            res.push_back(x);\n        }\n        return res;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 280542111, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574315401, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/280542111/", "is_pending": "Not Pending", "title": "Minimum Swaps to Make Strings Equal", "memory": "8.6 MB", "code": "class Solution {\npublic:\n    int minimumSwap(string s1, string s2) {\n        int x1 = 0,y1 = 0;\n        int x2 = 0,y2 = 0;\n        for(int i = 0;i < s1.size();i ++){\n            if(s1[i] == s2[i]) continue;\n            if(s1[i] == 'x'){\n                x1 ++;\n            }else{\n                y1 ++;\n            }\n            \n            if(s2[i] == 'x'){\n                x2 ++;\n            }else{\n                y2 ++;\n            }\n        }\n        \n        if((x1+x2)%2 != 0 || (y1+y2)%2 != 0) return -1;\n        \n        return (x1/2) + (y1/2) + (x1%2)*2;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 280529875, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574312466, "status_display": "Accepted", "runtime": "24 ms", "url": "/submissions/detail/280529875/", "is_pending": "Not Pending", "title": "Maximum Nesting Depth of Two Valid Parentheses Strings", "memory": "9.4 MB", "code": "class Solution {\npublic:\n    vector<int> maxDepthAfterSplit(string seq) {\n        int level = 0;\n        int index = 0;\n        vector<int> ret;\n        while(index < seq.size()){\n            if(seq[index] == '('){\n                ret.push_back(++level%2);\n            }else{\n                ret.push_back(level--%2);\n            }\n            index ++;\n        }\n        return ret;\n    }\n};", "compare_result": "1111111111111111111111111111111"}, {"id": 280514796, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574308721, "status_display": "Accepted", "runtime": "0 ms", "url": "/submissions/detail/280514796/", "is_pending": "Not Pending", "title": "Score After Flipping Matrix", "memory": "8.6 MB", "code": "class Solution {\npublic:\n    int matrixScore(vector<vector<int>>& A) {\n        if(A.size() <= 0) return 0;\n        int m = A.size();\n        int n = A[0].size();\n        int ret = 0;\n        ret += m * (1 << (n-1));\n        \n        for(int i = 1;i < n;i ++){\n            int one = 0;\n            for(int j = 0; j < m;j ++){\n                if(A[j][i] == A[j][0]){\n                    one ++;\n                }\n            }\n            ret =  ret + (1 << (n-i-1)) * max(one,m-one);\n        }\n        return ret;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 280510512, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574307653, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/280510512/", "is_pending": "Not Pending", "title": "Minimum Add to Make Parentheses Valid", "memory": "8.4 MB", "code": "class Solution {\npublic:\n    int minAddToMakeValid(string S) {\n        int left = 0;\n        int right = 0;\n        int count = 0;\n        for(int i = 0;i < S.size();i ++){\n            if(S[i] == ')'){\n                right ++;\n            }\n            if(S[i] == '('){\n                left ++;\n            }\n            if(right > left){\n                count =count + (right - left);\n                left = right;\n            }\n        }\n        if(left > right){\n            count =  count + left - right;\n        }\n        return count;\n        \n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 280504494, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574306186, "status_display": "Accepted", "runtime": "0 ms", "url": "/submissions/detail/280504494/", "is_pending": "Not Pending", "title": "Broken Calculator", "memory": "8.1 MB", "code": "class Solution {\npublic:\n    int brokenCalc(int X, int Y) {\n        int res = 0;\n        while(Y > X){\n            if(Y %2 == 0){\n                Y = Y/2;\n            }else{\n                Y = Y +1;\n            }\n            res ++;\n        }\n        // cout << X << \" \" << Y << endl;\n        return res + X - Y;\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 280501657, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574305493, "status_display": "Accepted", "runtime": "128 ms", "url": "/submissions/detail/280501657/", "is_pending": "Not Pending", "title": "Split Array into Consecutive Subsequences", "memory": "18.2 MB", "code": "class Solution {\npublic:\n    bool isPossible(vector<int>& nums) {\n        map<int,int> freq;\n        map<int,int> appendFreq;\n        for(auto it: nums){\n            freq[it] ++;\n        }\n        for(auto it : nums){\n            if(freq[it] == 0){\n                continue;\n            }\n            \n            if(appendFreq[it] > 0 ){\n                appendFreq[it] --;\n                appendFreq[it+1] ++;\n            }else if(freq[it+1] >0 && freq[it+2] > 0){\n                freq[it+1] --;\n                freq[it+2] --;\n                appendFreq[it+3] ++;\n            }else\n            {\n                return false;\n            }\n            freq[it] --;\n        }\n        return true;\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 280497842, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574304532, "status_display": "Accepted", "runtime": "16 ms", "url": "/submissions/detail/280497842/", "is_pending": "Not Pending", "title": "Non-overlapping Intervals", "memory": "11.6 MB", "code": "class Solution {\npublic:\n    static int mycomp(vector<int>&a,vector<int>&b){\n        // if(a[0] == b[0]) return a[1] < b[1];\n        // return a[0] < b[0];\n        return a[1] < b[1];\n    }\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        sort(intervals.begin(),intervals.end(),mycomp);\n        if(intervals.size() <= 0) return 0;\n        int end = intervals[0][1];\n        int count = 1;\n        for(int i = 1;i < intervals.size();i ++){\n            if(intervals[i][0] >= end){\n                // cout << end << endl;\n                end = intervals[i][1];\n                count ++;\n            }\n        }\n        return intervals.size() - count;\n    }\n};", "compare_result": "111111111111111111"}, {"id": 280497517, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574304457, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/280497517/", "is_pending": "Not Pending", "title": "Non-overlapping Intervals", "memory": "N/A", "code": "class Solution {\npublic:\n    static int mycomp(vector<int>&a,vector<int>&b){\n        if(a[0] == b[0]) return a[1] < b[1];\n        return a[0] < b[0];\n    }\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        sort(intervals.begin(),intervals.end(),mycomp);\n        if(intervals.size() <= 0) return 0;\n        int end = intervals[0][1];\n        int count = 1;\n        for(int i = 1;i < intervals.size();i ++){\n            if(intervals[i][0] >= end){\n                // cout << end << endl;\n                end = intervals[i][1];\n                count ++;\n            }\n        }\n        return intervals.size() - count;\n    }\n};", "compare_result": "111111111111111010"}, {"id": 280497428, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574304434, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/280497428/", "is_pending": "Not Pending", "title": "Non-overlapping Intervals", "memory": "N/A", "code": "class Solution {\npublic:\n    static int mycomp(vector<int>&a,vector<int>&b){\n        if(a[0] == b[0]) return a[1] < b[1];\n        return a[0] < b[0];\n    }\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        sort(intervals.begin(),intervals.end(),mycomp);\n        int end = intervals[0][1];\n        int count = 1;\n        for(int i = 1;i < intervals.size();i ++){\n            if(intervals[i][0] >= end){\n                // cout << end << endl;\n                end = intervals[i][1];\n                count ++;\n            }\n        }\n        return intervals.size() - count;\n    }\n};", "compare_result": "111100000000000000"}, {"id": 280493228, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574303398, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/280493228/", "is_pending": "Not Pending", "title": "Bag of Tokens", "memory": "8.6 MB", "code": "class Solution {\npublic:\n    int bagOfTokensScore(vector<int>& tokens, int P) {\n        sort(tokens.begin(),tokens.end());\n        int i = 0;\n        int j = tokens.size()-1;\n        int score = 0;\n        int res = 0;\n        while(i <= j){\n            if(P >= tokens[i]){\n                P -= tokens[i++];\n                score ++;\n                res = max(res,score);\n            }else if (score > 0){\n                score -= 1;\n                P += tokens[j--];\n            }else {\n                break;\n            }\n        }\n        return res;\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 280488790, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574302251, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/280488790/", "is_pending": "Not Pending", "title": "Split Array into Fibonacci Sequence", "memory": "8.6 MB", "code": "class Solution {\npublic:\n    vector<int> splitIntoFibonacci(string S) {\n        vector<int> ret;\n        for(int i =1;i < 12 && i < S.size();i ++){\n            for(int j = 1;j < 12 && j+i<=S.size();j ++){\n                long first = toLong(S.substr(0,i));\n                if(first < -1) break;\n                long second = toLong(S.substr(i,j));\n                if(second < -1) break;\n                // cout << first << \" \" << second << endl;\n                int status = DFS(S,i+j,first,second);\n                if(status > 0){\n                    ret.push_back(first);\n                    ret.push_back(second);\n                    for(int k = 0;k < status;k ++){\n                        long third = first + second;\n                        ret.push_back(third);\n                        first = second;\n                        second = third;\n                    }\n                    return ret;\n                }\n            }\n        }\n        \n        // cout << DFS(S,6,123,456);\n        return ret;\n    }\n    \n    int DFS(string &s,int idx,long first,long second){\n        if(idx >= s.size()) return 0;\n        long third = first + second;\n        if(third > INT_MAX){\n            return -1;\n        }\n        string sthird = toString(third);\n        // cout << third << \" \" << sthird << endl;\n        if(idx + sthird.size() > s.size()) return -1;\n        for(int i = 0; i < sthird.size();i ++){\n            if(sthird[i] != s[idx+i]){\n                return -1;\n            }\n        }\n        int iret =  DFS(s,idx+sthird.size(),second,third);\n        if(iret < 0) return iret;\n        return iret+1;\n    }\n    \n    string toString(long lv){\n        stringstream ss;\n        ss << lv;\n        string ret;\n        ss >> ret;\n        return ret;\n    }\n    \n    long toLong(string s){\n        // cout << \"ss: \" << s << endl;\n        if(s[0] == '0' && s.size() > 1 ) return -1;\n        long ret =0;\n        int tt = 10;\n        for(int i = 0;i < s.size();i ++){\n            ret = ret*tt + (s[i] - '0');\n        }\n        if(ret > INT_MAX) return -1;\n        return ret;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 280476831, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574299008, "status_display": "Accepted", "runtime": "16 ms", "url": "/submissions/detail/280476831/", "is_pending": "Not Pending", "title": "Delete Columns to Make Sorted II", "memory": "9.6 MB", "code": "class Solution {\npublic:\n    int minDeletionSize(vector<string>& A) {\n        int count = 0;\n        int idx = 0;\n        set<int> removes;\n        do{\n            for(auto it : removes){\n                for(auto &letter: A){\n                    //update\n                    letter[it] = 'a';\n                }\n            }\n            removes.clear();\n            // cout << removes.size() << \" ss \" ;\n            for(int i = 0; i < A.size()-1;i ++){\n                if(A[i] > A[i+1]){\n                    for(int k = 0;k < A[i].size();k ++){\n                        if(A[i][k] > A[i+1][k]){\n                            removes.insert(k);\n                            break;\n                        }\n                    }\n                }\n            }\n            count += removes.size();\n            // cout << count  << endl;\n        }while(removes.size() >0);\n        \n        return count;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 280473138, "lang": "cpp", "time": "1\u00a0month, 1\u00a0week", "timestamp": 1574297978, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/280473138/", "is_pending": "Not Pending", "title": "String Without AAA or BBB", "memory": "10.4 MB", "code": "class Solution {\npublic:\n    string strWithout3a3b(int A, int B) {\n        \n        if(A <=B){\n            return genString(A,B,'a','b');\n            \n        }else{\n            return genString(B,A,'b','a');\n        }\n    }\n    \n    string genString(int A,int B,char a,char b){\n        vector<string> sa;\n        vector<string> sb;\n        for(int i = 0;i < A;i ++){\n            sa.push_back(string(1,a));\n            sb.push_back(string(1,b));\n        }\n        int index = A;\n        int idx = 0;\n        if(index < B){\n            index += 1;\n            sb.push_back(string(1,b));\n        }\n        while(index < B){\n            sb[idx].push_back(b);\n            idx +=1;\n            index += 1;\n        }\n        string ret = \"\";\n        for(int i = 0;i < A;i ++){\n            ret = ret + sb[i] + sa[i];\n        }\n        if(A < B){\n            ret += sb[A];\n        }\n        return ret;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 280377358, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574269808, "status_display": "Accepted", "runtime": "32 ms", "url": "/submissions/detail/280377358/", "is_pending": "Not Pending", "title": "Smallest Range II", "memory": "9.7 MB", "code": "class Solution {\npublic:\n    int smallestRangeII(vector<int>& A, int K) {\n        if(A.size() <= 1) return 0;\n        sort(A.begin(),A.end());\n        int sz = A.size();\n        int ret = A[sz-1] - A[0];\n        \n        for(int i = 0,j = i+1;j < sz;i ++ ,j ++){\n            ret = min(ret,max(A[sz-1]-K,A[i]+K) - min(A[0]+K,A[j]-K));\n        }\n        return ret;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 280374916, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574268965, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/280374916/", "is_pending": "Not Pending", "title": "Smallest Range II", "memory": "N/A", "code": "class Solution {\npublic:\n    int smallestRangeII(vector<int>& A, int K) {\n        if(A.size() <= 1) return 0;\n        double avg = 0;\n        int imax1 = INT_MIN;\n        int imin1 = INT_MAX;\n        for(auto it : A){\n            avg += it;\n            imax1 = max(it,imax1);\n            imin1  = min(it,imin1);\n        }\n        avg = avg/A.size();\n        int imax = INT_MIN;\n        int imin = INT_MAX;\n        \n        for(int i = 0;i < A.size();i ++){\n            if(A[i] >= avg){\n                A[i] = A[i] -K;\n            }else{\n                A[i] = A[i] +K;\n            }\n            imax = max(A[i],imax);\n            imin  = min(A[i],imin);\n        }\n        return min(imax -imin,imax1 -imin1);\n        \n    }\n};", "compare_result": "11111111111111111111111101111001111111111111110001111100111110111110"}, {"id": 280374550, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574268843, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/280374550/", "is_pending": "Not Pending", "title": "Smallest Range II", "memory": "N/A", "code": "class Solution {\npublic:\n    int smallestRangeII(vector<int>& A, int K) {\n        if(A.size() <= 1) return 0;\n        double avg = 0;\n        for(auto it : A){\n            avg += it;\n        }\n        avg = avg/A.size();\n        int imax = INT_MIN;\n        int imin = INT_MAX;\n        \n        for(int i = 0;i < A.size();i ++){\n            if(A[i] >= avg){\n                A[i] = A[i] -K;\n            }else{\n                A[i] = A[i] +K;\n            }\n            imax = max(A[i],imax);\n            imin  = min(A[i],imin);\n        }\n        return imax -imin;\n        \n    }\n};", "compare_result": "11110001111110111111001000111001111111111111110000001100000000001100"}, {"id": 280372232, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574268077, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/280372232/", "is_pending": "Not Pending", "title": "Remove K Digits", "memory": "9.3 MB", "code": "class Solution {\npublic:\n    string removeKdigits(string num, int k) {        \n        stack<char> cstk;\n        for(int i = 0;i < num.size();i ++){\n            while(cstk.size() >0 && num[i] < cstk.top() && k >0){\n                cstk.pop();\n                k --;\n            }\n            cstk.push(num[i]);\n        }\n        while(k >0){\n            cstk.pop();\n            k --;\n        }\n        \n        string s = \"\";\n        while(!cstk.empty()){\n            s.push_back(cstk.top());\n            cstk.pop();\n        }\n        // add zero \n        s.push_back('0');\n        while(s.size() >1 && s[s.size()-1] == '0'){\n            s.pop_back();\n        }\n        reverse(s.begin(),s.end());\n        \n        return s;\n    } \n};", "compare_result": "111111111111111111111111111111111"}, {"id": 280372121, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574268042, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/280372121/", "is_pending": "Not Pending", "title": "Remove K Digits", "memory": "9.2 MB", "code": "class Solution {\npublic:\n    string removeKdigits(string num, int k) {        \n        stack<char> cstk;\n        for(int i = 0;i < num.size();i ++){\n            while(cstk.size() >0 && num[i] < cstk.top() && k >0){\n                cstk.pop();\n                k --;\n            }\n            cstk.push(num[i]);\n        }\n        while(k >0){\n            cstk.pop();\n            k --;\n        }\n        \n        string s = \"\";\n        while(!cstk.empty()){\n            s.push_back(cstk.top());\n            cstk.pop();\n        }\n        cout << s << endl;\n        s.push_back('0');\n        while(s.size() >1 && s[s.size()-1] == '0'){\n            s.pop_back();\n        }\n        reverse(s.begin(),s.end());\n        \n        return s;\n    } \n};", "compare_result": "111111111111111111111111111111111"}, {"id": 280371519, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574267843, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/280371519/", "is_pending": "Not Pending", "title": "Remove K Digits", "memory": "N/A", "code": "class Solution {\npublic:\n    string removeKdigits(string num, int k) {        \n        stack<char> cstk;\n        for(int i = 0;i < num.size();i ++){\n            if(cstk.size() >0 && num[i] < cstk.top() && k >0){\n                cstk.pop();\n                k --;\n            }\n            cstk.push(num[i]);\n        }\n        while(k >0){\n            cstk.pop();\n            k --;\n        }\n        \n        string s = \"\";\n        while(!cstk.empty()){\n            s.push_back(cstk.top());\n            cstk.pop();\n        }\n        s.push_back('0');\n        while(s.size() >1 && s[s.size()-1] == '0'){\n            s.pop_back();\n        }\n        reverse(s.begin(),s.end());\n        \n        return s;\n    } \n};", "compare_result": "111111111111111111111001000001100"}, {"id": 280371304, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574267773, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/280371304/", "is_pending": "Not Pending", "title": "Remove K Digits", "memory": "N/A", "code": "class Solution {\npublic:\n    string removeKdigits(string num, int k) {        \n        stack<char> cstk;\n        for(int i = 0;i < num.size();i ++){\n            if(cstk.size() >0 && num[i] < cstk.top() && k >0){\n                cstk.pop();\n                k --;\n            }\n            cstk.push(num[i]);\n        }\n        while(k >0){\n            cstk.pop();\n            k --;\n        }\n        \n        string s = \"\";\n        while(!cstk.empty()){\n            s.push_back(cstk.top());\n            cstk.pop();\n        }\n        cout << s << endl;\n        while(s.size() >1 && s[s.size()-1] == '0'){\n            s.pop_back();\n        }\n        reverse(s.begin(),s.end());\n        \n        return s;\n    } \n};", "compare_result": "110110111111111110110001000001100"}, {"id": 280370837, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574267621, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/280370837/", "is_pending": "Not Pending", "title": "Remove K Digits", "memory": "N/A", "code": "class Solution {\npublic:\n    string removeKdigits(string num, int k) {        \n        stack<char> cstk;\n        for(int i = 0;i < num.size();i ++){\n            if(cstk.size() >0 && num[i] < cstk.top() && k >0){\n                cstk.pop();\n                k --;\n            }\n            cstk.push(num[i]);\n        }\n        while(k >0){\n            cstk.pop();\n            k --;\n        }\n        \n        string s = \"\";\n        while(!cstk.empty()){\n            s.push_back(cstk.top());\n            cstk.pop();\n        }\n        \n        reverse(s.begin(),s.end());\n        while(s.size() >1 && s[0] == '0'){\n            s.pop_back();\n        }\n        return s;\n    } \n};", "compare_result": "100110111111111110110001000001100"}, {"id": 280364067, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574265241, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/280364067/", "is_pending": "Not Pending", "title": "Search in Rotated Sorted Array", "memory": "8.7 MB", "code": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int left = 0;\n        int right = nums.size() -1;\n        while(left <= right){\n            int mid = left + (right-left)/2;\n            if(nums[mid] == target) return mid;\n            \n            //exist rotation mid right\n            if(nums[mid] >= nums[right]){\n                if(target >= nums[left] && target <= nums[mid]){\n                    right = mid-1;\n                }else{\n                    left = mid +1;\n                }\n            }else if (nums[mid] <= nums[left]){ //exist rotation mid left \n                if(target >= nums[mid] && target <= nums[right]){\n                    left = mid +1;\n                }else{\n                    right = mid -1;\n                }\n            }else{ // no rotation\n                if(target < nums[mid]){\n                    right = mid -1;\n                }else{\n                    left = mid +1;\n                }\n            }\n            \n        }\n        return -1;\n    }\n\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 280360944, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574264106, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/280360944/", "is_pending": "Not Pending", "title": "Search in Rotated Sorted Array", "memory": "N/A", "code": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int left = 0;\n        int right = nums.size() -1;\n        while(left <= right){\n            int mid = left + (right-left)/2;\n            if(nums[mid] == target) return mid;\n            if(nums[mid] < target){\n                if(nums[left] < nums[mid]){\n                    right = mid-1;\n                }else{\n                    left = mid+1;\n                } \n            }else{\n                if(nums[right] > nums[mid]){\n                    right = mid-1;\n                }else{\n                    left = mid+1;\n                }\n            }\n        }\n        return -1;\n    }\n\n};", "compare_result": "1111111111111111111110111101111111101100001111011100001100001010110000101111111000111111010010111110101111111111011010011111100110111010111111110001011001111110111011000101000011010010111011110111"}, {"id": 280358465, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574263142, "status_display": "Accepted", "runtime": "52 ms", "url": "/submissions/detail/280358465/", "is_pending": "Not Pending", "title": "Task Scheduler", "memory": "9.7 MB", "code": "class Solution {\npublic:\n    int leastInterval(vector<char>& tasks, int n) {\n        vector<int> counts(26,0);\n        for(char t : tasks){\n            counts[t-'A'] ++;\n        }\n        sort(counts.begin(),counts.end());\n        int i = 25;\n        while(i >=0 && counts[i]==counts[25]){\n            i --;\n        }\n        // cout << i <<\" \" << counts[25]<< endl;\n        int sz = tasks.size();\n        return max(sz,(counts[25]-1)*(n+1)+25-i);\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111"}, {"id": 280358037, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574262982, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/280358037/", "is_pending": "Not Pending", "title": "Task Scheduler", "memory": "N/A", "code": "class Solution {\npublic:\n    int leastInterval(vector<char>& tasks, int n) {\n        vector<int> counts(26,0);\n        for(char t : tasks){\n            counts[t-'A'] ++;\n        }\n        sort(counts.begin(),counts.end());\n        int i = 25;\n        while(i >=0 && counts[i]==counts[25]){\n            i --;\n        }\n        int sz = counts.size();\n        return min(sz,(counts[25]-1)*(n+1)+25-i);\n    }\n};", "compare_result": "1001111111111111100000000000000000000000000000000000000000000000"}, {"id": 280338700, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574253681, "status_display": "Accepted", "runtime": "48 ms", "url": "/submissions/detail/280338700/", "is_pending": "Not Pending", "title": "Course Schedule II", "memory": "19 MB", "code": "class Solution {\npublic:\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n       map<int,set<int> > table1;\n        map<int,set<int> > table2;\n        set<int> orders;\n        for(int i = 0;i < numCourses;i ++){\n            orders.insert(i);\n        }\n        for(int i = 0;i < prerequisites.size();i ++){\n            orders.erase(prerequisites[i][0]);\n            table1[prerequisites[i][0]].insert(prerequisites[i][1]);\n            table2[prerequisites[i][1]].insert(prerequisites[i][0]);\n        }\n        vector<int> ret;\n        while(orders.size() >0){\n            int idx = *orders.begin();\n            orders.erase(idx);\n            ret.push_back(idx);\n            if(table2.find(idx) != table2.end()){\n                for(auto it : table2[idx]){\n                    table1[it].erase(idx);\n                    if(table1[it].size() == 0){\n                        table1.erase(it);\n                        orders.insert(it);\n                    }\n                }\n                table2.erase(idx);\n            }\n        }\n        return table1.size() ==0 ?  ret : vector<int>();\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111"}, {"id": 280338605, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574253628, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/280338605/", "is_pending": "Not Pending", "title": "Course Schedule II", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n       map<int,set<int> > table1;\n        map<int,set<int> > table2;\n        set<int> orders;\n        for(int i = 0;i < numCourses;i ++){\n            orders.insert(i);\n        }\n        for(int i = 0;i < prerequisites.size();i ++){\n            orders.erase(prerequisites[i][0]);\n            table1[prerequisites[i][0]].insert(prerequisites[i][1]);\n            table2[prerequisites[i][1]].insert(prerequisites[i][0]);\n        }\n        vector<int> ret;\n        while(orders.size() >0){\n            int idx = *orders.begin();\n            orders.erase(idx);\n            ret.push_back(idx);\n            if(table2.find(idx) != table2.end()){\n                for(auto it : table2[idx]){\n                    table1[it].erase(idx);\n                    if(table1[it].size() == 0){\n                        table1.erase(it);\n                        orders.insert(it);\n                    }\n                }\n                table2.erase(idx);\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "11111111111111111110010010100111011000101111"}, {"id": 280337912, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574253210, "status_display": "Accepted", "runtime": "52 ms", "url": "/submissions/detail/280337912/", "is_pending": "Not Pending", "title": "Course Schedule", "memory": "18.4 MB", "code": "class Solution {\npublic:\n//     bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n//         vector<int> table(numCourses);\n//         for(int i = 0;i < numCourses;i ++){\n//             table[i] = i;\n//         }\n        \n//         for(auto it :  prerequisites){\n//             if(false == Union(table,it[0],it[1])){\n//                 return false;\n//             }\n//         }\n//         return true;\n//     }\n//     int getFather(vector<int>&table,int tar){\n//         if(table[tar] == tar) return tar;\n//         return table[tar] = getFather(table,table[tar]);\n//     }\n    \n//     bool Union(vector<int> & table,int a,int b){\n//         int pa = getFather(table,a);\n//         int pb = getFather(table,b);\n//         if(pa == pb) return false;\n//         table[pa] = pb;\n//         return true;\n//     }\n    \n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        map<int,set<int> > table1;\n        map<int,set<int> > table2;\n        set<int> orders;\n        for(int i = 0;i < numCourses;i ++){\n            orders.insert(i);\n        }\n        for(int i = 0;i < prerequisites.size();i ++){\n            orders.erase(prerequisites[i][0]);\n            table1[prerequisites[i][0]].insert(prerequisites[i][1]);\n            table2[prerequisites[i][1]].insert(prerequisites[i][0]);\n        }\n        while(orders.size() >0){\n            int idx = *orders.begin();\n            orders.erase(idx);\n            if(table2.find(idx) != table2.end()){\n                for(auto it : table2[idx]){\n                    table1[it].erase(idx);\n                    if(table1[it].size() == 0){\n                        table1.erase(it);\n                        orders.insert(it);\n                    }\n                }\n                table2.erase(idx);\n            }\n        }\n        return table1.size() ==0;\n    }\n};", "compare_result": "111111111111111111111111111111111111111111"}, {"id": 280337806, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574253147, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/280337806/", "is_pending": "Not Pending", "title": "Course Schedule", "memory": "N/A", "code": "class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<int> table(numCourses);\n        for(int i = 0;i < numCourses;i ++){\n            table[i] = i;\n        }\n        \n        for(auto it :  prerequisites){\n            if(false == Union(table,it[0],it[1])){\n                return false;\n            }\n        }\n        return true;\n    }\n    int getFather(vector<int>&table,int tar){\n        if(table[tar] == tar) return tar;\n        return table[tar] = getFather(table,table[tar]);\n    }\n    \n    bool Union(vector<int> & table,int a,int b){\n        int pa = getFather(table,a);\n        int pb = getFather(table,b);\n        if(pa == pb) return false;\n        table[pa] = pb;\n        return true;\n    }\n    \n    // bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n    //     map<int,set<int> > table1;\n    //     map<int,set<int> > table2;\n    //     set<int> orders;\n    //     for(int i = 0;i < numCourses;i ++){\n    //         orders.insert(i);\n    //     }\n    //     for(int i = 0;i < prerequisites.size();i ++){\n    //         orders.erase(prerequisites[i][0]);\n    //         table1[prerequisites[i][0]].insert(prerequisites[i][1]);\n    //         table2[prerequisites[i][1]].insert(prerequisites[i][0]);\n    //     }\n    //     while(orders.size() >0){\n    //         int idx = *orders.begin();\n    //         orders.erase(idx);\n    //         if(table2.find(idx) != table2.end()){\n    //             for(auto it : table2[idx]){\n    //                 table1[it].erase(idx);\n    //                 if(table1[it].size() == 0){\n    //                     table1.erase(it);\n    //                     orders.insert(it);\n    //                 }\n    //             }\n    //             table2.erase(idx);\n    //         }\n    //     }\n    //     return table1.size() ==0;\n    // }\n};", "compare_result": "111111111111101111111111110110110111010011"}, {"id": 280337059, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574252672, "status_display": "Accepted", "runtime": "44 ms", "url": "/submissions/detail/280337059/", "is_pending": "Not Pending", "title": "Course Schedule", "memory": "18.2 MB", "code": "class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        map<int,set<int> > table1;\n        map<int,set<int> > table2;\n        set<int> orders;\n        for(int i = 0;i < numCourses;i ++){\n            orders.insert(i);\n        }\n        for(int i = 0;i < prerequisites.size();i ++){\n            orders.erase(prerequisites[i][0]);\n            table1[prerequisites[i][0]].insert(prerequisites[i][1]);\n            table2[prerequisites[i][1]].insert(prerequisites[i][0]);\n        }\n        while(orders.size() >0){\n            int idx = *orders.begin();\n            orders.erase(idx);\n            if(table2.find(idx) != table2.end()){\n                for(auto it : table2[idx]){\n                    table1[it].erase(idx);\n                    if(table1[it].size() == 0){\n                        table1.erase(it);\n                        orders.insert(it);\n                    }\n                }\n                table2.erase(idx);\n            }\n        }\n        return table1.size() ==0;\n        \n    }\n};", "compare_result": "111111111111111111111111111111111111111111"}, {"id": 280334482, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574251049, "status_display": "Accepted", "runtime": "32 ms", "url": "/submissions/detail/280334482/", "is_pending": "Not Pending", "title": "Range Sum Query - Mutable", "memory": "19 MB", "code": "struct RangeNode{\npublic:\n    int l;\n    int r;\n    int val;\n    RangeNode *left;\n    RangeNode *right;\n    RangeNode():l(0),r(0),val(0),left(NULL),right(NULL){\n        \n    }\n    \n    RangeNode(int _l,int _r):l(_l),r(_r),val(0),left(NULL),right(NULL){\n        \n    }\n};\n\nvoid insert(RangeNode *root,int index,int val){\n    if(root->l == root->r && root->l == index){\n        root->val = val;\n        return;\n    }\n    root->val += val;\n    int mid = root->l + (root->r - root->l)/2;\n    if(index <= mid){\n        if(root->left == NULL){\n            root->left = new RangeNode(root->l,mid);\n        }\n        insert(root->left,index,val);\n    }else{\n        if(root->right == NULL){\n            root->right  = new RangeNode(mid+1,root->r);\n        }\n        insert(root->right,index,val);\n    }\n}\n\nint updateVal(RangeNode *root,int index,int val){\n    if(root->l == root->r && root->l == index){\n        int change = val - root->val;\n        root->val = val;\n        return change;\n    }\n    int change = 0;\n    int mid = root->l + (root->r - root->l)/2;\n    // cout << mid << \" \"<< root->l << \" \" << root->r << endl;\n    if(index <= mid){\n        change = updateVal(root->left,index,val);\n    }else{\n        change = updateVal(root->right,index,val);\n    }\n    root->val += change;\n    return change;\n}\n\nint getRangeSum(RangeNode *root,int start,int end){\n    if(start == root->l && end == root->r){\n        return root->val;\n    }\n    int mid = root->l + (root->r - root->l)/2;\n    if(end <= mid){\n        return getRangeSum(root->left,start,end);\n    }else if(start > mid){\n        return getRangeSum(root->right,start,end);\n    }else{\n        return getRangeSum(root->left,start,mid) + getRangeSum(root->right,mid+1,end);\n    }\n    return 0;\n}\n\n\nclass NumArray {\npublic:\n    vector<int> bit;\n    int sz  = 0;\n    vector<int> _nums;\n    \n    NumArray(vector<int>& nums) {\n        bit.reserve(nums.size()+1);\n        for(int i = 0;i <= nums.size();i ++){\n            bit[i] = 0;\n        }\n        sz = nums.size();\n        _nums.insert(_nums.end(),nums.begin(),nums.end());\n        // root = new RangeNode();\n        // root->r = nums.size()-1;\n        // for(int i = 0;i < nums.size();i ++){\n        //     insert(root,i,nums[i]);\n        // }\n        \n        for(int i = 0;i < nums.size();i ++){\n            init(i,nums[i]);\n        }\n    }\n    \n    int lowbit(int x){\n        return x&(-x);\n    }\n    \n    void init(int index,int val){\n        index ++;\n        while(index <= sz){\n            bit[index] += val;\n            index += lowbit(index);\n        }\n    }\n\n    int getSum(int index){\n        index ++;\n        int sum = 0;\n        while(index > 0){\n            sum += bit[index];\n            index -= lowbit(index);\n        }\n        return sum;\n    }\n    \n    void update(int i, int val) {\n        // updateVal(root,i,val);\n        int diff = val - _nums[i];\n        _nums[i] = val;\n        init(i,diff);\n    }\n    \n    int sumRange(int i, int j) {\n        return getSum(j) - getSum(i-1);\n    }\n};\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray* obj = new NumArray(nums);\n * obj->update(i,val);\n * int param_2 = obj->sumRange(i,j);\n */", "compare_result": "1111111111"}, {"id": 280322640, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574243476, "status_display": "Accepted", "runtime": "40 ms", "url": "/submissions/detail/280322640/", "is_pending": "Not Pending", "title": "Range Sum Query - Mutable", "memory": "33.2 MB", "code": "struct RangeNode{\npublic:\n    int l;\n    int r;\n    int val;\n    RangeNode *left;\n    RangeNode *right;\n    RangeNode():l(0),r(0),val(0),left(NULL),right(NULL){\n        \n    }\n    \n    RangeNode(int _l,int _r):l(_l),r(_r),val(0),left(NULL),right(NULL){\n        \n    }\n};\n\nvoid insert(RangeNode *root,int index,int val){\n    if(root->l == root->r && root->l == index){\n        root->val = val;\n        return;\n    }\n    root->val += val;\n    int mid = root->l + (root->r - root->l)/2;\n    if(index <= mid){\n        if(root->left == NULL){\n            root->left = new RangeNode(root->l,mid);\n        }\n        insert(root->left,index,val);\n    }else{\n        if(root->right == NULL){\n            root->right  = new RangeNode(mid+1,root->r);\n        }\n        insert(root->right,index,val);\n    }\n}\n\nint updateVal(RangeNode *root,int index,int val){\n    if(root->l == root->r && root->l == index){\n        int change = val - root->val;\n        root->val = val;\n        return change;\n    }\n    int change = 0;\n    int mid = root->l + (root->r - root->l)/2;\n    // cout << mid << \" \"<< root->l << \" \" << root->r << endl;\n    if(index <= mid){\n        change = updateVal(root->left,index,val);\n    }else{\n        change = updateVal(root->right,index,val);\n    }\n    root->val += change;\n    return change;\n}\n\nint getRangeSum(RangeNode *root,int start,int end){\n    if(start == root->l && end == root->r){\n        return root->val;\n    }\n    int mid = root->l + (root->r - root->l)/2;\n    if(end <= mid){\n        return getRangeSum(root->left,start,end);\n    }else if(start > mid){\n        return getRangeSum(root->right,start,end);\n    }else{\n        return getRangeSum(root->left,start,mid) + getRangeSum(root->right,mid+1,end);\n    }\n    return 0;\n}\n\n\nclass NumArray {\npublic:\n    RangeNode *root;\n    NumArray(vector<int>& nums) {\n        root = new RangeNode();\n        root->r = nums.size()-1;\n        for(int i = 0;i < nums.size();i ++){\n            insert(root,i,nums[i]);\n        }\n    }\n    \n    void update(int i, int val) {\n        updateVal(root,i,val);\n    }\n    \n    int sumRange(int i, int j) {\n        return getRangeSum(root,i,j);\n    }\n    \n};\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray* obj = new NumArray(nums);\n * obj->update(i,val);\n * int param_2 = obj->sumRange(i,j);\n */", "compare_result": "1111111111"}, {"id": 280309319, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574237910, "status_display": "Accepted", "runtime": "16 ms", "url": "/submissions/detail/280309319/", "is_pending": "Not Pending", "title": "Swap Adjacent in LR String", "memory": "11.2 MB", "code": "class Solution {\npublic:\n    bool canTransform(string start, string end) {\n        vector<pair<char,int> > vs;\n        vector<pair<char,int> > ve;\n        if(start.size() != end.size()) return false;\n        \n        for(int i =0;i < start.size();i ++){\n            if(start[i] == 'L' || start[i] == 'R'){\n                vs.push_back(pair<char,int>(start[i],i));\n            }\n            if(end[i] == 'L' || end[i] == 'R'){\n                ve.push_back(pair<char,int>(end[i],i));\n            }\n        }\n        if(vs.size() != ve.size()) return false;\n        \n        for(int i = 0;i < vs.size();i ++){\n            if(vs[i].first != ve[i].first){\n                return false;\n            }\n            if(vs[i].first == 'L' && vs[i].second < ve[i].second){\n                return false;\n            }\n            if(vs[i].first == 'R' && vs[i].second > ve[i].second){\n                return false;\n            }\n        }\n        \n        return true;\n        \n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 280295718, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574234051, "status_display": "Accepted", "runtime": "36 ms", "url": "/submissions/detail/280295718/", "is_pending": "Not Pending", "title": "Minimum Area Rectangle II", "memory": "20.8 MB", "code": "class Solution {\npublic:\n    double minAreaFreeRect(vector<vector<int>>& points) {\n        map<pair<double,double> ,vector<pair<int,int> > > mps;\n        for(int i = 0;i < points.size();i ++){\n            for(int j = i+1;j < points.size();j ++){\n                double centerx = (points[i][0] + points[j][0])/2.0;\n                double centery = (points[i][1] + points[j][1])/2.0;\n                \n                mps[pair<double,double>(centerx,centery)].push_back(pair<int,int>(i,j));\n                // mps[pair<int,int>(centerx,centery)].push_back(j);\n            }\n        }\n        double maxSz = 0;\n        for(auto it : mps){\n            if(it.second.size() <2){\n                continue;\n            }\n            \n            auto &vec = it.second;\n            for(int i = 0;i < vec.size();i ++){\n                for(int j = i+1;j < vec.size(); j ++){\n                    //\n                    int sz = getSize(vec[i],vec[j],points);\n                    if(sz >  0){\n                        if(maxSz == 0 || maxSz > sz){\n                            // cout << vec[i].first << vec[i].second << ' ' << vec[j].first << vec[j].second << endl;\n                            maxSz = sz;\n                        }\n                        \n                    }\n                }\n            }\n            \n        }\n        return maxSz;\n    }\n    \n    int getSize(pair<int,int> &L1,pair<int,int>&L2,vector<vector<int> >&pts){\n       //check rectangle ?\n        int a = L1.first;\n        int b = L1.second;\n        int c = L2.first;\n        int d = L2.second;\n        \n        if(checkStatus(a,b,c,pts) < 0|| checkStatus(a,b,d,pts) < 0\n           || checkStatus(c,d,b,pts) < 0){\n            return -1;\n        }\n        \n        return checkStatus(a,b,c,pts);\n        \n    }\n    \n    \n    double checkStatus(int a,int b,int c ,vector<vector<int> > &pts){\n        double ab  =  (pts[a][0]-pts[b][0])*1.0  * (pts[a][0]-pts[b][0]) + (pts[a][1]-pts[b][1]) * (pts[a][1]-pts[b][1]);\n        double ac = (pts[a][0]-pts[c][0])*1.0  * (pts[a][0]-pts[c][0]) + (pts[a][1]-pts[c][1]) * (pts[a][1]-pts[c][1]);\n        double bc = (pts[b][0]-pts[c][0])*1.0 * (pts[b][0]-pts[c][0]) + (pts[b][1]-pts[c][1]) * (pts[b][1]-pts[c][1]);\n        \n        \n        if (ac + bc != ab) return -1;\n        return sqrt(ac*bc);\n    }\n    \n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 280295515, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574233999, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/280295515/", "is_pending": "Not Pending", "title": "Minimum Area Rectangle II", "memory": "N/A", "code": "class Solution {\npublic:\n    double minAreaFreeRect(vector<vector<int>>& points) {\n        map<pair<double,double> ,vector<pair<int,int> > > mps;\n        for(int i = 0;i < points.size();i ++){\n            for(int j = i+1;j < points.size();j ++){\n                double centerx = (points[i][0] + points[j][0])/2.0;\n                double centery = (points[i][1] + points[j][1])/2.0;\n                \n                mps[pair<double,double>(centerx,centery)].push_back(pair<int,int>(i,j));\n                // mps[pair<int,int>(centerx,centery)].push_back(j);\n            }\n        }\n        double maxSz = 0;\n        for(auto it : mps){\n            if(it.second.size() <2){\n                continue;\n            }\n            \n            auto &vec = it.second;\n            for(int i = 0;i < vec.size();i ++){\n                for(int j = i+1;j < vec.size(); j ++){\n                    //\n                    int sz = getSize(vec[i],vec[j],points);\n                    if(sz >  0){\n                        if(maxSz == 0 || maxSz > sz){\n                            // cout << vec[i].first << vec[i].second << ' ' << vec[j].first << vec[j].second << endl;\n                            maxSz = sz;\n                        }\n                        \n                    }\n                }\n            }\n            \n        }\n        return maxSz;\n    }\n    \n    int getSize(pair<int,int> &L1,pair<int,int>&L2,vector<vector<int> >&pts){\n       //check rectangle ?\n        int a = L1.first;\n        int b = L1.second;\n        int c = L2.first;\n        int d = L2.second;\n        \n        if(checkStatus(a,b,c,pts) < 0|| checkStatus(a,b,d,pts) < 0\n           || checkStatus(c,d,b,pts) < 0){\n            return -1;\n        }\n        \n        return checkStatus(a,b,c,pts);\n        \n    }\n    \n    \n    double checkStatus(int a,int b,int c ,vector<vector<int> > &pts){\n        int ab  =  (pts[a][0]-pts[b][0]) * (pts[a][0]-pts[b][0]) + (pts[a][1]-pts[b][1]) * (pts[a][1]-pts[b][1]);\n        int ac = (pts[a][0]-pts[c][0]) * (pts[a][0]-pts[c][0]) + (pts[a][1]-pts[c][1]) * (pts[a][1]-pts[c][1]);\n        int bc = (pts[b][0]-pts[c][0]) * (pts[b][0]-pts[c][0]) + (pts[b][1]-pts[c][1]) * (pts[b][1]-pts[c][1]);\n        \n        \n        if (ac + bc != ab) return -1;\n        return sqrt(ac*bc);\n    }\n    \n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111110000000000000000000000000000000000000000"}, {"id": 280254185, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574224672, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/280254185/", "is_pending": "Not Pending", "title": "Binary Search Tree to Greater Sum Tree", "memory": "9 MB", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* bstToGst(TreeNode* root) {\n        int s = 0;\n        getSum(root,s);\n        return root;\n    }\n    \n    void getSum(TreeNode *root,int &cumSum){\n        if(root == NULL) return ;\n        getSum(root->right,cumSum);\n        int tmp = root->val;\n        root->val += cumSum;\n        cumSum += tmp;\n        getSum(root->left,cumSum);\n        return ;\n    }\n};", "compare_result": "1111111111111111111111111111"}, {"id": 280248895, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574223537, "status_display": "Accepted", "runtime": "76 ms", "url": "/submissions/detail/280248895/", "is_pending": "Not Pending", "title": "Implement Rand10() Using Rand7()", "memory": "9.6 MB", "code": "// The rand7() API is already defined for you.\n// int rand7();\n// @return a random integer in the range 1 to 7\n\nclass Solution {\npublic:\n    int rand10() {\n        int tar  = 39;\n        while(tar < 40){\n            tar = (rand7()%7)  * 7 + rand7()%7 +1;\n        }\n        return tar%40+1;\n    }\n};", "compare_result": "1111111111"}, {"id": 280248478, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574223441, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/280248478/", "is_pending": "Not Pending", "title": "Implement Rand10() Using Rand7()", "memory": "N/A", "code": "// The rand7() API is already defined for you.\n// int rand7();\n// @return a random integer in the range 1 to 7\n\nclass Solution {\npublic:\n    int rand10() {\n        int tar  = 39;\n        while(tar < 40){\n            tar = rand7()  * 7 + rand7();\n        }\n        return tar%40+1;\n    }\n};", "compare_result": "0010100000"}, {"id": 280248326, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574223410, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/280248326/", "is_pending": "Not Pending", "title": "Implement Rand10() Using Rand7()", "memory": "N/A", "code": "// The rand7() API is already defined for you.\n// int rand7();\n// @return a random integer in the range 1 to 7\n\nclass Solution {\npublic:\n    int rand10() {\n        int tar  = 41;\n        while(tar < 40){\n            tar = rand7()  * 7 + rand7();\n        }\n        return tar%40+1;\n    }\n};", "compare_result": "1111110000"}, {"id": 280130473, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574180142, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/280130473/", "is_pending": "Not Pending", "title": "Implement Rand10() Using Rand7()", "memory": "N/A", "code": "// The rand7() API is already defined for you.\n// int rand7();\n// @return a random integer in the range 1 to 7\n\nclass Solution {\npublic:\n    int rand10() {\n        int tar = 11;\n        while(tar > 9){\n            tar = rand7()%7;\n            tar += (rand7()%2)*7;\n        }\n        return tar+1;\n    }\n};", "compare_result": "1111111100"}, {"id": 280127322, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574179101, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/280127322/", "is_pending": "Not Pending", "title": "Implement Rand10() Using Rand7()", "memory": "N/A", "code": "// The rand7() API is already defined for you.\n// int rand7();\n// @return a random integer in the range 1 to 7\n\nclass Solution {\npublic:\n    int rand10() {\n        int tar = 11;\n        while(tar > 10){\n            tar = rand7();\n            tar += (rand7()%2)*7;\n        }\n        return tar;\n    }\n};", "compare_result": "1111111100"}, {"id": 280127216, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574179063, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/280127216/", "is_pending": "Not Pending", "title": "Implement Rand10() Using Rand7()", "memory": "N/A", "code": "// The rand7() API is already defined for you.\n// int rand7();\n// @return a random integer in the range 1 to 7\n\nclass Solution {\npublic:\n    int rand10() {\n        int tar = 10;\n        while(tar >= 10){\n            tar = rand7();\n            tar += (rand7()%2)*7;\n        }\n        return tar;\n    }\n};", "compare_result": "1111111000"}, {"id": 280124455, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1574178025, "status_display": "Accepted", "runtime": "176 ms", "url": "/submissions/detail/280124455/", "is_pending": "Not Pending", "title": "Random Pick Index", "memory": "36.9 MB", "code": "class Solution {\npublic:\n    map<int,vector<int>> mps;\n    Solution(vector<int>& nums) {\n        for(int i = 0;i <nums.size();i ++){\n            mps[nums[i]].push_back(i);\n        }\n    }\n    \n    int pick(int target) {\n        vector<int> &vec = mps[target];\n        int idx = rand()%vec.size();\n        return vec[idx];\n    }\n};\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj = new Solution(nums);\n * int param_1 = obj->pick(target);\n */", "compare_result": "1111111111111"}, {"id": 279273503, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1573921763, "status_display": "Accepted", "runtime": "0 ms", "url": "/submissions/detail/279273503/", "is_pending": "Not Pending", "title": "Camelcase Matching", "memory": "8.6 MB", "code": "class Solution {\npublic:\n    vector<bool> camelMatch(vector<string>& queries, string pattern) {\n        vector<bool> status;\n        for(string s : queries){\n            status.push_back(isMatch(s,pattern));\n        }\n        \n        return status;\n    }\n    \n    bool isMatch(string &query,string pattern){\n        int idx = 0;\n        for(char c : query){\n            if(c == pattern[idx]){\n                idx ++;\n            }else if (c < 'a'){\n                return false;\n            }\n        }\n        return idx == pattern.size();\n    }\n};", "compare_result": "111111111111111111111111111111111111"}, {"id": 279256347, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1573916199, "status_display": "Accepted", "runtime": "188 ms", "url": "/submissions/detail/279256347/", "is_pending": "Not Pending", "title": "Smallest String With Swaps", "memory": "50 MB", "code": "class Solution {\npublic:\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\n        vector<int> table(s.size(),0);\n        for(int i = 0; i < s.size(); i ++){\n            table[i] = i;\n        }\n        for(auto pa : pairs){\n            Union(table,pa[0],pa[1]);\n        }\n        map<int,vector<int> > mps;\n        for(int i = 0;i < table.size(); i ++ ){\n            int pa = getParent(table,i);\n            mps[pa].push_back(i);\n        }\n        for(auto it : mps){\n            if(it.second.size() <= 1) continue;\n            vector<char> tmp;\n            for(auto idx : it.second){\n                // cout << s[idx] << \" \";\n                tmp.push_back(s[idx]);\n            }\n            sort(tmp.begin(),tmp.end());\n            sort(it.second.begin(),it.second.end());\n            for(int i = 0; i < tmp.size();i ++){\n                s[it.second[i]] = tmp[i];\n            } \n        }\n        return s;\n   }    \n    int getParent(vector<int> & table,int tar){\n        if(table[tar] == tar){\n            return tar;\n        }\n        return table[tar] = getParent(table,table[tar]);\n    }\n    void Union(vector<int> & table, int a ,int b){\n        int pa = getParent(table,a);\n        int pb = getParent(table,b);\n        table[pa] = pb;\n    }\n};", "compare_result": "111111111111111111111111111111111111"}, {"id": 279235158, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1573904010, "status_display": "Accepted", "runtime": "40 ms", "url": "/submissions/detail/279235158/", "is_pending": "Not Pending", "title": "Number of Islands", "memory": "13 MB", "code": "class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int count = 0;\n        for(int i = 0;i < grid.size();i ++){\n            for(int j = 0;j < grid[0].size();j ++){\n                if(grid[i][j] == '1'){\n                    count ++;\n                    dfs(grid,i,j);\n                    // break;\n                }\n            }\n        }\n        \n        return count;\n    }\n    void dfs(vector<vector<char>>& grid,int x,int y){\n        if(x < 0 || y < 0 || x >= grid.size() ||y >= grid[0].size() || grid[x][y] == '0')\n            return;\n        grid[x][y] = '0';\n        vector<pair<int, int> > steps = { {-1, 0},{1,0},{0,1} ,{0,-1} };\n        for(auto st : steps){\n            dfs(grid,x+st.first,y+st.second);\n        }\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111"}, {"id": 279234395, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1573903493, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/279234395/", "is_pending": "Not Pending", "title": "Satisfiability of Equality Equations", "memory": "9.6 MB", "code": "class Solution {\npublic:\n    bool equationsPossible(vector<string>& equations) {\n        vector<int> table(257,0);\n        for(int i = 0;i < 257;i ++){\n            table[i] = i;\n        }\n        \n        for(string s: equations){\n            int a = s[0];\n            int b = s[3];\n            // cout << (char)a << (char) b << endl;\n            char eq = s[1];\n            if(eq == '='){\n                Union(table,a,b);\n            }\n        }\n        for(string s: equations){\n            int a = s[0];\n            int b = s[3];\n            char eq = s[1];\n            if(eq == '!'){\n                if(getParent(table,a) == getParent(table,b)){\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    int getParent(vector<int> & table,int tar){\n        if(tar == table[tar]){\n            return tar;\n        }\n        return table[tar] = getParent(table,table[tar]);\n    }\n    \n    void Union(vector<int>&table,int a,int b){\n        int pa = getParent(table,a);\n        int pb = getParent(table,b);\n        table[pa] = pb;\n    }\n    \n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 279207149, "lang": "cpp", "time": "1\u00a0month, 2\u00a0weeks", "timestamp": 1573889155, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/279207149/", "is_pending": "Not Pending", "title": "Largest Component Size by Common Factor", "memory": "N/A", "code": "class Solution {\npublic:\n    int largestComponentSize(vector<int>& A) {\n        vector<int> table(A.size(),0);\n        for(int i = 0;i < A.size();i ++){\n            table[i] = i;\n        }\n        for(int i  =0;i < A.size();i ++){\n            for(int j = i+1;j < A.size();j ++){\n                if(gcd(A[i],A[j]) > 1){\n                    Union(table,j,i);\n                }\n            }\n        }\n        map<int,int> mps;\n        int mx = 0;\n        for(int i = 0;i < table.size();i ++){\n            mps[getParent(table,i)] ++;\n            if(mx < mps[getParent(table,i)]){\n                mx  = mps[getParent(table,i)];\n            }\n        }\n        return mx;\n    }\n    \n    int gcd(int a,int b){\n        while(b != 0){\n            int t = b;\n            b = a%b;\n            a = t;\n        }\n        return a;\n    }\n    int getParent(vector<int> & table,int tar){\n        if (tar == table[tar]){\n            return tar;\n        }\n        //compress\n        return table[tar] = getParent(table,table[tar]);\n    }\n    \n    void Union(vector<int> &table,int a,int b){\n        int pa = getParent(table,a);\n        int pb = getParent(table,b);\n        table[pa] = pb;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000"}, {"id": 275138804, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572637551, "status_display": "Accepted", "runtime": "300 ms", "url": "/submissions/detail/275138804/", "is_pending": "Not Pending", "title": "Can I Win", "memory": "27.8 MB", "code": "class Solution {\npublic:\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\n        // return false\n        int status =0;\n        map<int,int> table;\n        if(desiredTotal <= maxChoosableInteger) return true;\n        if(maxChoosableInteger*(maxChoosableInteger+1) < 2*desiredTotal) return false;\n        return dfs(table,status,0,desiredTotal,maxChoosableInteger) == 1;\n    }\n    \n    int dfs(map<int,int> &table,int status,int cur,int tar,int maxChoosableInteger){\n        if(table[status] != 0) return table[status];\n        if(cur >= tar){\n            table[status] = -1;\n            return -1;\n        }\n        \n        for(int i = 0;i <  maxChoosableInteger ;i ++){\n            if((status & (1 << i))  == 0){\n                if(-1 == dfs(table,status|((1 << i)), cur+i+1,tar,maxChoosableInteger)){\n                    table[status] = 1;\n                    return 1;\n                }\n            }\n        }\n        table[status] = -1;\n        return -1;\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111"}, {"id": 275138189, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572637359, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/275138189/", "is_pending": "Not Pending", "title": "Can I Win", "memory": "N/A", "code": "class Solution {\npublic:\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\n        // return false\n        int status =0;\n        map<int,int> table;\n        if(desiredTotal <= maxChoosableInteger) return true;\n        return dfs(table,status,0,desiredTotal,maxChoosableInteger) == 1;\n    }\n    \n    int dfs(map<int,int> &table,int status,int cur,int tar,int maxChoosableInteger){\n        if(table[status] != 0) return table[status];\n        if(cur >= tar){\n            table[status] = -1;\n            return -1;\n        }\n        \n        for(int i = 0;i <  maxChoosableInteger ;i ++){\n            if((status & (1 << i))  == 0){\n                if(-1 == dfs(table,status|((1 << i)), cur+i+1,tar,maxChoosableInteger)){\n                    table[status] = 1;\n                    return 1;\n                }\n            }\n        }\n        table[status] = -1;\n        return -1;\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111011111111"}, {"id": 275137705, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572637226, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/275137705/", "is_pending": "Not Pending", "title": "Can I Win", "memory": "N/A", "code": "class Solution {\npublic:\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\n        // return false\n        int status =0;\n        map<int,int> table;\n        return dfs(table,status,0,desiredTotal,maxChoosableInteger) == 1;\n    }\n    \n    int dfs(map<int,int> &table,int status,int cur,int tar,int maxChoosableInteger){\n        if(table[status] != 0) return table[status];\n        if(cur >= tar){\n            table[status] = -1;\n            return -1;\n        }\n        \n        for(int i = 0;i <  maxChoosableInteger ;i ++){\n            if((status & (1 << i))  == 0){\n                if(-1 == dfs(table,status|((1 << i)), cur+i+1,tar,maxChoosableInteger)){\n                    table[status] = 1;\n                    return 1;\n                }\n            }\n        }\n        table[status] = -1;\n        return -1;\n    }\n};", "compare_result": "101111111111011111111111111111111111111111111011111111"}, {"id": 275130561, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572635119, "status_display": "Accepted", "runtime": "1832 ms", "url": "/submissions/detail/275130561/", "is_pending": "Not Pending", "title": "Continuous Subarray Sum", "memory": "416.6 MB", "code": "class Solution {\npublic:\n    bool checkSubarraySum(vector<int>& nums, int k) {\n        set<int> dp;\n        if (k==0) {\n            int count = 0;\n            for(int j :nums){\n                if(j == 0){\n                    count ++;\n                }else{\n                    count = 0;\n                }\n                if(count >=2) return true;\n            }\n            return false;\n        }\n        dp.insert(nums[0]%k);\n        for(int i = 1;i < nums.size();i ++){\n            set<int> tdp;\n            int t = nums[i];\n            // if(t%k==0) return true;\n            tdp.insert(t%k);\n            for( int j : dp){\n                if((t+j)%k ==0){\n                    return true;\n                }\n                tdp.insert((t+j)%k);\n            }\n            dp = tdp;\n        }\n        return false;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 275129730, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572634887, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/275129730/", "is_pending": "Not Pending", "title": "Continuous Subarray Sum", "memory": "N/A", "code": "class Solution {\npublic:\n    bool checkSubarraySum(vector<int>& nums, int k) {\n        set<int> dp;\n        if (k==0) {\n            set<int> tt;\n            for(int j : nums){\n                tt.insert(j);\n            }\n            if(tt.find(0) == tt.end()) return false;\n            return true;\n        }\n        dp.insert(nums[0]%k);\n        for(int i = 1;i < nums.size();i ++){\n            set<int> tdp;\n            int t = nums[i];\n            if(t%k==0) return true;\n            tdp.insert(t%k);\n            for( int j : dp){\n                if((t+j)%k ==0){\n                    return true;\n                }\n                tdp.insert((t+j)%k);\n            }\n            dp = tdp;\n        }\n        return false;\n    }\n};", "compare_result": "1111101011111111100110001101011111111111111111111111111111111111111111111111111111111111"}, {"id": 275129285, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572634744, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/275129285/", "is_pending": "Not Pending", "title": "Continuous Subarray Sum", "memory": "N/A", "code": "class Solution {\npublic:\n    bool checkSubarraySum(vector<int>& nums, int k) {\n        set<int> dp;\n        if (k==0) return false;\n        dp.insert(nums[0]%k);\n        for(int i = 1;i < nums.size();i ++){\n            set<int> tdp;\n            int t = nums[i];\n            if(t%k==0) return true;\n            tdp.insert(t%k);\n            for( int j : dp){\n                if((t+j)%k ==0){\n                    return true;\n                }\n                tdp.insert((t+j)%k);\n            }\n            dp = tdp;\n        }\n        return false;\n    }\n};", "compare_result": "1111110111111111110100000100011111111111111111111111111111111111111111111111111111111111"}, {"id": 275129143, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572634709, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/275129143/", "is_pending": "Not Pending", "title": "Continuous Subarray Sum", "memory": "N/A", "code": "class Solution {\npublic:\n    bool checkSubarraySum(vector<int>& nums, int k) {\n        set<int> dp;\n        dp.insert(nums[0]%k);\n        for(int i = 1;i < nums.size();i ++){\n            set<int> tdp;\n            int t = nums[i];\n            if(t%k==0) return true;\n            tdp.insert(t%k);\n            for( int j : dp){\n                if((t+j)%k ==0){\n                    return true;\n                }\n                tdp.insert((t+j)%k);\n            }\n            dp = tdp;\n        }\n        return false;\n    }\n};", "compare_result": "1111000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 275125072, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572633530, "status_display": "Accepted", "runtime": "60 ms", "url": "/submissions/detail/275125072/", "is_pending": "Not Pending", "title": "K-Concatenation Maximum Sum", "memory": "14.2 MB", "code": "class Solution {\npublic:\n    const int pd = 1e9 +7;\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\n        long maxSum = 0;\n        long sum  = 0;\n        long cur = 0;\n        for(int i =0;i < arr.size();i ++){\n            sum += arr[i];\n            cur = max((long)arr[i],cur + arr[i]);\n            maxSum = max(maxSum,cur);\n        }\n        if(k < 2) return maxSum%pd;\n        \n        \n        if(sum >0 && k>2){\n            cur = (cur + (k-2) * sum);\n        }\n        long result=0;\n        for(int i =0;i < arr.size();i ++){\n            cur = max((long)arr[i],cur + arr[i]);\n            maxSum = max(maxSum,cur);\n        }\n        return (maxSum )%pd;\n    }\n};", "compare_result": "1111111111111111111111111111111111111"}, {"id": 275124962, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572633496, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/275124962/", "is_pending": "Not Pending", "title": "K-Concatenation Maximum Sum", "memory": "N/A", "code": "class Solution {\npublic:\n    const int pd = 1e9 +7;\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\n        long maxSum = INT_MIN;\n        long sum  = 0;\n        long cur = 0;\n        for(int i =0;i < arr.size();i ++){\n            sum += arr[i];\n            cur = max((long)arr[i],cur + arr[i]);\n            maxSum = max(maxSum,cur);\n        }\n        if(k < 2) return maxSum%pd;\n        \n        \n        if(sum >0 && k>2){\n            cur = (cur + (k-2) * sum);\n        }\n        long result=0;\n        for(int i =0;i < arr.size();i ++){\n            cur = max((long)arr[i],cur + arr[i]);\n            maxSum = max(maxSum,cur);\n        }\n        return (maxSum )%pd;\n    }\n};", "compare_result": "1101111111111111111111111111111111111"}, {"id": 275112161, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572629580, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/275112161/", "is_pending": "Not Pending", "title": "Maximum Product Subarray", "memory": "9.2 MB", "code": "class Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        int imax = nums[0];\n        int imin = nums[0];\n        int ret = imax;\n        for(int i = 1;i <nums.size();i ++){\n            int timax = max(imax*nums[i],imin*nums[i]);\n            timax = max(nums[i],timax);\n            \n            int timin = min(imax*nums[i],imin*nums[i]);\n            timin = min(nums[i],timin);\n            \n            ret = max(timax,ret);\n            \n            imax = timax;\n            imin = timin;\n        }\n        \n        return ret;\n        \n    }\n//     int maxProduct(vector<int>& nums) {\n//         int mx = nums[0];\n//         map<pair<int,int>,int> table;\n//         divideAndConqure(table,nums,0,nums.size()-1,mx);\n//         return mx;\n        \n//     }\n//     int  divideAndConqure(map<pair<int,int>,int> &table,\n//                           vector<int>& nums,int start, int end,int &mx){\n//         if(start == end) {\n//             if (mx < nums[start]){\n//                 mx = nums[start];\n//             }\n//             return nums[start];\n//         }\n//         if(table[pair<int,int>(start,end)] >0){\n//             return table[pair<int,int>(start,end)];\n//         }\n//         int mid = (start+end)/2;\n//         int res = INT_MIN;\n//         res = max(divideAndConqure(table,nums,start,mid,mx),res);\n//         res = max(divideAndConqure(table,nums,mid+1,end,mx),res);\n        \n//         for (int i = mid+1;i <= end;i ++){\n//             for(int j = mid;j >= start; j --){\n//                 int sum = 1;\n//                 for(int k = j;k <= i;k ++){\n//                     sum *= nums[k];\n//                     // if (sum > mx){\n//                     //     mx = sum;\n//                     // }\n//                     res = max(res,sum);\n//                 }\n//             }\n//         }\n//         mx = max(res,mx);\n//         table[pair<int,int>(start,end)] = mx;\n//         return mx;\n        \n//     }\n    \n    \n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 275110302, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572629007, "status_display": "Accepted", "runtime": "224 ms", "url": "/submissions/detail/275110302/", "is_pending": "Not Pending", "title": "Longest Palindromic Substring", "memory": "194.5 MB", "code": "class Solution {\npublic:\n    string longestPalindrome(string s) {\n        int sz = s.size();\n        //dp[i][j] is string[i,j] parlindromic <-1 none\n        //we want max\n        if(s.size() <= 0) return string(\"\");\n        int imax = 1;\n        string sret = string(\"\")+s[0];\n        vector<vector<int> > dp(sz+1,vector<int>(sz+1,-1));\n        for(int i = 0;i < sz;i ++){\n            dp[i][i] = 1;\n        }\n        for( int j = 1;j < sz;j ++){\n            for(int i = j-1;i >=0;i --){\n                if(s[i]==s[j]){\n                    if((i+1) > (j-1)){\n                        dp[i][j] = 2;\n                    }else{\n                        if(dp[i+1][j-1] > 0){\n                            dp[i][j] = dp[i+1][j-1] + 2;\n                        }\n                    }\n                }\n                if(imax < dp[i][j]){\n                    sret = s.substr(i,(j-i+1));\n                    imax = dp[i][j];\n                }\n            }\n        }\n        return sret;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 275110109, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572628941, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/275110109/", "is_pending": "Not Pending", "title": "Longest Palindromic Substring", "memory": "N/A", "code": "class Solution {\npublic:\n    string longestPalindrome(string s) {\n        int sz = s.size();\n        //dp[i][j] is string[i,j] parlindromic <-1 none\n        //we want max\n        if(s.size() <= 0) return string(\"\");\n        int imax = 1;\n        string sret = string(\"\")+s[0];\n        vector<vector<int> > dp(sz+1,vector<int>(sz+1,-1));\n        for(int i = 0;i < sz;i ++){\n            dp[i][i] = 1;\n        }\n        for( int j = 1;j < sz;j ++){\n            for(int i = j-1;i >=0;i --){\n                if(s[i]==s[j]){\n                    if((i+1) > (j-1)){\n                        dp[i][j] = 2;\n                    }else{\n                        if(dp[i+1][j-1] > 0){\n                            dp[i][j] = dp[i+1][j-1] + 2;\n                        }\n                    }\n                }\n                if(imax < dp[i][j]){\n                    sret = s.substr(i,(j-i+1));\n                }\n            }\n        }\n        return sret;\n    }\n};", "compare_result": "1111111111111111011111110111111101111110100000000000000000000010100000000000000100000010111111101111001"}, {"id": 275089487, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572621573, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/275089487/", "is_pending": "Not Pending", "title": "New 21 Game", "memory": "11.5 MB", "code": "class Solution {\npublic:\n    double new21Game(int N, int K, int W) {\n        if(K ==0 || N >= K +W) return 1;\n        vector<double> dp(N+1,0.0);\n        dp[0] = 1;\n        double sumW = 1;\n        double  res = 0.0;\n        for(int i = 1;i <=N;i ++){\n            dp[i] = sumW/W;\n            if(i < K){\n                sumW += dp[i];\n            }else{\n                res += dp[i];\n            }\n            if(i -W >=0){\n                sumW -= dp[i-W];\n            }\n        }\n        return res;\n        \n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 275085702, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572620049, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/275085702/", "is_pending": "Not Pending", "title": "New 21 Game", "memory": "N/A", "code": "class Solution {\npublic:\n    double new21Game(int N, int K, int W) {\n        vector<double> dp(N+1,0.0);\n        double rate = 1.0/W;\n        dp[0] = 1;\n        int midx = 0;\n        double ret = 0.0;\n        for(int i =0;i < K;i ++){\n            vector<double> tdp(N+1,0.0);\n            for(int j = midx;j <=N; j ++){\n                // cout << j << endl;\n                if(dp[j] == 0.0) break;\n                for(int k = 1; k <=W && j+k <= N ;k ++){\n                    tdp[k+j] += dp[j] * rate;\n                }\n                for(int k = K;k <=N;k ++){\n                    ret += tdp[k];\n                    tdp[k] = 0.0;\n                }\n            }\n            dp = tdp;\n            midx ++;\n        }\n        \n        for(int i= midx;i <=N;i ++){\n            ret += dp[i];\n        }\n        return ret;\n        \n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000"}, {"id": 275081651, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572618347, "status_display": "Accepted", "runtime": "60 ms", "url": "/submissions/detail/275081651/", "is_pending": "Not Pending", "title": "Coin Change", "memory": "12.5 MB", "code": "class Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        vector<int> dp(amount +1,-1);\n        dp[0] = 0;\n        sort(coins.begin(),coins.end());\n        \n        for(int i = 1;i <= amount;i ++){\n            for(int j : coins){\n                if(j > i){\n                    break;\n                }\n                if(dp[i-j] >=0 ){\n                    if(dp[i] == -1){\n                        dp[i] = dp[i-j] +1;\n                    }else{\n                        dp[i] = min(dp[i-j]+1,dp[i]);\n                    }\n                }\n            }\n        }\n        \n        return dp[amount];\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 274840770, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572538237, "status_display": "Accepted", "runtime": "56 ms", "url": "/submissions/detail/274840770/", "is_pending": "Not Pending", "title": "Out of Boundary Paths", "memory": "13.8 MB", "code": "class Solution {\n    \npublic:\n    const int pd = 1e9+7;\n    int findPaths(int m, int n, int N, int i, int j) {\n        map<pair<int,int>,int > mp;\n        mp[pair<int,int>(i,j)] = 1;\n        int ret = 0;\n        for(int i = 0;i <  N;i ++){\n            map<pair<int,int>,int > tmp;\n            for(auto it: mp){\n                //up \n                if ((it.first.first -1) < 0){\n                    ret = (ret + it.second) %pd;\n                }else{\n                    tmp[pair<int,int>(it.first.first -1,it.first.second)] = (tmp[pair<int,int>(it.first.first -1,it.first.second)] + it.second)%pd;\n                }\n                // down\n                 if ((it.first.first +1) >= m){\n                    ret = (ret + it.second) %pd;\n                }else{\n                    tmp[pair<int,int>(it.first.first +1,it.first.second)] = (tmp[pair<int,int>(it.first.first +1,it.first.second)] + it.second)%pd;\n                }\n                \n                //left\n                if ((it.first.second -1) < 0){\n                    ret = (ret + it.second) %pd;\n                }else{\n                    tmp[pair<int,int>(it.first.first ,it.first.second-1)] = (tmp[pair<int,int>(it.first.first ,it.first.second-1)] + it.second)%pd;\n                }\n                 //right\n                if ((it.first.second +1)  >= n){\n                    ret = (ret + it.second) %pd;\n                }else{\n                    tmp[pair<int,int>(it.first.first ,it.first.second+1)] = (tmp[pair<int,int>(it.first.first ,it.first.second+1)] + it.second)%pd;\n                }\n            }\n            mp = tmp;\n        }\n        return ret;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 274832319, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572535444, "status_display": "Accepted", "runtime": "656 ms", "url": "/submissions/detail/274832319/", "is_pending": "Not Pending", "title": "3Sum", "memory": "43.8 MB", "code": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        unordered_map<int,int>  mp;\n        int imin = INT_MAX;\n        int imax = INT_MIN;\n        for(int i:nums){\n            mp[-i] ++;\n            imin = min(i,imin);\n            imax = max(i,imax);\n        }\n        set<vector<int> > res;\n        sort(nums.begin(),nums.end());\n        for(int i = 0; i < nums.size(); i ++){\n            for(int j = i+1;j < nums.size();){\n                mp[-nums[i]]--;\n                mp[-nums[j]]--;\n                if(mp[nums[i] + nums[j]] >0){\n                    vector<int> re;\n                    re.push_back(nums[i]);\n                    re.push_back(nums[j]);\n                    re.push_back(-nums[i]-nums[j]);\n                    sort(re.begin(),re.end());\n                    res.insert(re);\n                    while(j < (nums.size()-1) && nums[j] == nums[j+1]) j ++;\n                }\n                mp[-nums[i]]++;\n                mp[-nums[j]]++;\n                if(nums[i] + nums[j] +imin >0 ||  nums[i] + nums[j] +imax <0){\n                    break;\n                }\n                j ++;\n                \n            }\n        }\n        \n        return vector<vector<int>>(res.begin(),res.end());\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 274831588, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572535196, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/274831588/", "is_pending": "Not Pending", "title": "3Sum", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        unordered_map<int,int>  mp;\n        int imin = INT_MAX;\n        int imax = INT_MIN;\n        for(int i:nums){\n            mp[-i] ++;\n            imin = min(i,imin);\n            imax = max(i,imax);\n        }\n        set<vector<int> > res;\n        sort(nums.begin(),nums.end());\n        for(int i = 0; i < nums.size(); i ++){\n            for(int j = i+1;j < nums.size();j ++){\n                mp[-nums[i]]--;\n                mp[-nums[j]]--;\n                if(mp[nums[i] + nums[j]] >0){\n                    vector<int> re;\n                    re.push_back(nums[i]);\n                    re.push_back(nums[j]);\n                    re.push_back(-nums[i]-nums[j]);\n                    sort(re.begin(),re.end());\n                    res.insert(re);\n                }\n                mp[-nums[i]]++;\n                mp[-nums[j]]++;\n                if(nums[i] + nums[j] +imin >0 ||  nums[i] + nums[j] +imax <0){\n                    break;\n                }\n                \n            }\n        }\n        \n        return vector<vector<int>>(res.begin(),res.end());\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110"}, {"id": 274830880, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572534957, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/274830880/", "is_pending": "Not Pending", "title": "3Sum", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        unordered_map<int,int>  mp;\n        for(int i:nums){\n            mp[-i] ++;\n        }\n        set<vector<int> > res;\n        sort(nums.begin(),nums.end());\n        for(int i = 0; i < nums.size(); i ++){\n            for(int j = i+1;j < nums.size();j ++){\n                mp[-nums[i]]--;\n                mp[-nums[j]]--;\n                if(mp[nums[i] + nums[j]] >0){\n                    vector<int> re;\n                    re.push_back(nums[i]);\n                    re.push_back(nums[j]);\n                    re.push_back(-nums[i]-nums[j]);\n                    sort(re.begin(),re.end());\n                    res.insert(re);\n                }\n                 mp[-nums[i]]++;\n                mp[-nums[j]]++;\n            }\n        }\n        \n        return vector<vector<int>>(res.begin(),res.end());\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100"}, {"id": 274567774, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572454912, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/274567774/", "is_pending": "Not Pending", "title": "Unique Paths II", "memory": "9.4 MB", "code": "class Solution {\npublic:\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        vector<vector<long> > dp(obstacleGrid.size(),\n                                 vector<long>(obstacleGrid[0].size(),0));\n        dp[0][0] = obstacleGrid[0][0] ==  1? 0:1;\n        for(int i = 1;i < obstacleGrid.size();i ++){\n            if(obstacleGrid[i][0] == 1){\n                dp[i][0] = 0;\n            }else{\n                dp[i][0] =  dp[i-1][0];\n            }\n        }\n        \n        for(int i = 1;i < obstacleGrid[0].size();i ++){\n            if(obstacleGrid[0][i] == 1){\n                dp[0][i] = 0;\n            }else{\n                dp[0][i] =  dp[0][i-1];\n            }\n        }\n        \n        for(int i = 1;i < obstacleGrid.size();i ++){\n            for(int j = 1;j <obstacleGrid[0].size();j ++){\n                if(obstacleGrid[i][j] == 1){\n                    dp[i][j] = 0;\n                }else{\n                    dp[i][j] = 0;\n                    if(dp[i-1][j] > 0 ){\n                        dp[i][j] += dp[i-1][j];\n                    }\n                    \n                    if(dp[i][j-1] > 0){\n                        dp[i][j] += dp[i][j-1];\n                    }\n                }\n            }\n        }\n        return dp[obstacleGrid.size()-1][obstacleGrid[0].size()-1];\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111"}, {"id": 274567583, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572454850, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/274567583/", "is_pending": "Not Pending", "title": "Unique Paths II", "memory": "N/A", "code": "class Solution {\npublic:\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        vector<vector<int> > dp(obstacleGrid.size(),vector<int>(obstacleGrid[0].size(),0));\n        dp[0][0] = obstacleGrid[0][0] ==  1? 0:1;\n        for(int i = 1;i < obstacleGrid.size();i ++){\n            if(obstacleGrid[i][0] == 1){\n                dp[i][0] = 0;\n            }else{\n                dp[i][0] =  dp[i-1][0];\n            }\n        }\n        \n        for(int i = 1;i < obstacleGrid[0].size();i ++){\n            if(obstacleGrid[0][i] == 1){\n                dp[0][i] = 0;\n            }else{\n                dp[0][i] =  dp[0][i-1];\n            }\n        }\n        \n        for(int i = 1;i < obstacleGrid.size();i ++){\n            for(int j = 1;j <obstacleGrid[0].size();j ++){\n                if(obstacleGrid[i][j] == 1){\n                    dp[i][j] = 0;\n                }else{\n                    dp[i][j] = 0;\n                    if(dp[i-1][j] > 0 ){\n                        dp[i][j] += dp[i-1][j];\n                    }\n                    \n                    if(dp[i][j-1] > 0){\n                        dp[i][j] += dp[i][j-1];\n                    }\n                }\n            }\n        }\n        return dp[obstacleGrid.size()-1][obstacleGrid[0].size()-1];\n    }\n};", "compare_result": "1111111111111111111111111110000000000000000"}, {"id": 274564889, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572454055, "status_display": "Accepted", "runtime": "40 ms", "url": "/submissions/detail/274564889/", "is_pending": "Not Pending", "title": "Maximum Subarray Sum with One Deletion", "memory": "15.1 MB", "code": "class Solution {\npublic:\n    int maximumSum(vector<int>& arr) {\n        \n        vector<int> left  = arr ;\n        vector<int> right = arr;\n        int cur = arr[0];\n        int allMax = arr[0];\n        int sz = arr.size();\n        for(int i = 1;i < sz;i ++){\n            left[i] = max(left[i],cur+left[i]);\n            allMax = max(allMax,left[i]);\n            cur = left[i];\n        }\n        \n        cur = arr[sz-1];\n        \n        for(int i = sz -2;i  >=0 ;i --){\n            right[i] = max(right[i],cur+right[i]);\n            allMax = max(allMax,right[i]);\n            cur = right[i];\n        }\n        // cout << left[5] << ' ' << right[7] << endl;\n        for(int i = 1;i <= sz-2;i ++){\n            allMax = max(allMax,left[i-1] + right[i+1]);\n        }\n        return allMax;\n    }\n};", "compare_result": "11111111111111111111111111111111"}, {"id": 274564417, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572453918, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/274564417/", "is_pending": "Not Pending", "title": "Maximum Subarray Sum with One Deletion", "memory": "N/A", "code": "class Solution {\npublic:\n    int maximumSum(vector<int>& arr) {\n        \n        vector<int> left  = arr ;\n        vector<int> right = arr;\n        int cur = arr[0];\n        int allMax = arr[0];\n        int sz = arr.size();\n        for(int i = 1;i < sz;i ++){\n            left[i] = max(left[i],cur+left[i]);\n            allMax = max(allMax,left[i]);\n            cur = left[i];\n        }\n        \n        cur = arr[sz-1];\n        \n        for(int i = sz -2;i  >=0 ;i --){\n            right[i] = max(right[i],cur+right[i]);\n            allMax = max(allMax,right[i]);\n            cur = right[i];\n        }\n        \n        for(int i = 1;i < sz-2;i ++){\n            allMax = max(allMax,left[i-1] + right[i+1]);\n        }\n        return allMax;\n    }\n};", "compare_result": "11111110111111111111111111111111"}, {"id": 274563813, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572453721, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/274563813/", "is_pending": "Not Pending", "title": "Maximum Subarray Sum with One Deletion", "memory": "N/A", "code": "class Solution {\npublic:\n    int maximumSum(vector<int>& arr) {\n        vector<int> sumf;\n        int sum = 0;\n        vector<int> left  = arr ;\n        vector<int> right = arr;\n        int cur = arr[0];\n        int allMax = INT_MIN;\n        for(int i = 1;i < arr.size();i ++){\n            left[i] = max(left[i],cur+left[i]);\n            allMax = max(allMax,left[i]);\n            cur = left[i];\n        }\n        \n        cur = arr[arr.size()-1];\n        for(int i = arr.size()-2;i  >=0 ;i --){\n            right[i] = max(right[i],cur+right[i]);\n            allMax = max(allMax,right[i]);\n            cur = right[i];\n        }\n        for(int i = 1;i < arr.size()-2;i ++){\n            allMax = max(allMax,left[i-1] + right[i+1]);\n        }\n        return allMax;\n    }\n};", "compare_result": "11111100000000000000000000000000"}, {"id": 274557103, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572451645, "status_display": "Accepted", "runtime": "28 ms", "url": "/submissions/detail/274557103/", "is_pending": "Not Pending", "title": "Maximal Square", "memory": "12.4 MB", "code": "class Solution {\npublic:\n    int maximalSquare(vector<vector<char>>& matrix) {\n        if(matrix.size() <= 0) return 0;\n        vector<vector<int>> rows;\n        vector<vector<int>> columns;\n        \n        for(int i = 0;i < matrix.size();i ++){\n            rows.push_back(getRowConsecutive(matrix,i));\n        }\n        \n        for(int i = 0;i < matrix[0].size();i ++){\n            columns.push_back(getColumnConsecutive(matrix,i));\n        }\n        int retMax = 0;\n        vector<vector<int>>dp(matrix.size(),vector<int>(matrix[0].size(),0));\n        for(int i = 0;i < matrix.size();i ++){\n            dp[i][0] = (matrix[i][0] == '1');\n            retMax = max(dp[i][0],retMax);\n        }\n        for(int i = 0;i < matrix[0].size();i ++){\n            dp[0][i] = (matrix[0][i] == '1');\n            retMax = max(dp[0][i],retMax);\n        }\n        \n        for(int i = 1; i < matrix.size();i ++){\n            for(int j = 1;j < matrix[0].size();j ++){\n                if(matrix[i][j] == '1'){\n                    if(dp[i-1][j-1] > 0){\n                        int sz = min(min(dp[i-1][j-1] +1,i+1),j+1);\n                        for( int k = sz;k >=1;k --){\n                            int msz = min(min(min(min(k,rows[i-k+1][j]),\n                                              rows[i][j]),columns[j][i]),columns[j-k+1][i]);\n                            // if(i == 2 && j == 3){\n                            //     cout << '\\t' << k <<' ' << msz << '\\t';\n                            // }\n                            if(msz == k){\n                                dp[i][j] = k;\n                                break;\n                            }\n                        }\n                        \n                    }else{\n                        dp[i][j] = 1;\n                    }\n                    retMax = max(retMax,dp[i][j]);\n                }else{\n                    dp[i][j] = 0;\n                }\n                cout << dp[i][j] << ' ';\n            }\n            cout << endl;\n        }\n        // cout << rows[2][3] << ' ' << columns[3][2] << rows[1][3] << columns[2][2] ;\n        return retMax*retMax;\n        \n    }\n    \n    vector<int> getColumnConsecutive(vector<vector<char>>& matrix,int idx){\n        vector<int> dp(matrix.size());\n        dp[0] = matrix[0][idx] == '1';\n        for(int i = 1;i < matrix.size();i ++){\n            if(matrix[i][idx] == '1'){\n                dp[i] = dp[i-1] +1;\n            }else{\n                dp[i] = 0;\n            }\n        }\n        return dp;\n    }\n    \n    vector<int> getRowConsecutive(vector<vector<char>>& matrix,int idx){\n        vector<int> dp(matrix[0].size());\n        dp[0] = (matrix[idx][0] == '1');\n        for(int i = 1;i < matrix[0].size();i ++){\n            if(matrix[idx][i] == '1'){\n                dp[i] = dp[i-1] +1;\n            }else{\n                dp[i] = 0;\n            }\n        }\n        return dp;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 274556946, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572451583, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/274556946/", "is_pending": "Not Pending", "title": "Maximal Square", "memory": "N/A", "code": "class Solution {\npublic:\n    int maximalSquare(vector<vector<char>>& matrix) {\n        if(matrix.size() <= 0) return 0;\n        vector<vector<int>> rows;\n        vector<vector<int>> columns;\n        \n        for(int i = 0;i < matrix.size();i ++){\n            rows.push_back(getRowConsecutive(matrix,i));\n        }\n        \n        for(int i = 0;i < matrix[0].size();i ++){\n            columns.push_back(getColumnConsecutive(matrix,i));\n        }\n        \n        vector<vector<int>>dp(matrix.size(),vector<int>(matrix[0].size(),0));\n        for(int i = 0;i < matrix.size();i ++){\n            dp[i][0] = (matrix[i][0] == '1');\n        }\n        for(int i = 0;i < matrix[0].size();i ++){\n            dp[0][i] = (matrix[0][i] == '1');\n        }\n        int retMax = dp[0][0];\n        for(int i = 1; i < matrix.size();i ++){\n            for(int j = 1;j < matrix[0].size();j ++){\n                if(matrix[i][j] == '1'){\n                    if(dp[i-1][j-1] > 0){\n                        int sz = min(min(dp[i-1][j-1] +1,i+1),j+1);\n                        for( int k = sz;k >=1;k --){\n                            int msz = min(min(min(min(k,rows[i-k+1][j]),\n                                              rows[i][j]),columns[j][i]),columns[j-k+1][i]);\n                            // if(i == 2 && j == 3){\n                            //     cout << '\\t' << k <<' ' << msz << '\\t';\n                            // }\n                            if(msz == k){\n                                dp[i][j] = k;\n                                break;\n                            }\n                        }\n                        \n                    }else{\n                        dp[i][j] = 1;\n                    }\n                    retMax = max(retMax,dp[i][j]);\n                }else{\n                    dp[i][j] = 0;\n                }\n                cout << dp[i][j] << ' ';\n            }\n            cout << endl;\n        }\n        // cout << rows[2][3] << ' ' << columns[3][2] << rows[1][3] << columns[2][2] ;\n        return retMax*retMax;\n        \n    }\n    \n    vector<int> getColumnConsecutive(vector<vector<char>>& matrix,int idx){\n        vector<int> dp(matrix.size());\n        dp[0] = matrix[0][idx] == '1';\n        for(int i = 1;i < matrix.size();i ++){\n            if(matrix[i][idx] == '1'){\n                dp[i] = dp[i-1] +1;\n            }else{\n                dp[i] = 0;\n            }\n        }\n        return dp;\n    }\n    \n    vector<int> getRowConsecutive(vector<vector<char>>& matrix,int idx){\n        vector<int> dp(matrix[0].size());\n        dp[0] = (matrix[idx][0] == '1');\n        for(int i = 1;i < matrix[0].size();i ++){\n            if(matrix[idx][i] == '1'){\n                dp[i] = dp[i-1] +1;\n            }else{\n                dp[i] = 0;\n            }\n        }\n        return dp;\n    }\n};", "compare_result": "11111011101111111101111111111111101111111111111111111111111111110111"}, {"id": 274279974, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572370394, "status_display": "Accepted", "runtime": "1548 ms", "url": "/submissions/detail/274279974/", "is_pending": "Not Pending", "title": "Bitwise ORs of Subarrays", "memory": "323.1 MB", "code": "class Solution {\npublic:\n    int subarrayBitwiseORs(vector<int>& A) {\n        vector<unordered_set<int>> dps(A.size(),unordered_set<int>());\n        dps[0].insert(A[0]);\n        unordered_set<int> ret(A.size()*2) ;\n        ret.insert(A[0]);\n        unordered_set<int> last;\n        last.insert(A[0]);\n        for(int i = 1;i < A.size();i ++){\n            unordered_set<int> cur = {A[i]};\n            ret.insert(A[i]);\n            for (int t : last){\n                cur.insert(t | A[i]);\n                ret.insert(t | A[i]);\n            }\n            last = cur;\n        }\n        return ret.size();\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 274277502, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572369713, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/274277502/", "is_pending": "Not Pending", "title": "Bitwise ORs of Subarrays", "memory": "N/A", "code": "class Solution {\npublic:\n    int subarrayBitwiseORs(vector<int>& A) {\n        vector<unordered_set<int>> dps(A.size(),unordered_set<int>());\n        dps[0].insert(A[0]);\n        unordered_set<int> ret(A.size()*2) ;\n        ret.insert(A[0]);\n        for(int i = 1;i < A.size();i ++){\n            int t = A[i];\n            for(int j = i-1;j >=0;j--){\n                ret.insert(t);\n                t = t|A[j];\n            }\n            ret.insert(t);\n        }\n        return ret.size();\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111000000000"}, {"id": 274272558, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572368295, "status_display": "Accepted", "runtime": "12 ms", "url": "/submissions/detail/274272558/", "is_pending": "Not Pending", "title": "Minimum Swaps To Make Sequences Increasing", "memory": "8.9 MB", "code": "class Solution {\npublic:\n    int minSwap(vector<int>& A, vector<int>& B) {\n        int fixState = 0;\n        int swapState = 1;\n        for(int i = 1;i < A.size();i ++){\n            bool allincreasing = (A[i-1] < A[i]) && (B[i-1] < B[i]);\n            bool interchangable = (A[i-1] < B[i]) && (B[i-1] < A[i]);\n            if(allincreasing && interchangable){\n                fixState = min(fixState,swapState);\n                swapState = min(fixState,swapState) +1;\n                \n            }else if (allincreasing){\n                fixState = fixState;\n                swapState = swapState +1;\n            }else if (interchangable){\n                int prevfixState = fixState;\n                fixState = swapState;\n                swapState = prevfixState +1;\n            }\n            // cout << fixState << ' ' << swapState << endl;\n        }\n        \n        return min(fixState,swapState);\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 274257255, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572363908, "status_display": "Accepted", "runtime": "44 ms", "url": "/submissions/detail/274257255/", "is_pending": "Not Pending", "title": "Largest Divisible Subset", "memory": "11.6 MB", "code": "class Solution {\npublic:\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\n        vector<int> ret;\n        if(nums.size() <= 0) return ret;\n        sort(nums.begin(),nums.end());\n        vector<vector<int>> dp(nums.size(),vector<int>());\n        dp[0].push_back(nums[0]);\n        ret = dp[0];\n        for(int i = 1;i < nums.size();i ++){\n            for(int j = 0;j <i;j ++){\n                if(nums[i] % nums[j] == 0 ){\n                    if(dp[i].size() < dp[j].size()){\n                        dp[i] = dp[j];\n                    }\n                }\n            }\n            dp[i].push_back(nums[i]);\n            if(ret.size() <dp[i].size()){\n                ret = dp[i];\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111"}, {"id": 274257191, "lang": "cpp", "time": "2\u00a0months", "timestamp": 1572363888, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/274257191/", "is_pending": "Not Pending", "title": "Largest Divisible Subset", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\n        vector<int> ret;\n        sort(nums.begin(),nums.end());\n        vector<vector<int>> dp(nums.size(),vector<int>());\n        dp[0].push_back(nums[0]);\n        ret = dp[0];\n        for(int i = 1;i < nums.size();i ++){\n            for(int j = 0;j <i;j ++){\n                if(nums[i] % nums[j] == 0 ){\n                    if(dp[i].size() < dp[j].size()){\n                        dp[i] = dp[j];\n                    }\n                }\n            }\n            dp[i].push_back(nums[i]);\n            if(ret.size() <dp[i].size()){\n                ret = dp[i];\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "11100000000000000000000000000000000000000"}, {"id": 273972644, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572282930, "status_display": "Accepted", "runtime": "24 ms", "url": "/submissions/detail/273972644/", "is_pending": "Not Pending", "title": "Range Sum Query 2D - Immutable", "memory": "16.5 MB", "code": "class NumMatrix {\npublic:\n    vector<vector<int>> sums;\n    int maxrow = 0;\n    int maxcol = 0;\n    NumMatrix(vector<vector<int>>& matrix) {\n        int m = matrix.size();\n        maxrow = m-1;\n        int n = 0;\n        if(m >0){\n            n = matrix[0].size();\n        }\n        maxcol = n-1;\n        sums =  vector<vector<int>>(m+1,vector<int>(n+1,0));\n        \n        for(int i = 1;i <= m;i ++){\n            for(int j = 1;j <= n;j ++){\n                sums[i][j] = sums[i][j-1] + sums[i-1][j] - sums[i-1][j-1] + matrix[i-1][j-1];\n                // cout << sums[i][j] << ' ';\n            }\n            // cout << endl;\n        }\n    }\n    \n    int sumRegion(int row1, int col1, int row2, int col2) {\n        if(maxrow <0 || maxcol <0 ) return 0;\n        row1 = min(maxrow,row1) +1;\n        row2 = min(maxrow,row2) +1;\n        col1 = min(maxcol,col1) +1;\n        col2 = min(maxcol,col2) +1;\n        // return sums[1][1];\n        return sums[row2][col2] - sums[row1-1][col2] - sums[row2][col1-1] + sums[row1-1][col1-1] ;\n    }\n};\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * NumMatrix* obj = new NumMatrix(matrix);\n * int param_1 = obj->sumRegion(row1,col1,row2,col2);\n */", "compare_result": "111111111111"}, {"id": 273971696, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572282663, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/273971696/", "is_pending": "Not Pending", "title": "Range Sum Query 2D - Immutable", "memory": "N/A", "code": "class NumMatrix {\npublic:\n    vector<vector<int>> sums;\n    int maxrow ;\n    int maxcol ;\n    NumMatrix(vector<vector<int>>& matrix) {\n        int m = matrix.size();\n        maxrow = m-1;\n        int n = matrix[0].size();\n        maxcol = n-1;\n        sums =  vector<vector<int>>(m+1,vector<int>(n+1,0));\n        for(int i = 1;i <= m;i ++){\n            for(int j = 1;j <= n;j ++){\n                sums[i][j] = sums[i][j-1] + sums[i-1][j] - sums[i-1][j-1] + matrix[i-1][j-1];\n                // cout << sums[i][j] << ' ';\n            }\n            // cout << endl;\n        }\n    }\n    \n    int sumRegion(int row1, int col1, int row2, int col2) {\n        row1 = min(maxrow,row1) +1;\n        row2 = min(maxrow,row2) +1;\n        col1 = min(maxcol,col1) +1;\n        col2 = min(maxcol,col2) +1;\n        // return sums[1][1];\n        return sums[row2][col2] - sums[row1-1][col2] - sums[row2][col1-1] + sums[row1-1][col1-1] ;\n    }\n};\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * NumMatrix* obj = new NumMatrix(matrix);\n * int param_1 = obj->sumRegion(row1,col1,row2,col2);\n */", "compare_result": "100000000000"}, {"id": 273965565, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572280816, "status_display": "Accepted", "runtime": "12 ms", "url": "/submissions/detail/273965565/", "is_pending": "Not Pending", "title": "Unique Substrings in Wraparound String", "memory": "9.5 MB", "code": "class Solution {\npublic:\n    int findSubstringInWraproundString(string p) {\n        int counts[26]= {0};\n        int curlen = 1;\n        for(int i =0;i < p.size();i ++){\n            if (i >0 && ((p[i]-p[i-1] == 1) || (p[i-1]-p[i]) ==25)){\n                curlen ++;\n            }else{\n                curlen = 1;\n            }\n            int idx = p[i] - 'a';\n            counts[idx] = max(counts[idx],curlen);\n        }\n        int sumf = 0;\n        for(int i : counts){\n            sumf += i;\n        }\n        return sumf;\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 273959675, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572279019, "status_display": "Accepted", "runtime": "44 ms", "url": "/submissions/detail/273959675/", "is_pending": "Not Pending", "title": "Number of Longest Increasing Subsequence", "memory": "10.8 MB", "code": "class Solution {\npublic:\n    int findNumberOfLIS(vector<int>& nums) {\n        //dp[i] max increasing integers end with i\n        vector<vector<int>>dp(nums.size(),vector<int>(2,1));\n        if(nums.size() <=0) return 0;\n        int maxlen = 1;\n        int counts = 1;\n        for(int i = 1;i < nums.size();i ++){\n            for(int j = 0;j < i;j ++){\n                if(nums[i] > nums[j]){\n                    if((dp[j][0]+1) > dp[i][0]){\n                        dp[i][0] = dp[j][0]+1;\n                        dp[i][1] = dp[j][1];\n                    }else if((dp[j][0]+1) == dp[i][0]){\n                        dp[i][1] += dp[j][1];\n                    }\n                }\n            }\n            if(maxlen < dp[i][0]  ){\n                maxlen = dp[i][0];\n                counts = dp[i][1];\n            }else if (maxlen == dp[i][0]  ){\n                counts += dp[i][1];\n            }\n        }\n        return counts;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 273959610, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572279002, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273959610/", "is_pending": "Not Pending", "title": "Number of Longest Increasing Subsequence", "memory": "N/A", "code": "class Solution {\npublic:\n    int findNumberOfLIS(vector<int>& nums) {\n        //dp[i] max increasing integers end with i\n        vector<vector<int>>dp(nums.size(),vector<int>(2,1));\n        int maxlen = 1;\n        int counts = 1;\n        for(int i = 1;i < nums.size();i ++){\n            for(int j = 0;j < i;j ++){\n                if(nums[i] > nums[j]){\n                    if((dp[j][0]+1) > dp[i][0]){\n                        dp[i][0] = dp[j][0]+1;\n                        dp[i][1] = dp[j][1];\n                    }else if((dp[j][0]+1) == dp[i][0]){\n                        dp[i][1] += dp[j][1];\n                    }\n                }\n            }\n            if(maxlen < dp[i][0]  ){\n                maxlen = dp[i][0];\n                counts = dp[i][1];\n            }else if (maxlen == dp[i][0]  ){\n                counts += dp[i][1];\n            }\n        }\n        return counts;\n    }\n};", "compare_result": "1110111111111111111111111111111111111111111111111111111111111111111111011111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 273639061, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572183732, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/273639061/", "is_pending": "Not Pending", "title": "Wiggle Subsequence", "memory": "8.9 MB", "code": "class Solution {\npublic:\n    int wiggleMaxLength(vector<int>& nums) {\n        vector<vector<int>>dp(nums.size(),vector<int>(2,1));\n        // dp[0][1] =1 ;\n        // dp[0][0] = 1;\n        if(nums.size() <=0) return 0;\n        for(int i =1;i < nums.size();i ++){\n            for(int j = 0;j <i;j ++){\n                if(nums[i] > nums[j]){\n                    dp[i][0] = max(dp[i][0],dp[j][1]+1);\n                }else if(nums[i]<nums[j]){\n                    dp[i][1] = max(dp[i][1],dp[j][0]+1);\n                }\n            }\n        }\n        return max(dp[nums.size()-1][0],dp[nums.size()-1][1]);\n    }\n};", "compare_result": "111111111111111111111111"}, {"id": 273639014, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572183712, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/273639014/", "is_pending": "Not Pending", "title": "Wiggle Subsequence", "memory": "N/A", "code": "class Solution {\npublic:\n    int wiggleMaxLength(vector<int>& nums) {\n        vector<vector<int>>dp(nums.size(),vector<int>(2,1));\n        // dp[0][1] =1 ;\n        // dp[0][0] = 1;\n        for(int i =1;i < nums.size();i ++){\n            for(int j = 0;j <i;j ++){\n                if(nums[i] > nums[j]){\n                    dp[i][0] = max(dp[i][0],dp[j][1]+1);\n                }else if(nums[i]<nums[j]){\n                    dp[i][1] = max(dp[i][1],dp[j][0]+1);\n                }\n            }\n        }\n        return max(dp[nums.size()-1][0],dp[nums.size()-1][1]);\n    }\n};", "compare_result": "111000000000000000000000"}, {"id": 273636908, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572182616, "status_display": "Accepted", "runtime": "148 ms", "url": "/submissions/detail/273636908/", "is_pending": "Not Pending", "title": "Ugly Number II", "memory": "11.8 MB", "code": "class Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int>dp;\n        dp.push_back(1);\n        vector<long> steps;\n        steps.push_back(2);\n        steps.push_back(3);\n        steps.push_back(5);\n        for(int i = 1;i < n;i ++){\n            int t = dp[i-1];\n            long last = INT_MAX;\n            int start = i-1;\n            for(long &st: steps){\n                for(int j = start;j >=0;j --){\n                    if(st*dp[j] > t){\n                        last = min(last,st*dp[j]);\n                    }else{\n                        start = max(j,0);\n                        break;\n                    }\n                } \n            }\n            dp.push_back(last);\n        }\n        // for(int i : dp){\n        //     cout << i << ' ';\n        // }\n        return dp[n-1];\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 273636685, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572182491, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/273636685/", "is_pending": "Not Pending", "title": "Ugly Number II", "memory": "N/A", "code": "class Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int>dp;\n        dp.push_back(1);\n        vector<int> steps;\n        steps.push_back(2);\n        steps.push_back(3);\n        steps.push_back(5);\n        for(int i = 1;i < n;i ++){\n            int t = dp[i-1];\n            int last = INT_MAX;\n            int start = i-1;\n            for(int st: steps){\n                for(int j = start;j >=0;j --){\n                    if(st*dp[j] > t){\n                        last = min(last,st*dp[j]);\n                    }else{\n                        start = max(j,0);\n                        break;\n                    }\n                } \n            }\n            dp.push_back(last);\n        }\n        // for(int i : dp){\n        //     cout << i << ' ';\n        // }\n        return dp[n-1];\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000"}, {"id": 273634675, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572181354, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/273634675/", "is_pending": "Not Pending", "title": "Maximum Product Subarray", "memory": "N/A", "code": "class Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        int mx = nums[0];\n        map<pair<int,int>,int> table;\n        divideAndConqure(table,nums,0,nums.size()-1,mx);\n        return mx;\n        \n    }\n    int  divideAndConqure(map<pair<int,int>,int> &table,\n                          vector<int>& nums,int start, int end,int &mx){\n        if(start == end) {\n            if (mx < nums[start]){\n                mx = nums[start];\n            }\n            return nums[start];\n        }\n        if(table[pair<int,int>(start,end)] >0){\n            return table[pair<int,int>(start,end)];\n        }\n        int mid = (start+end)/2;\n        int res = INT_MIN;\n        res = max(divideAndConqure(table,nums,start,mid,mx),res);\n        res = max(divideAndConqure(table,nums,mid+1,end,mx),res);\n        \n        for (int i = mid+1;i <= end;i ++){\n            for(int j = mid;j >= start; j --){\n                int sum = 1;\n                for(int k = j;k <= i;k ++){\n                    sum *= nums[k];\n                    // if (sum > mx){\n                    //     mx = sum;\n                    // }\n                    res = max(res,sum);\n                }\n            }\n        }\n        mx = max(res,mx);\n        table[pair<int,int>(start,end)] = mx;\n        return mx;\n        \n    }\n    \n    \n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110"}, {"id": 273633759, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572180806, "status_display": "Accepted", "runtime": "20 ms", "url": "/submissions/detail/273633759/", "is_pending": "Not Pending", "title": "Cheapest Flights Within K Stops", "memory": "10.9 MB", "code": "class Solution {\npublic:\n     const int INF=100000011;\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\n        // vector<vector<vector<int> > > dp(K+1,vector<vector<int> >(n,\n        //                                                         vector<int>(n,100000011)));\n        // map<pair<int,int> ,int> mp;\n        // for(vector<int> vi : flights){\n        //     dp[0][vi[0]][vi[1]] = vi[2];  \n        //     // mp[pair<int,int>(vi[0],vi[1])] = vi[2];\n        // }\n        // for(int m = 1;m <=K;m ++){\n        //     for(int i = 0; i < n;i ++){\n        //         for(int j = 0;j <n;j ++){\n        //             for(int k = 0;k < n;k ++){\n        //                 if(i==j) continue;\n        //                 dp[m][i][j] = min(dp[m-1][i][j],dp[m][i][j]);\n        //                 dp[m][i][j] = min(dp[m][i][j],dp[m-1][i][k]+dp[m-1][k][j]);\n        //             }\n        //         }\n        //     }\n        // }\n        // return dp[K][src][dst] == 100000011 ? -1 :dp[K][src][dst];\n        \n        vector<vector<int>>dp(K+2,vector<int>(n,INF));\n        dp[0][src] = 0;\n        for(int i = 1;i <= K+1 ;i ++){\n                dp[i][src] = 0;\n                for(vector<int> &st: flights){\n                    dp[i][st[1]] = min(dp[i][st[1]],\n                                       dp[i-1][st[0]] + st[2]);\n                }\n            }\n        return dp[K+1][dst] == INF ? -1:dp[K+1][dst] ;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111"}, {"id": 273631882, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572179627, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273631882/", "is_pending": "Not Pending", "title": "Cheapest Flights Within K Stops", "memory": "N/A", "code": "class Solution {\npublic:\n    // static const int MAX=100000011;\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\n        vector<vector<vector<int> > > dp(K+1,vector<vector<int> >(n,\n                                                                vector<int>(n,100000011)));\n        // map<pair<int,int> ,int> mp;\n        for(vector<int> vi : flights){\n            dp[0][vi[0]][vi[1]] = vi[2];  \n            // mp[pair<int,int>(vi[0],vi[1])] = vi[2];\n        }\n        for(int m = 1;m <=K;m ++){\n            for(int i = 0; i < n;i ++){\n                for(int j = 0;j <n;j ++){\n                    for(int k = 0;k < n;k ++){\n                        dp[m][i][j] = min(dp[m-1][i][j],dp[m][i][j]);\n                        dp[m][i][j] = min(dp[m][i][j],dp[m-1][i][k]+dp[m-1][k][j]);\n                    }\n                }\n            }\n        }\n        return dp[K][src][dst] == 100000011 ? -1 :dp[K][src][dst];\n    }\n};", "compare_result": "11111111111011111111111111111111111111111"}, {"id": 273631663, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572179508, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273631663/", "is_pending": "Not Pending", "title": "Cheapest Flights Within K Stops", "memory": "N/A", "code": "class Solution {\npublic:\n    // static const int MAX=100000011;\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\n        vector<vector<vector<int> > > dp(K+1,vector<vector<int> >(n,\n                                                                vector<int>(n,100000011)));\n        // map<pair<int,int> ,int> mp;\n        for(vector<int> vi : flights){\n            dp[0][vi[0]][vi[1]] = vi[2];  \n            // mp[pair<int,int>(vi[0],vi[1])] = vi[2];\n        }\n        for(int m = 1;m <=K;m ++){\n            for(int i = 0; i < n;i ++){\n                for(int j = 0;j <n;j ++){\n                    for(int k = 0;k < n;k ++){\n                        dp[m][i][j] = min(dp[m-1][i][j],dp[m-1][i][k]+dp[m-1][k][j]);\n                    }\n                }\n            }\n        }\n        return dp[K][src][dst] == 100000011 ? -1 :dp[K][src][dst];\n    }\n};", "compare_result": "01101111010000111011001110001010100000001"}, {"id": 273631507, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572179396, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273631507/", "is_pending": "Not Pending", "title": "Cheapest Flights Within K Stops", "memory": "N/A", "code": "class Solution {\npublic:\n    // static const int MAX=100000011;\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\n        vector<vector<vector<int> > > dp(K+1,vector<vector<int> >(n,\n                                                                vector<int>(n,100000011)));\n        // map<pair<int,int> ,int> mp;\n        for(vector<int> vi : flights){\n            dp[0][vi[0]][vi[1]] = vi[2];  \n            // mp[pair<int,int>(vi[0],vi[1])] = vi[2];\n        }\n        for(int m = 1;m <=K;m ++){\n            for(int i = 0; i < n;i ++){\n                for(int j = 0;j <n;j ++){\n                    for(int k = 0;k < n;k ++){\n                        dp[m][i][j] = min(dp[m][i][j],dp[m-1][i][k]+dp[m-1][k][j]);\n                    }\n                }\n            }\n        }\n        return dp[K][src][dst] == 100000011 ? -1 :dp[K][src][dst];\n    }\n};", "compare_result": "11111101011011010000000110001010100000000"}, {"id": 273631453, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572179352, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273631453/", "is_pending": "Not Pending", "title": "Cheapest Flights Within K Stops", "memory": "N/A", "code": "class Solution {\npublic:\n    // static const int MAX=100000011;\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\n        vector<vector<vector<int> > > dp(K+1,vector<vector<int> >(n,\n                                                                vector<int>(n,100000011)));\n        // map<pair<int,int> ,int> mp;\n        for(vector<int> vi : flights){\n            dp[0][vi[0]][vi[1]] = vi[2];  \n            // mp[pair<int,int>(vi[0],vi[1])] = vi[2];\n        }\n        for(int m = 1;m <=K;m ++){\n            for(int i = 0; i < n;i ++){\n                for(int j = 0;j <n;j ++){\n                    for(int k = 0;k < n;k ++){\n                        dp[m][i][j] = min(dp[m][i][j],dp[m-1][i][k]+dp[m-1][k][j]);\n                    }\n                }\n            }\n        }\n        return dp[K][src][dst];\n    }\n};", "compare_result": "11010000001011010000000110000000000000000"}, {"id": 273627316, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572176726, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/273627316/", "is_pending": "Not Pending", "title": "Word Break", "memory": "8.9 MB", "code": "class Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        map<string,int> mp;\n        set<int> steps;\n        for(string st : wordDict){\n            mp[st] ++;\n            steps.insert(st.size());\n            // cout << st.size() << endl;\n        }\n        int n = s.size();\n        vector<int> stps(steps.begin(),steps.end());\n        \n        sort(stps.begin(),stps.end());\n        if(stps.size() == 0 || stps[0] > n) return false;\n        if(s.size() ==0) return true;\n        \n        //dp[i]  can be split end with i;\n        // we want get dp[N]\n        // vector<vector<bool> > dp(n+1,vector<bool>(n+1,false));\n        vector<bool> dp(n+1,false);\n        dp[0] = true;\n        for(int i = 1;i <=n;i ++){\n            for(int j :stps){\n                // cout << i <<' '<< j << endl;\n                if(j > i) break;\n                if( !dp[i-j]) continue;\n                string st = s.substr(i-j,j);\n                if(mp[st] >0){\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[n];\n        \n    }\n};", "compare_result": "111111111111111111111111111111111111"}, {"id": 273627129, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572176585, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273627129/", "is_pending": "Not Pending", "title": "Word Break", "memory": "N/A", "code": "class Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        map<string,int> mp;\n        set<int> steps;\n        for(string st : wordDict){\n            mp[st] ++;\n            steps.insert(st.size());\n            // cout << st.size() << endl;\n        }\n        int n = s.size();\n        vector<int> stps(steps.begin(),steps.end());\n        \n        sort(stps.begin(),stps.end());\n        if(stps.size() == 0 || stps[0] > n) return false;\n        if(s.size() ==0) return true;\n        \n        //dp[i]  can be split end with i;\n        // we want get dp[N]\n        // vector<vector<bool> > dp(n+1,vector<bool>(n+1,false));\n        vector<bool> dp(n+1,false);\n        dp[0] = true;\n        for(int i = 1;i <=n;i ++){\n            for(int j :stps){\n                // cout << i <<' '<< j << endl;\n                if(j > i || !dp[i-j]) break;\n                string st = s.substr(i-j,j);\n                if(mp[st] >0){\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[n];\n        \n    }\n};", "compare_result": "101111111011011111110100010101011111"}, {"id": 273627106, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572176567, "status_display": "Compile Error", "runtime": "N/A", "url": "/submissions/detail/273627106/", "is_pending": "Not Pending", "title": "Word Break", "memory": "N/A", "code": "class Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        map<string,int> mp;\n        set<int> steps;\n        for(string st : wordDict){\n            mp[st] ++;\n            steps.insert(st.size());\n            // cout << st.size() << endl;\n        }\n        int n = s.size();\n        vector<int> stps(steps.begin(),steps.end());\n        \n        sort(stps.begin(),stps.end());\n        if(stps == 0 || stps[0] > n) return false;\n        if(s.size() ==0) return true;\n        \n        //dp[i]  can be split end with i;\n        // we want get dp[N]\n        // vector<vector<bool> > dp(n+1,vector<bool>(n+1,false));\n        vector<bool> dp(n+1,false);\n        dp[0] = true;\n        for(int i = 1;i <=n;i ++){\n            for(int j :stps){\n                // cout << i <<' '<< j << endl;\n                if(j > i || !dp[i-j]) break;\n                string st = s.substr(i-j,j);\n                if(mp[st] >0){\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[n];\n        \n    }\n};", "compare_result": null}, {"id": 273620069, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572172014, "status_display": "Accepted", "runtime": "372 ms", "url": "/submissions/detail/273620069/", "is_pending": "Not Pending", "title": "Longest Arithmetic Subsequence of Given Difference", "memory": "43.9 MB", "code": "class Solution {\npublic:\n    int longestSubsequence(vector<int>& arr, int difference) {\n        // vector<vector<int>>dp(arr.size()+1,vector<int>(arr.size()+1,1));\n        vector<int>dp(arr.size()+1,1);\n        \n        if (arr.size() <= 0) return 0;\n        int ret = 1;\n        if(difference < 0){\n            difference = -difference;\n            for(int i = 0;i<arr.size();i++){\n                arr[i] = -arr[i];\n            }\n        }\n        map<int,vector<int>> mp;\n        for(int i = 0;i < arr.size();i ++){\n            mp[arr[i]].push_back(i+1);\n        }\n        for(int i = 2; i <=arr.size();i ++){\n            \n            for(int j : mp[arr[i-1]-difference]){\n                // if(arr[i-1] - arr[j-1] == difference)\n                if(j < i)\n                {\n                    dp[i] = max(dp[i],dp[j]+1);\n                    ret = max(dp[i],ret);\n                }\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "11111111111111111111111111111111111111"}, {"id": 273619907, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572171906, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273619907/", "is_pending": "Not Pending", "title": "Longest Arithmetic Subsequence of Given Difference", "memory": "N/A", "code": "class Solution {\npublic:\n    int longestSubsequence(vector<int>& arr, int difference) {\n        // vector<vector<int>>dp(arr.size()+1,vector<int>(arr.size()+1,1));\n        vector<int>dp(arr.size()+1,1);\n        \n        if (arr.size() <= 0) return 0;\n        int ret = 1;\n        if(difference < 0){\n            difference = -difference;\n            for(int i = 0;i<arr.size();i++){\n                arr[i] = -arr[i];\n            }\n        }\n        map<int,vector<int>> mp;\n        for(int i = 0;i < arr.size();i ++){\n            mp[arr[i]].push_back(i+1);\n        }\n        for(int i = 2; i <=arr.size();i ++){\n            \n            for(int j : mp[arr[i-1]-difference]){\n                // if(arr[i-1] - arr[j-1] == difference)\n                {\n                    dp[i] = max(dp[i],dp[j]+1);\n                    ret = max(dp[i],ret);\n                }\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "11111100110001111111110111110110111100"}, {"id": 273619404, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572171569, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/273619404/", "is_pending": "Not Pending", "title": "Longest Arithmetic Subsequence of Given Difference", "memory": "N/A", "code": "class Solution {\npublic:\n    int longestSubsequence(vector<int>& arr, int difference) {\n        // vector<vector<int>>dp(arr.size()+1,vector<int>(arr.size()+1,1));\n        vector<int>dp(arr.size()+1,1);\n        \n        if (arr.size() <= 0) return 0;\n        int ret = 1;\n        if(difference < 0){\n            difference = -difference;\n            for(int i = 0;i<arr.size();i++){\n                arr[i] = -arr[i];\n            }\n        }\n        for(int i = 2; i <=arr.size();i ++){\n            for(int j = 1;j <i;j ++){\n                if(arr[i-1] - arr[j-1] == difference){\n                    dp[i] = max(dp[i],dp[j]+1);\n                    ret = max(dp[i],ret);\n                }\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "11111111111111111111111111111111110000"}, {"id": 273616302, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572169596, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/273616302/", "is_pending": "Not Pending", "title": "Numbers With Same Consecutive Differences", "memory": "10.7 MB", "code": "class Solution {\npublic:\n     void helper(vector<int>& result,int N,int last,int cur,int K){\n        if(N <=1){\n            result.push_back(cur);\n            return;\n        }\n         \n        if(last-K >=0){\n             helper(result,N-1,last-K,cur*10+(last-K),K);\n        }\n        if(last+K <=9 && last+K  != last-K){\n            helper(result,N-1,(K+last),cur*10+(K+last),K);\n        }\n    }\n    vector<int> numsSameConsecDiff(int N, int K) {\n        vector<int> result;\n        for(int i = 0;i <=9;i ++){\n            if(N > 1 && i == 0) continue; \n            helper(result,N,i,i,K);\n        }\n        return result;\n    }\n    \n   \n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 273616170, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572169513, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273616170/", "is_pending": "Not Pending", "title": "Numbers With Same Consecutive Differences", "memory": "N/A", "code": "class Solution {\npublic:\n     void helper(vector<int>& result,int N,int last,int cur,int K){\n        if(N <=1){\n            result.push_back(cur);\n            return;\n        }\n         \n        if(last-K >=0){\n             helper(result,N-1,last-K,cur*10+(last-K),K);\n        }\n        if(last+K <=9){\n            helper(result,N-1,(K+last),cur*10+(K+last),K);\n        }\n    }\n    vector<int> numsSameConsecDiff(int N, int K) {\n        vector<int> result;\n        for(int i = 0;i <=9;i ++){\n            if(N > 1 && i == 0) continue; \n            helper(result,N,i,i,K);\n        }\n        return result;\n    }\n    \n   \n};", "compare_result": "11111111111101111111110111111111011111111101111111110111111111011111111101111111110111111111"}, {"id": 273616132, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572169496, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273616132/", "is_pending": "Not Pending", "title": "Numbers With Same Consecutive Differences", "memory": "N/A", "code": "class Solution {\npublic:\n     void helper(vector<int>& result,int N,int last,int cur,int K){\n        if(N <=1){\n            result.push_back(cur);\n            return;\n        }\n         \n        if(last-K >=0){\n             helper(result,N-1,last-K,cur*10+(last-K),K);\n        }\n        if(last+K <=9){\n            helper(result,N-1,(K+last),cur*10+(K+last),K);\n        }\n    }\n    vector<int> numsSameConsecDiff(int N, int K) {\n        vector<int> result;\n        for(int i = 0;i <=9;i ++){\n            if(N > 1) continue; \n            helper(result,N,i,i,K);\n        }\n        return result;\n    }\n    \n   \n};", "compare_result": "00111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 273616005, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572169425, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273616005/", "is_pending": "Not Pending", "title": "Numbers With Same Consecutive Differences", "memory": "N/A", "code": "class Solution {\npublic:\n     void helper(vector<int>& result,int N,int last,int cur,int K){\n        if(N <=1){\n            result.push_back(cur);\n            return;\n        }\n         \n        if(last-K >=0){\n             helper(result,N-1,last-K,cur*10+(last-K),K);\n        }\n        if(last+K <=9){\n            helper(result,N-1,(K+last),cur*10+(K+last),K);\n        }\n    }\n    vector<int> numsSameConsecDiff(int N, int K) {\n        vector<int> result;\n        for(int i = 1;i <=9;i ++){\n            helper(result,N,i,i,K);\n        }\n        return result;\n    }\n    \n   \n};", "compare_result": "11000000000001111111110111111111011111111101111111110111111111011111111101111111110111111111"}, {"id": 273609803, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572166145, "status_display": "Accepted", "runtime": "16 ms", "url": "/submissions/detail/273609803/", "is_pending": "Not Pending", "title": "Soup Servings", "memory": "14.3 MB", "code": "class Solution {\npublic:\n    double soupServings(int N) {\n        map<pair<int,int>,double> table;\n        if (N > 10000) return 1;\n        return helper(table,N,N);\n    }\n    double helper(map<pair<int,int>,double> &table,int a,int b){\n        if(a <=0 || b <=0){\n            if(a==b){\n                return 0.5;\n            }else if (b > a){\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n        if(table[pair<int,int>(a,b)] >0){\n            return table[pair<int,int>(a,b)];\n        }\n        \n        double res =  0.25*(helper(table,a-100,b)\n                            +helper(table,a-75,b-25)\n                            +helper(table,a-50,b-50)\n                           +helper(table,a-25,b-75));\n        table[pair<int,int>(a,b)] = res;\n        return res;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111"}, {"id": 273606287, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572164576, "status_display": "Accepted", "runtime": "1544 ms", "url": "/submissions/detail/273606287/", "is_pending": "Not Pending", "title": "House Robber II", "memory": "518.7 MB", "code": "class Solution {\npublic:\n     int rob(vector<int>& nums) {\n        int sumf = 0;\n        for(int i: nums ){\n            sumf += i;\n        }\n        if(nums.size() <= 0) return 0;\n        vector<vector<vector<int> > > dp(nums.size()+1,\n                                         vector<vector<int>>(sumf+1,vector<int>(2,0)));\n        dp[0][0][0] = 1;\n        dp[1][0][0] = 1;\n        dp[1][0][1] = 1;\n        dp[1][nums[0]][1] = 1;\n        int ret = nums[0];\n        int nsz = nums.size();\n        for(int i = 2;i <= nsz;i ++){\n            int  x = nums[i-1];\n            for(int j = 0;j <=sumf;j ++){\n                if(j >= x && (dp[i-2][j-x][0] + dp[i-2][j-x][1]) >0 \n                   && !(i==nsz && dp[i-2][j-x][0]==0)){\n                     ret = max(ret,j);\n                    intersect(dp[i][j],dp[i-2][j-x]);\n                }\n                if(dp[i-1][j][0] + dp[i-1][j][1]  > 0){\n                    intersect(dp[i][j],dp[i-1][j]);\n                    ret = max(ret,j);\n                }\n            }\n        }\n        return ret;\n    }\n    \n    void intersect(vector<int>&s1,vector<int>&s2){\n        s1[0] = max(s1[0],s2[0]);\n        s1[1] = max(s1[1],s2[1]);\n    }\n    void printSet(set<int>&s){\n        for(int i : s){\n            cout << i << ' ';\n        }\n        cout <<\"####\" << endl;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 273606234, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572164545, "status_display": "Accepted", "runtime": "1480 ms", "url": "/submissions/detail/273606234/", "is_pending": "Not Pending", "title": "House Robber II", "memory": "518.5 MB", "code": "class Solution {\npublic:\n     int rob(vector<int>& nums) {\n        int sumf = 0;\n        for(int i: nums ){\n            sumf += i;\n        }\n        if(nums.size() <= 0) return 0;\n        vector<vector<vector<int> > > dp(nums.size()+1,\n                                         vector<vector<int>>(sumf+1,vector<int>(2,0)));\n        dp[0][0][0] = 1;\n        dp[1][0][0] = 1;\n        dp[1][0][1] = 1;\n        dp[1][nums[0]][1] = 1;\n        int ret = nums[0];\n        int nsz = nums.size();\n        for(int i = 2;i <= nsz;i ++){\n            int  x = nums[i-1];\n            for(int j = 0;j <=sumf;j ++){\n                if(j >= x && (dp[i-2][j-x][0] + dp[i-2][j-x][1]) >0 \n                   && !(i==nsz && dp[i-2][j-x][0]==0)){\n                     ret = max(ret,j);\n                     // if(dp[i][j].size() ==0){\n                     //     dp[i][j] = dp[i-2][j-x];\n                     //     // dp[i][j] = dp[i-2][j-x];\n                     // }else{\n                         intersect(dp[i][j],dp[i-2][j-x]);\n                         // dp[i][j]\n                     // }\n                    // dp[i][j].insert(i);\n                }\n                if(dp[i-1][j][0] + dp[i-1][j][1]  > 0){\n                    // if(dp[i][j].size() > 0){\n                    //     dp[i][j] = intersect(dp[i][j],dp[i-1][j]);\n                    // }else{\n                    //     dp[i][j] = dp[i-1][j];\n                    // }\n                    intersect(dp[i][j],dp[i-1][j]);\n                    ret = max(ret,j);\n                    // dp[i][j].insert(i);\n                }\n            }\n        }\n//         printSet(dp[2][0]);\n//         printSet(dp[3][1]);\n//         printSet(dp[3][3]);\n//         printSet(dp[5][8]);\n//         printSet(dp[8][11]);\n//         printSet(dp[10][16]);\n//         printSet(dp[5][9]);\n//         printSet(dp[1][1]);\n//         printSet(dp[1][1]);\n//         printSet(dp[1][1]);\n        \n        return ret;\n    }\n    \n    void intersect(vector<int>&s1,vector<int>&s2){\n        s1[0] = max(s1[0],s2[0]);\n        s1[1] = max(s1[1],s2[1]);\n    }\n    void printSet(set<int>&s){\n        for(int i : s){\n            cout << i << ' ';\n        }\n        cout <<\"####\" << endl;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 273604563, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572163832, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/273604563/", "is_pending": "Not Pending", "title": "House Robber II", "memory": "N/A", "code": "class Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int sumf = 0;\n        for(int i: nums ){\n            sumf += i;\n        }\n        if(nums.size() <= 0) return 0;\n        vector<vector<set<int> > > dp(nums.size()+1,vector<set<int>>(sumf+1,set<int>()));\n        dp[0][0].insert(0);\n        dp[1][0].insert(0);\n        dp[1][0].insert(1);\n        dp[1][nums[0]].insert(1);\n        int ret = nums[0];\n        int nsz = nums.size();\n        for(int i = 2;i <= nsz;i ++){\n            int  x = nums[i-1];\n            for(int j = 0;j <=sumf;j ++){\n                if(j >= x && dp[i-2][j-x].size() >0 && !(i==nsz && dp[i-2][j-x].find(0) == dp[i-2][j-x].end())){\n                     ret = max(ret,j);\n                     // if(dp[i][j].size() ==0){\n                     //     dp[i][j] = dp[i-2][j-x];\n                     //     // dp[i][j] = dp[i-2][j-x];\n                     // }else{\n                         dp[i][j] = intersect(dp[i][j],dp[i-2][j-x]);\n                         // dp[i][j]\n                     // }\n                    // dp[i][j].insert(i);\n                }\n                if(dp[i-1][j].size() > 0){\n                    // if(dp[i][j].size() > 0){\n                    //     dp[i][j] = intersect(dp[i][j],dp[i-1][j]);\n                    // }else{\n                    //     dp[i][j] = dp[i-1][j];\n                    // }\n                    dp[i][j] = intersect(dp[i][j],dp[i-1][j]);\n                    ret = max(ret,j);\n                    // dp[i][j].insert(i);\n                }\n            }\n        }\n        // printSet(dp[2][0]);\n        // printSet(dp[3][1]);\n        // printSet(dp[3][3]);\n        // printSet(dp[5][8]);\n        // printSet(dp[8][11]);\n        // printSet(dp[10][16]);\n        // printSet(dp[5][9]);\n        // printSet(dp[1][1]);\n        // printSet(dp[1][1]);\n        // printSet(dp[1][1]);\n        \n        return ret;\n    }\n    \n    set<int> intersect(set<int>&s1,set<int>&s2){\n        vector<int> common_data;\n        // set_intersection(s1.begin(),s1.end(),s2.begin(),\n        set_union(s1.begin(),s1.end(),s2.begin(),\n                         s2.end(),back_inserter(common_data));\n        return set<int>(common_data.begin(),common_data.end());\n    }\n    void printSet(set<int>&s){\n        for(int i : s){\n            cout << i << ' ';\n        }\n        cout <<\"####\" << endl;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111000000000"}, {"id": 273602090, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572162816, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273602090/", "is_pending": "Not Pending", "title": "House Robber II", "memory": "N/A", "code": "class Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int sumf = 0;\n        for(int i: nums ){\n            sumf += i;\n        }\n        if(nums.size() <= 0) return 0;\n        vector<vector<set<int> > > dp(nums.size()+1,vector<set<int>>(sumf+1,set<int>()));\n        dp[0][0].insert(0);\n        dp[1][0].insert(0);\n        dp[1][0].insert(1);\n        dp[1][nums[0]].insert(1);\n        int ret = nums[0];\n        int nsz = nums.size();\n        for(int i = 2;i <= nsz;i ++){\n            int  x = nums[i-1];\n            for(int j = 0;j <=sumf;j ++){\n                if(j >= x && dp[i-2][j-x].size() >0 && !(i==nsz && dp[i-2][j-x].find(1) != dp[i-2][j-x].end())){\n                     ret = max(ret,j);\n                     if(dp[i][j].size() ==0){\n                         dp[i][j] = dp[i-2][j-x];\n                         // dp[i][j] = dp[i-2][j-x];\n                     }else{\n                         dp[i][j] = intersect(dp[i][j],dp[i-2][j-x]);\n                         // dp[i][j]\n                     }\n                    dp[i][j].insert(i);\n                }\n                if(dp[i-1][j].size() > 0){\n                    if(dp[i][j].size() > 0){\n                        dp[i][j] = intersect(dp[i][j],dp[i-1][j]);\n                    }else{\n                        dp[i][j] = dp[i-1][j];\n                    }\n                    \n                    dp[i][j].insert(i);\n                }\n            }\n        }\n        // printSet(dp[2][0]);\n        // printSet(dp[3][1]);\n        // printSet(dp[3][4]);\n        return ret;\n    }\n    \n    set<int> intersect(set<int>&s1,set<int>&s2){\n        vector<int> common_data;\n        set_intersection(s1.begin(),s1.end(),s2.begin(),\n                         s2.end(),back_inserter(common_data));\n        return set<int>(common_data.begin(),common_data.end());\n    }\n    void printSet(set<int>&s){\n        for(int i : s){\n            cout << i << ' ';\n        }\n        cout <<\"####\" << endl;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111101111111111111000000000"}, {"id": 273602036, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572162795, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/273602036/", "is_pending": "Not Pending", "title": "House Robber II", "memory": "N/A", "code": "class Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int sumf = 0;\n        for(int i: nums ){\n            sumf += i;\n        }\n        vector<vector<set<int> > > dp(nums.size()+1,vector<set<int>>(sumf+1,set<int>()));\n        dp[0][0].insert(0);\n        dp[1][0].insert(0);\n        dp[1][0].insert(1);\n        dp[1][nums[0]].insert(1);\n        int ret = nums[0];\n        int nsz = nums.size();\n        for(int i = 2;i <= nsz;i ++){\n            int  x = nums[i-1];\n            for(int j = 0;j <=sumf;j ++){\n                if(j >= x && dp[i-2][j-x].size() >0 && !(i==nsz && dp[i-2][j-x].find(1) != dp[i-2][j-x].end())){\n                     ret = max(ret,j);\n                     if(dp[i][j].size() ==0){\n                         dp[i][j] = dp[i-2][j-x];\n                         // dp[i][j] = dp[i-2][j-x];\n                     }else{\n                         dp[i][j] = intersect(dp[i][j],dp[i-2][j-x]);\n                         // dp[i][j]\n                     }\n                    dp[i][j].insert(i);\n                }\n                if(dp[i-1][j].size() > 0){\n                    if(dp[i][j].size() > 0){\n                        dp[i][j] = intersect(dp[i][j],dp[i-1][j]);\n                    }else{\n                        dp[i][j] = dp[i-1][j];\n                    }\n                    \n                    dp[i][j].insert(i);\n                }\n            }\n        }\n        // printSet(dp[2][0]);\n        // printSet(dp[3][1]);\n        // printSet(dp[3][4]);\n        return ret;\n    }\n    \n    set<int> intersect(set<int>&s1,set<int>&s2){\n        vector<int> common_data;\n        set_intersection(s1.begin(),s1.end(),s2.begin(),\n                         s2.end(),back_inserter(common_data));\n        return set<int>(common_data.begin(),common_data.end());\n    }\n    void printSet(set<int>&s){\n        for(int i : s){\n            cout << i << ' ';\n        }\n        cout <<\"####\" << endl;\n    }\n};", "compare_result": "11000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 273600760, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572162271, "status_display": "Accepted", "runtime": "512 ms", "url": "/submissions/detail/273600760/", "is_pending": "Not Pending", "title": "House Robber", "memory": "10.4 MB", "code": "class Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int sumf = 0;\n        for(int i : nums){\n            sumf += i;\n        }\n        if(nums.size() <=0) return 0;\n        vector<vector<bool> > dp(nums.size()+1,vector<bool>(sumf+1,false));\n        dp[0][0] = true;\n        dp[1][0] = true;\n        dp[1][nums[0]] = true;\n        int ret = nums[0];\n        for(int i = 2;i <= nums.size();i ++){\n            int x =nums[i-1];\n            for(int j = 0;j <= sumf;j ++){\n                dp[i][j] = dp[i][j] | dp[i-1][j];\n                if(j>=x){\n                    dp[i][j] = dp[i][j] |dp[i-2][j-x];\n                }\n                if(dp[i][j]){\n                    ret = max(ret,j);\n                }\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 273600694, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572162245, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/273600694/", "is_pending": "Not Pending", "title": "House Robber", "memory": "N/A", "code": "class Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int sumf = 0;\n        for(int i : nums){\n            sumf += i;\n        }\n        vector<vector<bool> > dp(nums.size()+1,vector<bool>(sumf+1,false));\n        dp[0][0] = true;\n        dp[1][0] = true;\n        dp[1][nums[0]] = true;\n        int ret = nums[0];\n        for(int i = 2;i <= nums.size();i ++){\n            int x =nums[i-1];\n            for(int j = 0;j <= sumf;j ++){\n                dp[i][j] = dp[i][j] | dp[i-1][j];\n                if(j>=x){\n                    dp[i][j] = dp[i][j] |dp[i-2][j-x];\n                }\n                if(dp[i][j]){\n                    ret = max(ret,j);\n                }\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "110000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 273435080, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572122714, "status_display": "Accepted", "runtime": "56 ms", "url": "/submissions/detail/273435080/", "is_pending": "Not Pending", "title": "Dice Roll Simulation", "memory": "10.6 MB", "code": "class Solution {\npublic:\n    static const int md = pow(10,9)+7;\n    int dieSimulator(int n, vector<int>& rollMax) {\n        int dp[5001][7][16];\n        memset(dp,0,sizeof(dp));\n        return helper(n,rollMax,-1,0,dp);\n    }\n    int helper(int n,vector<int> &rollMax,int last,int curlen,int dp[][7][16]){\n        if (n <= 0){\n            return 1;\n        }\n        if(last >=0 && dp[n][last][curlen] >0) return dp[n][last][curlen];\n        int res = 0;\n        for(int i = 0;i < 6;i ++){\n            if(last==i && curlen >= rollMax[i]){\n                continue;\n            }\n            res = (res + helper(n-1,rollMax,i,last==i?curlen+1:1,dp))%md;\n        }\n        if(last >= 0){\n            dp[n][last][curlen] = res;\n        }\n        return res;\n    }\n};", "compare_result": "11111111111111111111111111111111"}, {"id": 273427447, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572120867, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273427447/", "is_pending": "Not Pending", "title": "Dice Roll Simulation", "memory": "N/A", "code": "class Solution {\npublic:\n    static const int md = pow(10,9)+7;\n    int dieSimulator(int n, vector<int>& rollMax) {\n        return helper(n,rollMax);\n    }\n    int helper(int n,vector<int> &rollMax){\n        if (n <= 0) return 1;\n        int res = 0;\n        for(int i = 0;i < 6;i ++){\n            if(rollMax[i] >0){\n                rollMax[i]--;\n                res = (res + helper(n-1,rollMax))%md;\n                rollMax[i]++;\n            }\n        }\n        return res;\n    }\n};", "compare_result": "11000000000000000000000000000000"}, {"id": 273421118, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572119326, "status_display": "Accepted", "runtime": "492 ms", "url": "/submissions/detail/273421118/", "is_pending": "Not Pending", "title": "Knight Dialer", "memory": "113 MB", "code": "class Solution {\npublic:\n    static const int md = pow(10,9) + 7;\n    int knightDialer(int N) {\n        vector<vector<int>>dp(4,vector<int>(3,1));\n        dp[3][0] = 0;\n        dp[3][2] = 0;\n        vector<pair<int,int>> step ;\n        step.push_back(pair<int,int>(-1,-2));\n        step.push_back(pair<int,int>(-2,-1));\n        step.push_back(pair<int,int>(-2,1));\n        step.push_back(pair<int,int>(-1,2));\n        step.push_back(pair<int,int>(1,-2));\n        step.push_back(pair<int,int>(2,-1));\n        step.push_back(pair<int,int>(2,1));\n        step.push_back(pair<int,int>(1,2));\n        \n        for(int i = 1;i < N;i ++){\n            vector<vector<int>>tmp(4,vector<int>(3,0));\n            for(int j = 0;j < 4;j ++){\n                for(int k = 0;k < 3;k ++){\n                    for(pair<int,int> st : step){\n                        int x = st.first;\n                        int y = st.second;\n                        if((x+j) < 4 && (x+j) >=0 && (y+k) < 3 && (y+k) >=0){\n                            tmp[x+j][y+k] = (tmp[x+j][y+k] + dp[j][k] )%md;\n                        }\n                    }\n                }\n            }\n            dp = tmp;\n            dp[3][0] = 0;\n            dp[3][2] = 0;\n        }\n        int sum = 0;\n        for(int i = 0;i < 4;i ++){\n            for(int j = 0;j < 3;j ++){\n                sum =(sum + dp[i][j]) %md;\n            }\n        }\n        return sum;\n        \n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 273416608, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572118241, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/273416608/", "is_pending": "Not Pending", "title": "Minimum Score Triangulation of Polygon", "memory": "8.7 MB", "code": "class Solution {\npublic:\n    int minScoreTriangulation(vector<int>& A) {\n        vector<vector<int> > dp(A.size(),vector<int>(A.size(),0));\n        int n = A.size();\n        for(int i = n-1;i >=0;i --){\n            for(int j =i;j <n;j ++){\n                if(j < i+2){\n                    dp[i][j] = 0;\n                    continue;\n                }\n                dp[i][j] = 10000000;\n                for(int k = i; k <j;k ++){\n                    dp[i][j] = min(dp[i][j],A[i]*A[j]*A[k] + dp[i][k]+dp[k][j]);\n                }\n            }\n        }\n        \n        return dp[0][A.size()-1];\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 273416267, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572118145, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/273416267/", "is_pending": "Not Pending", "title": "Minimum Score Triangulation of Polygon", "memory": "8.8 MB", "code": "class Solution {\npublic:\n    int minScoreTriangulation(vector<int>& A) {\n        vector<vector<int> > dp(A.size(),vector<int>(A.size(),10000000));\n        int n = A.size();\n        for(int i = n-1;i >=0;i --){\n            for(int j =i;j <n;j ++){\n\n                if(j < i+2){\n                    dp[i][j] = 0;\n                    continue;\n                }\n                // dp[i][j] = 1000000;\n                for(int k = i; k <j;k ++){\n                    dp[i][j] = min(dp[i][j],A[i]*A[j]*A[k] + dp[i][k]+dp[k][j]);\n                }\n            }\n        }\n        \n        return dp[0][A.size()-1];\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 273416124, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572118101, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273416124/", "is_pending": "Not Pending", "title": "Minimum Score Triangulation of Polygon", "memory": "N/A", "code": "class Solution {\npublic:\n    int minScoreTriangulation(vector<int>& A) {\n        vector<vector<int> > dp(A.size(),vector<int>(A.size(),100000));\n        int n = A.size();\n        for(int i = n-1;i >=0;i --){\n            for(int j =i;j <n;j ++){\n\n                if(j < i+2){\n                    dp[i][j] = 0;\n                    continue;\n                }\n                // dp[i][j] = 100000;\n                for(int k = i; k <j;k ++){\n                    dp[i][j] = min(dp[i][j],A[i]*A[j]*A[k] + dp[i][k]+dp[k][j]);\n                }\n            }\n        }\n        \n        return dp[0][A.size()-1];\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111001000010000110000100000000000"}, {"id": 273405672, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572115554, "status_display": "Accepted", "runtime": "136 ms", "url": "/submissions/detail/273405672/", "is_pending": "Not Pending", "title": "Perfect Squares", "memory": "11.4 MB", "code": "class Solution {\npublic:\n    int numSquares(int n) {\n        vector<int>source;\n        for(int i = 1;i <= n;i++){\n            if(i*i >n){\n                break;\n            }\n            source.push_back(i*i);\n        }\n        vector<int> dp(n+1,INT_MAX);\n        dp[0] = 0;\n        for(int i = 1;i <=n; i++){\n            for(int j : source){\n                if (j > i) break;\n                dp[i] = min(dp[i],dp[i-j] +1);\n            }\n        }\n        return dp[n];\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 273405332, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572115474, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273405332/", "is_pending": "Not Pending", "title": "Perfect Squares", "memory": "N/A", "code": "class Solution {\npublic:\n    int numSquares(int n) {\n        vector<int>source;\n        for(int i = 1;i < n;i++){\n            if(i*i >n){\n                break;\n            }\n            source.push_back(i*i);\n        }\n        vector<int> dp(n+1,INT_MAX);\n        dp[0] = 0;\n        for(int i = 1;i <=n; i++){\n            for(int j : source){\n                if (j > i) break;\n                dp[i] = min(dp[i],dp[i-j] +1);\n            }\n        }\n        return dp[n];\n    }\n};", "compare_result": "110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 273404165, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572115179, "status_display": "Accepted", "runtime": "0 ms", "url": "/submissions/detail/273404165/", "is_pending": "Not Pending", "title": "Combination Sum IV", "memory": "8.6 MB", "code": "class Solution {\npublic:\n    int combinationSum4(vector<int>& nums, int target) {\n        vector<double> dp(target+1,0);\n        dp[0] = 1;\n        for(int i = 1;i <=target;i ++){\n            for(int num :nums){\n                dp[i] += num>i?0:dp[i-num];\n            }\n        }\n        return dp[target];\n    }\n};", "compare_result": "11111111111111111"}, {"id": 273403388, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572114990, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/273403388/", "is_pending": "Not Pending", "title": "Combination Sum IV", "memory": "N/A", "code": "class Solution {\npublic:\n    int combinationSum4(vector<int>& nums, int target) {\n        vector<int> dp(target+1,0);\n        dp[0] = 1;\n        for(int i = 1;i <=target;i ++){\n            for(int num :nums){\n                dp[i] += num>i?0:dp[i-num];\n            }\n        }\n        return dp[target];\n    }\n};", "compare_result": "11111111111100000"}, {"id": 273384158, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572109493, "status_display": "Accepted", "runtime": "24 ms", "url": "/submissions/detail/273384158/", "is_pending": "Not Pending", "title": "Guess Number Higher or Lower II", "memory": "8.9 MB", "code": "/**\n\u8fd9\u9053\u9898\u662f\u7b2c\u4e00\u6b21\u9047\u89c1\u9012\u5f52\u8fc7\u7a0b\u4e2d\u6d89\u53cadp\uff0c\u8fd9\u4e2a\u9898\u76ee\u53c8\u4e24\u5c42\uff1b\n\u7b2c\u4e00\u5c42\uff0c\u9996\u5148\u627e\u5230\u88c2\u53d8\u6240\u9700\u8981\u7684\u6700\u5927\u503c\uff1b\n\u7b2c\u4e8c\u5c42\uff0c\u627e\u5230\u533a\u95f4\u5185\uff0c\u6240\u6709\u574f\u60c5\u51b5\u7684\u6700\u5c0f\u503c\uff0c\u5c31\u662f\u6211\u4eec\u9700\u8981\u8fd4\u56de\u7684\u503c\u3002\n**/\nclass Solution {\npublic:\n    // int helper(vector<vector<int>> &table,int s,int e){\n    //     if (s >= e) return 0;\n    //     if (table[s][e] != 0) return table[s][e];\n    //     int res = INT_MAX;\n    //     for(int i = s;i <=e;i ++){\n    //         //we get bad case \n    //         int tmp = i + max(helper(table,s,i-1),helper(table,i+1,e));\n    //         //every bad case ,the min;\n    //         res = min(tmp,res);\n    //     }\n    //     table[s][e]= res;\n    //     return res;\n    // }\n    // int getMoneyAmount(int n) {\n    //     vector<vector<int>> table(n+1,vector<int>(n+1,0));\n    //     helper(table,1,n);\n    //     return table[1][n];\n    // }\n    \n    int getMoneyAmount(int n) {\n        vector<vector<int> > table(n+1,vector<int>(n+1,0));\n        for(int i = n;i >= 1;i --){\n            for(int j = i;j <=n;j ++){\n                if(i==j){\n                    table[i][j] = 0;\n                }else{\n                    int res = 0;\n                    table[i][j] = INT_MAX;\n                    for(int k = i;k <=j;k ++){\n                        res = k+ max(table[i][k-1],(k+1)>n?0:table[k+1][j]);\n                        table[i][j] = min(table[i][j],res);\n                    }\n                }\n            }\n        }\n        return table[1][n];\n    }\n    \n    \n};", "compare_result": "1111111111111"}, {"id": 273384060, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572109460, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/273384060/", "is_pending": "Not Pending", "title": "Guess Number Higher or Lower II", "memory": "N/A", "code": "/**\n\u8fd9\u9053\u9898\u662f\u7b2c\u4e00\u6b21\u9047\u89c1\u9012\u5f52\u8fc7\u7a0b\u4e2d\u6d89\u53cadp\uff0c\u8fd9\u4e2a\u9898\u76ee\u53c8\u4e24\u5c42\uff1b\n\u7b2c\u4e00\u5c42\uff0c\u9996\u5148\u627e\u5230\u88c2\u53d8\u6240\u9700\u8981\u7684\u6700\u5927\u503c\uff1b\n\u7b2c\u4e8c\u5c42\uff0c\u627e\u5230\u533a\u95f4\u5185\uff0c\u6240\u6709\u574f\u60c5\u51b5\u7684\u6700\u5c0f\u503c\uff0c\u5c31\u662f\u6211\u4eec\u9700\u8981\u8fd4\u56de\u7684\u503c\u3002\n**/\nclass Solution {\npublic:\n    // int helper(vector<vector<int>> &table,int s,int e){\n    //     if (s >= e) return 0;\n    //     if (table[s][e] != 0) return table[s][e];\n    //     int res = INT_MAX;\n    //     for(int i = s;i <=e;i ++){\n    //         //we get bad case \n    //         int tmp = i + max(helper(table,s,i-1),helper(table,i+1,e));\n    //         //every bad case ,the min;\n    //         res = min(tmp,res);\n    //     }\n    //     table[s][e]= res;\n    //     return res;\n    // }\n    // int getMoneyAmount(int n) {\n    //     vector<vector<int>> table(n+1,vector<int>(n+1,0));\n    //     helper(table,1,n);\n    //     return table[1][n];\n    // }\n    \n    int getMoneyAmount(int n) {\n        vector<vector<int> > table(n+1,vector<int>(n+1,INT_MAX));\n        for(int i = 0;i <=n;i ++){\n            table[i][i] = 0;\n        }\n        for(int i = n;i >= 1;i --){\n            for(int j = i;j <=n;j ++){\n                if(i==j){\n                    table[i][j] = 0;\n                }else{\n                    int res = 0;\n                    table[i][j] = INT_MAX;\n                    for(int k = i;k <=j;k ++){\n                        res = k+ max(k-1>i?table[i][k-1]:0,(k+1)>n?0:table[k+1][j]);\n                        table[i][j] = min(table[i][j],res);\n                    }\n                }\n            }\n        }\n        return table[1][n];\n    }\n    \n    \n};", "compare_result": "1100000000000"}, {"id": 273383869, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572109398, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/273383869/", "is_pending": "Not Pending", "title": "Guess Number Higher or Lower II", "memory": "N/A", "code": "/**\n\u8fd9\u9053\u9898\u662f\u7b2c\u4e00\u6b21\u9047\u89c1\u9012\u5f52\u8fc7\u7a0b\u4e2d\u6d89\u53cadp\uff0c\u8fd9\u4e2a\u9898\u76ee\u53c8\u4e24\u5c42\uff1b\n\u7b2c\u4e00\u5c42\uff0c\u9996\u5148\u627e\u5230\u88c2\u53d8\u6240\u9700\u8981\u7684\u6700\u5927\u503c\uff1b\n\u7b2c\u4e8c\u5c42\uff0c\u627e\u5230\u533a\u95f4\u5185\uff0c\u6240\u6709\u574f\u60c5\u51b5\u7684\u6700\u5c0f\u503c\uff0c\u5c31\u662f\u6211\u4eec\u9700\u8981\u8fd4\u56de\u7684\u503c\u3002\n**/\nclass Solution {\npublic:\n    // int helper(vector<vector<int>> &table,int s,int e){\n    //     if (s >= e) return 0;\n    //     if (table[s][e] != 0) return table[s][e];\n    //     int res = INT_MAX;\n    //     for(int i = s;i <=e;i ++){\n    //         //we get bad case \n    //         int tmp = i + max(helper(table,s,i-1),helper(table,i+1,e));\n    //         //every bad case ,the min;\n    //         res = min(tmp,res);\n    //     }\n    //     table[s][e]= res;\n    //     return res;\n    // }\n    // int getMoneyAmount(int n) {\n    //     vector<vector<int>> table(n+1,vector<int>(n+1,0));\n    //     helper(table,1,n);\n    //     return table[1][n];\n    // }\n    \n    int getMoneyAmount(int n) {\n        vector<vector<int> > table(n+1,vector<int>(n+1,INT_MAX));\n        for(int i = 0;i <=n;i ++){\n            table[i][i] = 0;\n        }\n        for(int i = n;i >= 1;i --){\n            for(int j = i;j <=n;j ++){\n                if(i==j){\n                    table[i][j] = 0;\n                }else{\n                    int res = 0;\n                    // table[i][j] = INT_MAX;\n                    for(int k = i;k <=j;k ++){\n                        res = k+ max(table[i][k-1],(k+1)>n?0:table[k+1][j]);\n                        table[i][j] = min(table[i][j],res);\n                    }\n                }\n            }\n        }\n        return table[1][n];\n    }\n    \n    \n};", "compare_result": "1000000000000"}, {"id": 273383654, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572109330, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273383654/", "is_pending": "Not Pending", "title": "Guess Number Higher or Lower II", "memory": "N/A", "code": "/**\n\u8fd9\u9053\u9898\u662f\u7b2c\u4e00\u6b21\u9047\u89c1\u9012\u5f52\u8fc7\u7a0b\u4e2d\u6d89\u53cadp\uff0c\u8fd9\u4e2a\u9898\u76ee\u53c8\u4e24\u5c42\uff1b\n\u7b2c\u4e00\u5c42\uff0c\u9996\u5148\u627e\u5230\u88c2\u53d8\u6240\u9700\u8981\u7684\u6700\u5927\u503c\uff1b\n\u7b2c\u4e8c\u5c42\uff0c\u627e\u5230\u533a\u95f4\u5185\uff0c\u6240\u6709\u574f\u60c5\u51b5\u7684\u6700\u5c0f\u503c\uff0c\u5c31\u662f\u6211\u4eec\u9700\u8981\u8fd4\u56de\u7684\u503c\u3002\n**/\nclass Solution {\npublic:\n    // int helper(vector<vector<int>> &table,int s,int e){\n    //     if (s >= e) return 0;\n    //     if (table[s][e] != 0) return table[s][e];\n    //     int res = INT_MAX;\n    //     for(int i = s;i <=e;i ++){\n    //         //we get bad case \n    //         int tmp = i + max(helper(table,s,i-1),helper(table,i+1,e));\n    //         //every bad case ,the min;\n    //         res = min(tmp,res);\n    //     }\n    //     table[s][e]= res;\n    //     return res;\n    // }\n    // int getMoneyAmount(int n) {\n    //     vector<vector<int>> table(n+1,vector<int>(n+1,0));\n    //     helper(table,1,n);\n    //     return table[1][n];\n    // }\n    \n    int getMoneyAmount(int n) {\n        vector<vector<int> > table(n+1,vector<int>(n+1,n+1));\n        for(int i = n;i >= 1;i --){\n            for(int j = i;j <=n;j ++){\n                if(i==j){\n                    table[i][j] = 0;\n                }else{\n                    int res = 0;\n                    table[i][j] = INT_MAX;\n                    for(int k = i;k <=j;k ++){\n                        res = k+ max(table[i][k-1],(k+1)>n?0:table[k+1][j]);\n                        table[i][j] = min(table[i][j],res);\n                    }\n                }\n            }\n        }\n        return table[1][n];\n    }\n    \n    \n};", "compare_result": "1010111011111"}, {"id": 273381429, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572108573, "status_display": "Accepted", "runtime": "52 ms", "url": "/submissions/detail/273381429/", "is_pending": "Not Pending", "title": "Guess Number Higher or Lower II", "memory": "9.1 MB", "code": "/**\n\u8fd9\u9053\u9898\u662f\u7b2c\u4e00\u6b21\u9047\u89c1\u9012\u5f52\u8fc7\u7a0b\u4e2d\u6d89\u53cadp\uff0c\u8fd9\u4e2a\u9898\u76ee\u53c8\u4e24\u5c42\uff1b\n\u7b2c\u4e00\u5c42\uff0c\u9996\u5148\u627e\u5230\u88c2\u53d8\u6240\u9700\u8981\u7684\u6700\u5927\u503c\uff1b\n\u7b2c\u4e8c\u5c42\uff0c\u627e\u5230\u533a\u95f4\u5185\uff0c\u6240\u6709\u574f\u60c5\u51b5\u7684\u6700\u5c0f\u503c\uff0c\u5c31\u662f\u6211\u4eec\u9700\u8981\u8fd4\u56de\u7684\u503c\u3002\n**/\nclass Solution {\npublic:\n    int helper(vector<vector<int>> &table,int s,int e){\n        if (s >= e) return 0;\n        if (table[s][e] != 0) return table[s][e];\n        int res = INT_MAX;\n        for(int i = s;i <=e;i ++){\n            //we get bad case \n            int tmp = i + max(helper(table,s,i-1),helper(table,i+1,e));\n            //every bad case ,the min;\n            res = min(tmp,res);\n        }\n        table[s][e]= res;\n        return res;\n    }\n    int getMoneyAmount(int n) {\n        vector<vector<int>> table(n+1,vector<int>(n+1,0));\n        helper(table,1,n);\n        return table[1][n];\n    }\n    \n};", "compare_result": "1111111111111"}, {"id": 273380909, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572108382, "status_display": "Accepted", "runtime": "52 ms", "url": "/submissions/detail/273380909/", "is_pending": "Not Pending", "title": "Guess Number Higher or Lower II", "memory": "9.2 MB", "code": "class Solution {\npublic:\n    \n    int helper(vector<vector<int>> &table,int s,int e){\n        if (s >= e) return 0;\n        if (table[s][e] != 0) return table[s][e];\n        int res = INT_MAX;\n        for(int i = s;i <=e;i ++){\n            //we get bad case \n            int tmp = i + max(helper(table,s,i-1),helper(table,i+1,e));\n            //every bad case ,the min;\n            res = min(tmp,res);\n        }\n        table[s][e]= res;\n        return res;\n    }\n    int getMoneyAmount(int n) {\n        vector<vector<int>> table(n+1,vector<int>(n+1,0));\n        helper(table,1,n);\n        return table[1][n];\n    }\n    \n};", "compare_result": "1111111111111"}, {"id": 273372543, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572105424, "status_display": "Accepted", "runtime": "256 ms", "url": "/submissions/detail/273372543/", "is_pending": "Not Pending", "title": "Ones and Zeroes", "memory": "93.1 MB", "code": "class Solution {\npublic:\n    vector<int> getZeroOnes(string&s){\n        int a = 0,b = 0;\n        for(char c : s){\n            if(c =='0'){\n                a ++;\n            }else{\n                b++;\n            }\n        }\n        vector<int> ivc;\n        ivc.push_back(a);\n        ivc.push_back(b);\n        return ivc;\n    }\n    \n    static bool mycmp(vector<int> &a ,vector<int> &b){\n        return a[0] < b[0];\n    }\n    int findMaxForm(vector<string>& strs, int m, int n) {\n        vector<vector<int> > istrs;\n        for(string s : strs){\n            istrs.push_back(getZeroOnes(s));\n        }\n        sort(istrs.begin(),istrs.end(),mycmp);\n        \n        vector<vector<vector<int>>> dp(istrs.size()+1,vector<vector<int>>(m+1,vector<int>(n+1,0)));\n\n        \n        int ret = 0;\n        for(int k = 1; k <= istrs.size();k ++){\n            vector<int> a = istrs[k-1];\n            for(int i = 0;i <=m;i ++){\n                for(int j = 0;j <=n;j ++){\n                \n                    if(a[0] <= i && a[1] <= j ){\n                        //put in or not\n                        dp[k][i][j]=max(dp[k-1][i][j],dp[k-1][i-a[0]][j-a[1]]+1);\n                        // ret = max(ret,dp[k][i][j]);\n                    }else{\n                        dp[k][i][j]=dp[k-1][i][j];\n                        // ret = max(ret,dp[k][i][j])\n                    }\n                }\n            }\n        }\n        return dp[istrs.size()][m][n];\n    }\n};\n\n\n\n", "compare_result": "111111111111111111111111111111111111111111111111111111111111111"}, {"id": 273372375, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572105367, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273372375/", "is_pending": "Not Pending", "title": "Ones and Zeroes", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<int> getZeroOnes(string&s){\n        int a = 0,b = 0;\n        for(char c : s){\n            if(c =='0'){\n                a ++;\n            }else{\n                b++;\n            }\n        }\n        vector<int> ivc;\n        ivc.push_back(a);\n        ivc.push_back(b);\n        return ivc;\n    }\n    \n    static bool mycmp(vector<int> &a ,vector<int> &b){\n        return a[0] < b[0];\n    }\n    int findMaxForm(vector<string>& strs, int m, int n) {\n        vector<vector<int> > istrs;\n        for(string s : strs){\n            istrs.push_back(getZeroOnes(s));\n        }\n        sort(istrs.begin(),istrs.end(),mycmp);\n        \n        vector<vector<vector<int>>> dp(istrs.size()+1,vector<vector<int>>(m+1,vector<int>(n+1,0)));\n\n        \n        int ret = 0;\n        for(int k = 1; k <= istrs.size();k ++){\n            vector<int> a = istrs[k-1];\n            for(int i = 0;i <=m;i ++){\n                for(int j = 0;j <=n;j ++){\n                \n                    if(a[0] <= i && a[1] <= j ){\n                        dp[k][i][j]=max(dp[k][i][j],dp[k-1][i-a[0]][j-a[1]]+1);\n                        // ret = max(ret,dp[k][i][j]);\n                    }else{\n                        dp[k][i][j]=dp[k-1][i][j];\n                        // ret = max(ret,dp[k][i][j])\n                    }\n                }\n            }\n        }\n\n        \n        return dp[istrs.size()][m][n];\n    }\n};\n\n\n\n", "compare_result": "111110011111111101111001110111101111111111110011111111101111111"}, {"id": 273372173, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572105312, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273372173/", "is_pending": "Not Pending", "title": "Ones and Zeroes", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<int> getZeroOnes(string&s){\n        int a = 0,b = 0;\n        for(char c : s){\n            if(c =='0'){\n                a ++;\n            }else{\n                b++;\n            }\n        }\n        vector<int> ivc;\n        ivc.push_back(a);\n        ivc.push_back(b);\n        return ivc;\n    }\n    \n    static bool mycmp(vector<int> &a ,vector<int> &b){\n        return a[0] < b[0];\n    }\n    int findMaxForm(vector<string>& strs, int m, int n) {\n        vector<vector<int> > istrs;\n        for(string s : strs){\n            istrs.push_back(getZeroOnes(s));\n        }\n        sort(istrs.begin(),istrs.end(),mycmp);\n        \n        vector<vector<vector<int>>> dp(istrs.size()+1,vector<vector<int>>(m+1,vector<int>(n+1,0)));\n\n        \n        int ret = 0;\n        for(int k = 1; k <= istrs.size();k ++){\n            vector<int> a = istrs[k-1];\n            for(int i = 0;i <=m;i ++){\n                for(int j = 0;j <=n;j ++){\n                \n                    if(a[0] <= i && a[1] <= j ){\n                        dp[k][i][j]=max(dp[k][i][j],dp[k-1][i-a[0]][j-a[1]]+1);\n                        ret = max(ret,dp[k][i][j]);\n                    }else{\n                        dp[k][i][j]=dp[k-1][i][j];\n                    }\n                }\n            }\n        }\n\n        \n        return ret;\n    }\n};\n\n\n\n", "compare_result": "111111111111111111111101111111111111111111111111111111111111111"}, {"id": 273359315, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572100161, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273359315/", "is_pending": "Not Pending", "title": "Last Stone Weight II", "memory": "N/A", "code": "class Solution {\npublic:\n    int lastStoneWeightII(vector<int>& stones) {\n        //dp[i][j] stones between [i,j] small\n        //we want get dp[0][stones.size()-1];\n        //dp[i][i] = stones[i];\n        vector<vector<int> > dp(stones.size(),vector<int>(stones.size(),INT_MAX));\n        for(int i = 0;i <stones.size();i ++){\n            dp[i][i] = stones[i];\n        }\n        for(int i =stones.size() -1;i >= 0;i --){\n            for(int j = i;j < stones.size();j++){\n                for(int k = i;k < j ;k ++){\n                    // cout << i << ' ' << j << ' ' << k <<endl;\n                    dp[i][j] = min(dp[i][j],abs(dp[i][k]-dp[k+1][j]));\n                }\n            }\n        }\n        \n        // for(int i = 0;i < stones.size();i ++){\n        //     for(int j = 0;j < stones.size();j ++){\n        //         cout << dp[i][j]<< ' ';\n        //     }\n        //     cout  << endl;\n        // }\n        return dp[0][stones.size()-1];\n        \n    }\n};", "compare_result": "1111111111111111111111111111110111011101100111000110101001111101100100111010111111"}, {"id": 273313618, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572073956, "status_display": "Accepted", "runtime": "52 ms", "url": "/submissions/detail/273313618/", "is_pending": "Not Pending", "title": "Longest Increasing Subsequence", "memory": "8.5 MB", "code": "class Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        vector<int> dp(nums.size(),1);\n        if(nums.size() <= 0) return 0;\n        int ret = 1;\n        for(int i = 1;i < nums.size();i ++){\n            for(int j = 0;j < i;j ++){\n                if(nums[i] > nums[j]){\n                    dp[i] = max(dp[i],dp[j]+1);\n                    ret = max(ret,dp[i]);\n                }\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "111111111111111111111111"}, {"id": 273313523, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572073920, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273313523/", "is_pending": "Not Pending", "title": "Longest Increasing Subsequence", "memory": "N/A", "code": "class Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        vector<int> dp(nums.size(),1);\n        int ret = 1;\n        for(int i = 1;i < nums.size();i ++){\n            for(int j = 0;j < i;j ++){\n                if(nums[i] > nums[j]){\n                    dp[i] = max(dp[i],dp[j]+1);\n                    ret = max(ret,dp[i]);\n                }\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "101111111111111111111111"}, {"id": 273313486, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572073906, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273313486/", "is_pending": "Not Pending", "title": "Longest Increasing Subsequence", "memory": "N/A", "code": "class Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        vector<int> dp(nums.size(),1);\n        int ret = 0;\n        for(int i = 1;i < nums.size();i ++){\n            for(int j = 0;j < i;j ++){\n                if(nums[i] > nums[j]){\n                    dp[i] = max(dp[i],dp[j]+1);\n                    ret = max(ret,dp[i]);\n                }\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "110011110001101111111101"}, {"id": 273312908, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572073696, "status_display": "Accepted", "runtime": "92 ms", "url": "/submissions/detail/273312908/", "is_pending": "Not Pending", "title": "Partition to K Equal Sum Subsets", "memory": "16.5 MB", "code": "class Solution {\npublic:\n    // bool canPartitionKSubsets(vector<int>& nums, int k) {\n    //     map<int,int> mp;\n    //     int sumf = 0;\n    //     for(int i : nums){\n    //         sumf += i;\n    //         mp[i]++;\n    //     }\n    //     if(sumf % k != 0 || nums.size() < k) return false;\n    //     int T = sumf/k;\n    //     vector<vector<int> > dp;\n    //     dp.push_back(vector<int>(k,T));\n    //     for(int i = 0;i < nums.size();i ++){\n    //         vector<vector<int> > tmp;\n    //         int count = 0;\n    //         int rm = nums[i];\n    //         set<vector<int> > svec;\n    //         for(int j = 0;j < dp.size();j ++){\n    //             for(int m = 0;m < k;m ++){\n    //                 if(dp[j][m] - rm <0)\n    //                 {\n    //                     break;\n    //                 }\n    //                 {\n    //                     vector<int> vtp = dp[j];\n    //                     vtp[m] -= rm;\n    //                     sort(vtp.begin(),vtp.end());\n    //                     reverse(vtp.begin(),vtp.end());\n    //                     if(svec.find(vtp) != svec.end()){\n    //                         continue;\n    //                     }\n    //                     tmp.push_back(vtp);\n    //                     svec.insert(vtp);\n    //                 }\n    //             }\n    //         }\n    //         dp = tmp;\n    //     }\n    //     return dp.size() > 0;\n    // }\n    \n    \n    bool canPartitionKSubsets(vector<int>& nums, int k) {\n        int sumf = 0;\n        for(int i : nums){\n            sumf += i;\n        }\n        if (sumf%k !=0 || nums.size() < k) return false;\n        sumf /= k;\n        vector<bool> dp(1<<nums.size(),false);\n        vector<int> total(1<<nums.size(),0);\n        dp[0] = true;\n        sort(nums.begin(),nums.end());\n        if(nums[nums.size()-1] > sumf) return false;\n        \n        for(int i = 0;i < (1 << nums.size());i ++){\n            if(dp[i]){\n                for(int j = 0;j < nums.size();j ++){\n                    int t = i | 1<<j;\n                    //add in \n                    if (t != i){\n                        if(nums[j] <= (sumf - total[i] % sumf)){\n                            total[t] = total[i] + nums[j];\n                            dp[t] = true;\n                        }else{\n                            break;\n                        }\n                    }\n                    \n                }\n            }\n            \n        }\n        \n        return dp[(1<<nums.size())-1];\n\n    }\n    \n    \n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 273312311, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572073505, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273312311/", "is_pending": "Not Pending", "title": "Partition to K Equal Sum Subsets", "memory": "N/A", "code": "class Solution {\npublic:\n    // bool canPartitionKSubsets(vector<int>& nums, int k) {\n    //     map<int,int> mp;\n    //     int sumf = 0;\n    //     for(int i : nums){\n    //         sumf += i;\n    //         mp[i]++;\n    //     }\n    //     if(sumf % k != 0 || nums.size() < k) return false;\n    //     int T = sumf/k;\n    //     vector<vector<int> > dp;\n    //     dp.push_back(vector<int>(k,T));\n    //     for(int i = 0;i < nums.size();i ++){\n    //         vector<vector<int> > tmp;\n    //         int count = 0;\n    //         int rm = nums[i];\n    //         set<vector<int> > svec;\n    //         for(int j = 0;j < dp.size();j ++){\n    //             for(int m = 0;m < k;m ++){\n    //                 if(dp[j][m] - rm <0)\n    //                 {\n    //                     break;\n    //                 }\n    //                 {\n    //                     vector<int> vtp = dp[j];\n    //                     vtp[m] -= rm;\n    //                     sort(vtp.begin(),vtp.end());\n    //                     reverse(vtp.begin(),vtp.end());\n    //                     if(svec.find(vtp) != svec.end()){\n    //                         continue;\n    //                     }\n    //                     tmp.push_back(vtp);\n    //                     svec.insert(vtp);\n    //                 }\n    //             }\n    //         }\n    //         dp = tmp;\n    //     }\n    //     return dp.size() > 0;\n    // }\n    \n    \n    bool canPartitionKSubsets(vector<int>& nums, int k) {\n        int sumf = 0;\n        for(int i : nums){\n            sumf += i;\n        }\n        if (sumf%k !=0 || nums.size() < k) return false;\n        sumf /= k;\n        vector<bool> dp(1<<nums.size(),false);\n        vector<int> total(1<<nums.size(),0);\n        dp[0] = true;\n        sort(nums.begin(),nums.end());\n        if(nums[nums.size()-1] > sumf) return false;\n        \n        for(int i = 0;i < (1 << nums.size());i ++){\n            if(dp[i]){\n                for(int j = 0;j < nums.size();j ++){\n                    int t = i | 1<<j;\n                    //add in \n                    if (t != i){\n                        if(nums[j] <= (sumf - total[i] % sumf)){\n                            total[t] = total[i] + nums[j];\n                            dp[t] = true;\n                        }else{\n                            break;\n                        }\n                    }\n                    \n                }\n            }\n            \n        }\n        \n        return dp[1<<nums.size()-1];\n\n    }\n    \n    \n};", "compare_result": "11111111111111111111001100011111111111111111111111111111111111111111111111111111111111111111111011111111111111111111111111111111111111111111111111111"}, {"id": 273311924, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572073349, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273311924/", "is_pending": "Not Pending", "title": "Partition to K Equal Sum Subsets", "memory": "N/A", "code": "class Solution {\npublic:\n    // bool canPartitionKSubsets(vector<int>& nums, int k) {\n    //     map<int,int> mp;\n    //     int sumf = 0;\n    //     for(int i : nums){\n    //         sumf += i;\n    //         mp[i]++;\n    //     }\n    //     if(sumf % k != 0 || nums.size() < k) return false;\n    //     int T = sumf/k;\n    //     vector<vector<int> > dp;\n    //     dp.push_back(vector<int>(k,T));\n    //     for(int i = 0;i < nums.size();i ++){\n    //         vector<vector<int> > tmp;\n    //         int count = 0;\n    //         int rm = nums[i];\n    //         set<vector<int> > svec;\n    //         for(int j = 0;j < dp.size();j ++){\n    //             for(int m = 0;m < k;m ++){\n    //                 if(dp[j][m] - rm <0)\n    //                 {\n    //                     break;\n    //                 }\n    //                 {\n    //                     vector<int> vtp = dp[j];\n    //                     vtp[m] -= rm;\n    //                     sort(vtp.begin(),vtp.end());\n    //                     reverse(vtp.begin(),vtp.end());\n    //                     if(svec.find(vtp) != svec.end()){\n    //                         continue;\n    //                     }\n    //                     tmp.push_back(vtp);\n    //                     svec.insert(vtp);\n    //                 }\n    //             }\n    //         }\n    //         dp = tmp;\n    //     }\n    //     return dp.size() > 0;\n    // }\n    \n    \n    bool canPartitionKSubsets(vector<int>& nums, int k) {\n        int sumf = 0;\n        for(int i : nums){\n            sumf += i;\n        }\n        if (sumf%k !=0 || nums.size() < k) return false;\n        sumf /= k;\n        vector<bool> dp(1<<nums.size(),false);\n        vector<int> total(1<<nums.size(),0);\n        dp[0] = true;\n        sort(nums.begin(),nums.end());\n        \n        for(int i = 0;i < (1 << nums.size());i ++){\n            if(dp[i]){\n                for(int j = 0;j < nums.size();j ++){\n                    int t = i | 1<<j;\n                    //add in \n                    if (t != i){\n                        if(nums[j] <= (sumf - total[i] % sumf)){\n                            total[t] = total[i] + nums[j];\n                            dp[t] = true;\n                        }else{\n                            break;\n                        }\n                    }\n                    \n                }\n            }\n            \n        }\n        \n        return dp[1<<nums.size()-1];\n\n    }\n    \n    \n};", "compare_result": "11111111111111111111001100011111111111111111111111111111111111111111111111111111111111111111111011111111111111111111111111111111111111111111111111111"}, {"id": 273311705, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572073269, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273311705/", "is_pending": "Not Pending", "title": "Partition to K Equal Sum Subsets", "memory": "N/A", "code": "class Solution {\npublic:\n    // bool canPartitionKSubsets(vector<int>& nums, int k) {\n    //     map<int,int> mp;\n    //     int sumf = 0;\n    //     for(int i : nums){\n    //         sumf += i;\n    //         mp[i]++;\n    //     }\n    //     if(sumf % k != 0 || nums.size() < k) return false;\n    //     int T = sumf/k;\n    //     vector<vector<int> > dp;\n    //     dp.push_back(vector<int>(k,T));\n    //     for(int i = 0;i < nums.size();i ++){\n    //         vector<vector<int> > tmp;\n    //         int count = 0;\n    //         int rm = nums[i];\n    //         set<vector<int> > svec;\n    //         for(int j = 0;j < dp.size();j ++){\n    //             for(int m = 0;m < k;m ++){\n    //                 if(dp[j][m] - rm <0)\n    //                 {\n    //                     break;\n    //                 }\n    //                 {\n    //                     vector<int> vtp = dp[j];\n    //                     vtp[m] -= rm;\n    //                     sort(vtp.begin(),vtp.end());\n    //                     reverse(vtp.begin(),vtp.end());\n    //                     if(svec.find(vtp) != svec.end()){\n    //                         continue;\n    //                     }\n    //                     tmp.push_back(vtp);\n    //                     svec.insert(vtp);\n    //                 }\n    //             }\n    //         }\n    //         dp = tmp;\n    //     }\n    //     return dp.size() > 0;\n    // }\n    \n    \n    bool canPartitionKSubsets(vector<int>& nums, int k) {\n        int sumf = 0;\n        for(int i : nums){\n            sumf += i;\n        }\n        if (sumf%k !=0 || nums.size() < k) return false;\n        sumf /= k;\n        vector<bool> dp(1<<nums.size(),false);\n        vector<int> total(1<<nums.size(),0);\n        dp[0] = true;\n        sort(nums.begin(),nums.end());\n        \n        for(int i = 0;i < (1 << nums.size());i ++){\n            if(dp[i]){\n                for(int j = 0;j < nums.size();j ++){\n                    int t = i | 1<<j;\n                    //add in \n                    if (t != i){\n                        if(nums[j] <= (sumf - total[i] % sumf)){\n                            total[t] += nums[j];\n                            dp[t] = true;\n                        }else{\n                            break;\n                        }\n                    }\n                    \n                }\n            }\n            \n        }\n        \n        return dp[1<<nums.size()-1];\n\n    }\n    \n    \n};", "compare_result": "11111111111111111111001100011111111111111111111111111111111111111111111111111111111111111111111011111111111111111111111111111111111111111111111111111"}, {"id": 273304546, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572070778, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/273304546/", "is_pending": "Not Pending", "title": "Partition to K Equal Sum Subsets", "memory": "N/A", "code": "class Solution {\npublic:\n    bool canPartitionKSubsets(vector<int>& nums, int k) {\n        map<int,int> mp;\n        int sumf = 0;\n        for(int i : nums){\n            sumf += i;\n            mp[i]++;\n        }\n        if(sumf % k != 0 || nums.size() < k) return false;\n        int T = sumf/k;\n        vector<vector<int> > dp;\n        dp.push_back(vector<int>(k,T));\n        for(int i = 0;i < nums.size();i ++){\n            vector<vector<int> > tmp;\n            int count = 0;\n            int rm = nums[i];\n            set<vector<int> > svec;\n            for(int j = 0;j < dp.size();j ++){\n                for(int m = 0;m < k;m ++){\n                    if(dp[j][m] - rm >=0){\n                        vector<int> vtp = dp[j];\n                        vtp[m] -= rm;\n                        sort(vtp.begin(),vtp.end());\n                        if(svec.find(vtp) != svec.end()){\n                            continue;\n                        }\n                        tmp.push_back(vtp);\n                        svec.insert(vtp);\n                    }\n                }\n            }\n            dp = tmp;\n        }\n        return dp.size() > 0;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 273303399, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572070392, "status_display": "Memory Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/273303399/", "is_pending": "Not Pending", "title": "Partition to K Equal Sum Subsets", "memory": "N/A", "code": "class Solution {\npublic:\n    bool canPartitionKSubsets(vector<int>& nums, int k) {\n        map<int,int> mp;\n        int sumf = 0;\n        for(int i : nums){\n            sumf += i;\n            mp[i]++;\n        }\n        if(sumf % k != 0 || nums.size() < k) return false;\n        int T = sumf/k;\n        vector<vector<int> > dp;\n        dp.push_back(vector<int>(k,T));\n        for(int i = 0;i < nums.size();i ++){\n            vector<vector<int> > tmp;\n            int count = 0;\n            int rm = nums[i];\n            for(int j = 0;j < dp.size();j ++){\n                for(int m = 0;m < k;m ++){\n                    if(dp[j][m] - rm >=0){\n                        tmp.push_back(dp[j]);\n                        tmp[count][m] -= rm;\n                    }\n                }\n            }\n            dp = tmp;\n        }\n        return dp.size() > 0;\n    }\n};", "compare_result": "11000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 273298113, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572068644, "status_display": "Accepted", "runtime": "124 ms", "url": "/submissions/detail/273298113/", "is_pending": "Not Pending", "title": "Partition Equal Subset Sum", "memory": "60.6 MB", "code": "class Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        int sumf = 0;\n        for(int i  : nums){\n            sumf += i;\n        }\n        if(sumf %2 != 0 || nums.size() <=1) return false;\n        \n        vector<vector<int> > dp(nums.size()+1,vector<int>(sumf/2+1,false));\n        dp[0][0] = true;\n        for(int i = 1;i <= nums.size();i ++){\n            for(int j = sumf/2;j >= 0;j --){\n                dp[i][j] |= dp[i-1][j];\n                if(j-nums[i-1] >= 0){\n                 dp[i][j] |= dp[i-1][j-nums[i-1]];\n                }\n            }\n        }\n        // cout << dp[1][1] << endl;\n        // cout << dp[2][6] << endl;\n        // cout << dp[3][6] << endl;\n        return dp[nums.size()][sumf/2];\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 273282912, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572063585, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/273282912/", "is_pending": "Not Pending", "title": "Triangle", "memory": "9.9 MB", "code": "class Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        int n = triangle.size();\n        vector<vector<int> >dp(n, vector<int>(n,INT_MAX));\n        dp[0][0] = triangle[0][0];\n        for(int i = 1;i < n;i ++){\n            for(int j = 0;j <= i;j ++){\n                if(j-1 >=0){\n                    dp[i][j] = min(dp[i][j],dp[i-1][j-1] + triangle[i][j]);\n                }\n                if(j <= i-1){\n                    dp[i][j] = min(dp[i][j],dp[i-1][j] + triangle[i][j]);\n                }\n                // if (j +1 <= i-1){\n                //      dp[i][j] = min(dp[i][j],dp[i-1][j+1] + triangle[i][j]);\n                // }\n            }\n        }\n        \n        int ret = INT_MAX;\n        for(int i = 0;i < n;i ++){\n            ret = min(ret,dp[n-1][i]);\n        }\n        return ret;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111"}, {"id": 273282683, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572063509, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273282683/", "is_pending": "Not Pending", "title": "Triangle", "memory": "N/A", "code": "class Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        int n = triangle.size();\n        vector<vector<int> >dp(n, vector<int>(n,INT_MAX));\n        dp[0][0] = triangle[0][0];\n        for(int i = 1;i < n;i ++){\n            for(int j = 0;j <= i;j ++){\n                if(j-1 >=0){\n                    dp[i][j] = min(dp[i][j],dp[i-1][j-1] + triangle[i][j]);\n                }\n                if(j <= i-1){\n                    dp[i][j] = min(dp[i][j],dp[i-1][j] + triangle[i][j]);\n                }\n                if (j +1 <= i-1){\n                     dp[i][j] = min(dp[i][j],dp[i-1][j+1] + triangle[i][j]);\n                }\n            }\n        }\n        \n        int ret = INT_MAX;\n        for(int i = 0;i < n;i ++){\n            ret = min(ret,dp[n-1][i]);\n        }\n        return ret;\n    }\n};", "compare_result": "1111111001010001110001000011000011110010000"}, {"id": 273159810, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572024988, "status_display": "Accepted", "runtime": "24 ms", "url": "/submissions/detail/273159810/", "is_pending": "Not Pending", "title": "Push Dominoes", "memory": "12 MB", "code": "class Solution {\npublic:\n    string pushDominoes(string dominoes) {\n        int status = 0;\n        string ret(dominoes);\n        int L = -1;\n        int R = -1;\n        int sz = dominoes.size();\n        for(int i = 0;i <= sz;i ++){\n            if(i == sz || dominoes[i] == 'R'){\n                //R...R\n                if(R > L){\n                    for(int k = R;k < i;k ++){\n                        ret[k] = 'R';\n                    }\n                }\n                R = i;\n            }else if (dominoes[i] == 'L'){\n                //L ...L\n                if(L>R || (R==-1 && L == -1)){\n                    for(int k = i;k > L && k >= 0;k --){\n                        ret[k] = 'L';\n                    }\n                    L  = i;\n                }else{\n                    //R ..L\n                    int start = R+1;\n                    int end = i-1;\n                    while(start < end){\n                        ret[start] = 'R';\n                        ret[end] = 'L';\n                        start ++;\n                        end --;\n                    }\n                    L = i;\n                }\n                \n            }\n        }\n        return ret;\n    }\n};", "compare_result": "111111111111111111111111111111111111"}, {"id": 273159474, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572024875, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/273159474/", "is_pending": "Not Pending", "title": "Push Dominoes", "memory": "N/A", "code": "class Solution {\npublic:\n    string pushDominoes(string dominoes) {\n        int status = 0;\n        string ret(dominoes);\n        int L = -1;\n        int R = -1;\n        int sz = dominoes.size();\n        for(int i = 0;i <= sz;i ++){\n            if(i == sz || dominoes[i] == 'R'){\n                //R...R\n                if(R > L){\n                    for(int k = R;k < i;k ++){\n                        ret[k] = 'R';\n                    }\n                }\n                R = i;\n            }else if (dominoes[i] == 'L'){\n                //L ...L\n                if(L>R || (R==-1 && L == -1)){\n                    for(int k = L;k < i;k ++){\n                        ret[k] = 'L';\n                    }\n                    L  = i;\n                }else{\n                    //R ..L\n                    int start = R+1;\n                    int end = i-1;\n                    while(start < end){\n                        ret[start] = 'R';\n                        ret[end] = 'L';\n                        start ++;\n                        end --;\n                    }\n                    L = i;\n                }\n                \n            }\n        }\n        return ret;\n    }\n};", "compare_result": "111111111111111111111111110000000000"}, {"id": 273157622, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572024280, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273157622/", "is_pending": "Not Pending", "title": "Push Dominoes", "memory": "N/A", "code": "class Solution {\npublic:\n    string pushDominoes(string dominoes) {\n        int status = 0;\n        string ret(dominoes);\n        int last_index = 0;\n        int idx = 0;\n        int sz = dominoes.size();\n        while(idx < dominoes.size()){\n            if(dominoes[idx] == '.'){\n                while(idx < dominoes.size() && dominoes[idx] == '.') idx ++;\n                if (idx < dominoes.size()){\n                    if(dominoes[idx] == 'L' && (idx +1 >= dominoes.size() || dominoes[idx+1] != 'L')){\n                        for(int i = last_index;i < idx;i ++){\n                            ret[i] = 'L';\n                        }\n                    }\n                    // idx ++;\n                }\n                // idx ++;\n                last_index = idx;\n            }else if(dominoes[idx] == 'R'){\n                if(idx +1 < dominoes.size() && dominoes[idx+1] != '.'){\n                    while(idx < sz && dominoes[idx] == 'R') idx ++;\n                    if(idx < sz && dominoes[idx] == '.'){\n                        idx ++;\n                    }\n                    last_index = idx;\n                    // idx ++;\n                }else{\n                    //find L\n                    idx ++;\n                    while(idx < sz && dominoes[idx] == '.' ) idx ++;\n                    //R\n                    // cout << idx << endl;\n                    if (idx >= sz || dominoes[idx] == 'R' ){\n                        // cout <<'eee';\n                        for(int i = last_index;i < idx && i < sz ;i ++){\n                            ret[i] = 'R';\n                        }\n                    }else {\n                        //L\n                        if(idx +1 >= sz || dominoes[idx+1] != 'L' ){\n                            int start = last_index;\n                            int end = idx;\n                            while(start < end){\n                                ret[start] = 'R';\n                                ret[end] = 'L';\n                                start ++;\n                                end --;\n                            }\n                            last_index  = idx +1;\n                        }\n                    }\n                }\n            }else{\n                idx ++;\n                last_index = idx;\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "111111111111111111001011110000000000"}, {"id": 273155938, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572023724, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273155938/", "is_pending": "Not Pending", "title": "Push Dominoes", "memory": "N/A", "code": "class Solution {\npublic:\n    string pushDominoes(string dominoes) {\n        int status = 0;\n        string ret(dominoes);\n        int last_index = 0;\n        int idx = 0;\n        int sz = dominoes.size();\n        while(idx < dominoes.size()){\n            if(dominoes[idx] == '.'){\n                while(idx < dominoes.size() && dominoes[idx] == '.') idx ++;\n                if (idx < dominoes.size()){\n                    if(dominoes[idx] == 'L' && (idx +1 >= dominoes.size() || dominoes[idx+1] != 'L')){\n                        for(int i = last_index;i < idx;i ++){\n                            ret[i] = 'L';\n                        }\n                    }\n                    // idx ++;\n                }\n                // idx ++;\n                last_index = idx;\n            }else if(dominoes[idx] == 'R'){\n                if(idx +1 < dominoes.size() && dominoes[idx+1] != '.'){\n                    last_index = idx;\n                    idx ++;\n                }else{\n                    //find L\n                    idx ++;\n                    while(idx < sz && dominoes[idx] == '.' ) idx ++;\n                    //R\n                    // cout << idx << endl;\n                    if (idx >= sz || dominoes[idx] == 'R' ){\n                        // cout <<'eee';\n                        for(int i = last_index;i < idx && i < sz ;i ++){\n                            ret[i] = 'R';\n                        }\n                    }else {\n                        //L\n                        if(idx +1 >= sz || dominoes[idx+1] != 'L' ){\n                            int start = last_index;\n                            int end = idx;\n                            while(start < end){\n                                ret[start] = 'R';\n                                ret[end] = 'L';\n                                start ++;\n                                end --;\n                            }\n                            last_index  = idx +1;\n                        }\n                    }\n                }\n            }else{\n                idx ++;\n                last_index = idx;\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "101111111111111111011011110100000000"}, {"id": 273155528, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572023597, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273155528/", "is_pending": "Not Pending", "title": "Push Dominoes", "memory": "N/A", "code": "class Solution {\npublic:\n    string pushDominoes(string dominoes) {\n        int status = 0;\n        string ret(dominoes);\n        int last_index = 0;\n        int idx = 0;\n        int sz = dominoes.size();\n        while(idx < dominoes.size()){\n            if(dominoes[idx] == '.'){\n                while(idx < dominoes.size() && dominoes[idx] == '.') idx ++;\n                if (idx < dominoes.size()){\n                    if(dominoes[idx] == 'L' && (idx +1 >= dominoes.size() || dominoes[idx+1] != 'L')){\n                        for(int i = last_index;i < idx;i ++){\n                            ret[i] = 'L';\n                        }\n                    }\n                    // idx ++;\n                }\n                // idx ++;\n                last_index = idx;\n            }else if(dominoes[idx] == 'R'){\n                if(idx +1 < dominoes.size() && dominoes[idx+1] != '.'){\n                    last_index = idx;\n                    idx ++;\n                }else{\n                    //find L\n                    idx ++;\n                    while(idx < sz && dominoes[idx] == '.' ) idx ++;\n                    //R\n                    // cout << idx << endl;\n                    if (idx >= sz || dominoes[idx] == 'R' ){\n                        // cout <<'eee';\n                        for(int i = last_index;i < idx && i < sz ;i ++){\n                            ret[i] = 'R';\n                        }\n                    }else {\n                        //L\n                        if(idx +1 >= sz || dominoes[idx+1] != 'L' ){\n                            int start = last_index+1;\n                            int end = idx-1;\n                            while(start < end){\n                                ret[start] = 'R';\n                                ret[end] = 'L';\n                                start ++;\n                                end --;\n                            }\n                            last_index  = idx +1;\n                        }\n                    }\n                }\n            }else{\n                idx ++;\n                last_index = idx;\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "101111111111111111011011110100000000"}, {"id": 273155445, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572023573, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273155445/", "is_pending": "Not Pending", "title": "Push Dominoes", "memory": "N/A", "code": "class Solution {\npublic:\n    string pushDominoes(string dominoes) {\n        int status = 0;\n        string ret(dominoes);\n        int last_index = 0;\n        int idx = 0;\n        int sz = dominoes.size();\n        while(idx < dominoes.size()){\n            if(dominoes[idx] == '.'){\n                while(idx < dominoes.size() && dominoes[idx] == '.') idx ++;\n                if (idx < dominoes.size()){\n                    if(dominoes[idx] == 'L' && (idx +1 >= dominoes.size() || dominoes[idx+1] != 'L')){\n                        for(int i = last_index;i < idx;i ++){\n                            ret[i] = 'L';\n                        }\n                    }\n                    // idx ++;\n                }\n                // idx ++;\n                last_index = idx;\n            }else if(dominoes[idx] == 'R'){\n                if(idx +1 < dominoes.size() && dominoes[idx+1] != '.'){\n                    idx ++;\n                    last_index = idx;\n                }else{\n                    //find L\n                    idx ++;\n                    while(idx < sz && dominoes[idx] == '.' ) idx ++;\n                    //R\n                    // cout << idx << endl;\n                    if (idx >= sz || dominoes[idx] == 'R' ){\n                        // cout <<'eee';\n                        for(int i = last_index;i < idx && i < sz ;i ++){\n                            ret[i] = 'R';\n                        }\n                    }else {\n                        //L\n                        if(idx +1 >= sz || dominoes[idx+1] != 'L' ){\n                            int start = last_index+1;\n                            int end = idx-1;\n                            while(start < end){\n                                ret[start] = 'R';\n                                ret[end] = 'L';\n                                start ++;\n                                end --;\n                            }\n                            last_index  = idx +1;\n                        }\n                    }\n                }\n            }else{\n                idx ++;\n                last_index = idx;\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "111111111111111111011011110100000000"}, {"id": 273154837, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572023384, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273154837/", "is_pending": "Not Pending", "title": "Push Dominoes", "memory": "N/A", "code": "class Solution {\npublic:\n    string pushDominoes(string dominoes) {\n        int status = 0;\n        string ret(dominoes);\n        int last_index = 0;\n        int idx = 0;\n        int sz = dominoes.size();\n        while(idx < dominoes.size()){\n            if(dominoes[idx] == '.'){\n                while(idx < dominoes.size() && dominoes[idx] == '.') idx ++;\n                if (idx < dominoes.size()){\n                    if(dominoes[idx] == 'L' && (idx +1 >= dominoes.size() || dominoes[idx+1] != 'L')){\n                        for(int i = last_index;i < idx;i ++){\n                            ret[i] = 'L';\n                        }\n                    }\n                    // idx ++;\n                }\n                // idx ++;\n                last_index = idx;\n            }else if(dominoes[idx] == 'R'){\n                if(idx +1 < dominoes.size() && dominoes[idx+1] != '.'){\n                    while(dominoes[idx] == 'R') {\n                        last_index = idx;\n                        idx ++;\n                    }\n                    \n                }else{\n                    //find L\n                    idx ++;\n                    while(idx < sz && dominoes[idx] == '.' ) idx ++;\n                    //R\n                    // cout << idx << endl;\n                    if (idx >= sz || dominoes[idx] == 'R' ){\n                        // cout <<'eee';\n                        for(int i = last_index;i < idx && i < sz ;i ++){\n                            ret[i] = 'R';\n                        }\n                    }else {\n                        //L\n                        if(idx +1 >= sz || dominoes[idx+1] != 'L' ){\n                            int start = last_index+1;\n                            int end = idx-1;\n                            while(start < end){\n                                ret[start] = 'R';\n                                ret[end] = 'L';\n                                start ++;\n                                end --;\n                            }\n                            last_index  = idx +1;\n                        }\n                    }\n                }\n            }else{\n                idx ++;\n                last_index = idx;\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "101111111111111111001011110000000000"}, {"id": 273154442, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572023246, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273154442/", "is_pending": "Not Pending", "title": "Push Dominoes", "memory": "N/A", "code": "class Solution {\npublic:\n    string pushDominoes(string dominoes) {\n        int status = 0;\n        string ret(dominoes);\n        int last_index = 0;\n        int idx = 0;\n        int sz = dominoes.size();\n        while(idx < dominoes.size()){\n            if(dominoes[idx] == '.'){\n                while(idx < dominoes.size() && dominoes[idx] == '.') idx ++;\n                if (idx < dominoes.size()){\n                    if(dominoes[idx] == 'L' && (idx +1 >= dominoes.size() || dominoes[idx+1] != 'L')){\n                        for(int i = last_index;i < idx;i ++){\n                            ret[i] = 'L';\n                        }\n                    }\n                    // idx ++;\n                }\n                // idx ++;\n                last_index = idx;\n            }else if(dominoes[idx] == 'R'){\n                if(idx +1 < dominoes.size() && dominoes[idx+1] != '.'){\n                    while(dominoes[idx] == 'R') idx ++;\n                    // idx ++;\n                    last_index = idx;\n                }else{\n                    //find L\n                    idx ++;\n                    while(idx < sz && dominoes[idx] == '.' ) idx ++;\n                    //R\n                    // cout << idx << endl;\n                    if (idx >= sz || dominoes[idx] == 'R' ){\n                        // cout <<'eee';\n                        for(int i = last_index;i < idx && i < sz ;i ++){\n                            ret[i] = 'R';\n                        }\n                    }else {\n                        //L\n                        if(idx +1 >= sz || dominoes[idx+1] != 'L' ){\n                            int start = last_index+1;\n                            int end = idx-1;\n                            while(start < end){\n                                ret[start] = 'R';\n                                ret[end] = 'L';\n                                start ++;\n                                end --;\n                            }\n                            last_index  = idx +1;\n                        }\n                    }\n                }\n            }else{\n                idx ++;\n                last_index = idx;\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "101111111111111111001011110000000000"}, {"id": 273144884, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572019874, "status_display": "Accepted", "runtime": "156 ms", "url": "/submissions/detail/273144884/", "is_pending": "Not Pending", "title": "Longest Turbulent Subarray", "memory": "37.6 MB", "code": "class Solution {\npublic:\n    int maxTurbulenceSize(vector<int>& A) {\n        //dp[i][0], max size till i with i being small\n        //dp[i][1], max size till i with i being large\n        vector<vector<int> > dp(A.size(),vector<int>(2,1));\n        if(A.size() <= 0) return 0;\n        int ret = 1;\n        int inc = 1;\n        int dec = 1;\n        for(int i = 1;i < A.size();i ++){\n            int j = i-1;\n            if(A[i] < A[j]){\n                    // dp[i][0] = max(dp[i][0],dp[j][1]+1);\n                    dec = inc +1;\n                    inc = 1;\n                    // ret = max(ret,dp[i][0]);\n            }else if(A[i] >A[j]){\n                    // dp[i][1] = max(dp[i][1],dp[j][0]+1);\n                    inc = dec +1;\n                    dec = 1;\n                    // ret = max(ret,dp[i][1]);\n            }else{\n                dec = 1;\n                inc = 1;\n            }\n            ret = max(dec,ret);\n            ret = max(inc,ret);\n        }\n        return ret;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 273144108, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572019609, "status_display": "Accepted", "runtime": "164 ms", "url": "/submissions/detail/273144108/", "is_pending": "Not Pending", "title": "Longest Turbulent Subarray", "memory": "37.8 MB", "code": "class Solution {\npublic:\n    int maxTurbulenceSize(vector<int>& A) {\n        //dp[i][0], max size till i with i being small\n        //dp[i][1], max size till i with i being large\n        vector<vector<int> > dp(A.size(),vector<int>(2,1));\n        if(A.size() <= 0) return 0;\n        int ret = 1;\n        // dp[0][0] = 1;\n        // dp[0][1] = 1;\n        for(int i = 1;i < A.size();i ++){\n//             for(int j = 0;j < i;j ++){\n//                 if ((i+j)%2 == 0) continue;\n                \n//             }\n            int j = i-1;\n            if(A[i] < A[j]){\n                    dp[i][0] = max(dp[i][0],dp[j][1]+1);\n                    ret = max(ret,dp[i][0]);\n            }else if(A[i] >A[j]){\n                    dp[i][1] = max(dp[i][1],dp[j][0]+1);\n                    ret = max(ret,dp[i][1]);\n            }\n            // if(i > 8 )\n            // {\n            //     cout <<i << '\\t'<< dp[i][0] << '\\t' << dp[i][1] << endl;\n            // }\n        }\n        return ret;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 273140311, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572018317, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273140311/", "is_pending": "Not Pending", "title": "Longest Turbulent Subarray", "memory": "N/A", "code": "class Solution {\npublic:\n    int maxTurbulenceSize(vector<int>& A) {\n        //dp[i][0], max size till i with i being small\n        //dp[i][1], max size till i with i being large\n        vector<vector<int> > dp(A.size(),vector<int>(2,0));\n        if(A.size() <= 0) return 0;\n        int ret = 1;\n        dp[0][0] = 1;\n        dp[0][1] = 1;\n        for(int i = 1;i < A.size();i ++){\n            for(int j = 0;j < i;j ++){\n                if ((i+j)%2 == 0) continue;\n                if(A[i] < A[j]){\n                    dp[i][0] = max(dp[i][0],dp[j][1]+1);\n                    ret = max(ret,dp[i][0]);\n                }else if(A[i] >A[j]){\n                    dp[i][1] = max(dp[i][1],dp[j][0]+1);\n                    ret = max(ret,dp[i][1]);\n                }\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "11111100100001000000000000001000000000000000000000000000000000000000000000000000000000"}, {"id": 273136510, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572017029, "status_display": "Accepted", "runtime": "128 ms", "url": "/submissions/detail/273136510/", "is_pending": "Not Pending", "title": "Best Time to Buy and Sell Stock with Cooldown", "memory": "8.7 MB", "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.size() <= 0) return 0;\n        vector<int> buy(prices.size(),0);\n        vector<int> sell(prices.size(),0);\n        int ret = 0;\n        for(int i = 1;i < prices.size();i ++){\n            for(int j = 0;j < i;j ++){\n                int dif = prices[i]-prices[j];\n                sell[i] = max(sell[i],dif + buy[j]);\n            }\n            // if(i==1){\n            //     buy[i] = max(buy[i],sell[1]);\n            // }\n            for(int j = 0;j < i-1;j ++){\n                buy[i] = max(buy[i],sell[j]);\n            }\n            ret = max(ret,sell[i]);\n            ret = max(ret,buy[i]);\n            // cout << buy[i] << '\\t' << sell[i] << endl;\n        }\n        \n        return ret ;\n        \n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 273134661, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572016335, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273134661/", "is_pending": "Not Pending", "title": "Best Time to Buy and Sell Stock with Cooldown", "memory": "N/A", "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.size() <= 0) return 0;\n        vector<int> buy(prices.size(),0);\n        vector<int> sell(prices.size(),0);\n        for(int i = 1;i < prices.size();i ++){\n            for(int j = 0;j < i;j ++){\n                int dif = prices[i]-prices[j];\n                sell[i] = max(sell[i],dif + buy[j]);\n            }\n            for(int j = 0;j < i-1;j ++){\n                buy[i] = max(buy[i],sell[j]);\n            }\n        }\n        \n        return sell[prices.size()-1];\n        \n    }\n};", "compare_result": "1111111010111111101110101101000101000101000101011101000101000101000101010101000101000101000101010101000101000101000101010101000101000101000101010101000101000101000101011111011110111000110011010001110101001011111"}, {"id": 273131157, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572014978, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/273131157/", "is_pending": "Not Pending", "title": "Best Time to Buy and Sell Stock with Cooldown", "memory": "N/A", "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.size() <= 0) return 0;\n        vector<int> buy(prices.size(),0);\n        vector<int> sell(prices.size(),0);\n        for(int i = 1;i < prices.size();i ++){\n            int dif = prices[i]-prices[i-1];\n            sell[i] = max(0,dif) + buy[i-1];\n            buy[i] = sell[i-1];\n        }\n        \n        return sell[prices.size()-1];\n        \n    }\n};", "compare_result": "1111110010111100001010000000001000001001001001011000000001000000000000000000001000000000000000000000001000001000000000000000001000001001001000000000001000001001001001011110000000000000000000000001000000000010000"}, {"id": 273130654, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572014804, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/273130654/", "is_pending": "Not Pending", "title": "Best Time to Buy and Sell Stock with Cooldown", "memory": "N/A", "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        vector<int> buy(prices.size(),0);\n        vector<int> sell(prices.size(),0);\n        for(int i = 1;i < prices.size();i ++){\n            int dif = prices[i]-prices[i-1];\n            sell[i] = max(0,dif) + buy[i-1];\n            buy[i] = sell[i-1];\n        }\n        \n        return sell[prices.size()-1];\n        \n    }\n};", "compare_result": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 273127220, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1572013360, "status_display": "Accepted", "runtime": "16 ms", "url": "/submissions/detail/273127220/", "is_pending": "Not Pending", "title": "Largest 1-Bordered Square", "memory": "11 MB", "code": "class Solution {\npublic:\n    vector<int> getConsecutiveRow(vector<vector<int>>& grid,int idx){\n        vector<int> arr(grid.size());\n        arr[0] = grid[0][idx];\n        for(int i = 1;i < grid.size();i ++){\n            if(grid[i][idx] == 1){\n                arr[i] = arr[i-1] +1;\n            }else{\n                arr[i] = 0;\n            }\n        }    \n        return arr;\n    }\n    \n    vector<int> getConsecutiveColumn(vector<vector<int>>& grid,int idx){\n        vector<int> arr(grid[0].size());\n        arr[0] = grid[idx][0];\n        for(int i = 1;i < grid[0].size();i ++){\n            if(grid[idx][i] == 1){\n                arr[i] = arr[i-1] +1;\n            }else{\n                arr[i] = 0;\n            }\n        }    \n        return arr;\n    }\n    \n    int largest1BorderedSquare(vector<vector<int>>& grid) {\n        vector<vector<int>> rows;\n        vector<vector<int>> columns;\n        for(int i =0; i< grid.size();i ++){\n            rows.push_back(getConsecutiveColumn(grid,i));\n        }\n        for(int i =0; i< grid[0].size();i ++){\n            columns.push_back(getConsecutiveRow(grid,i));\n        }\n        int mx = 0;\n        for(int i = 0;i < grid.size();i ++){\n            for(int j = 0;j < grid[0].size();j ++){\n                int potential = min(rows[i][j],columns[j][i]);\n                if(potential > mx){\n                    for(int k = potential;k > mx;k --)\n                    {\n                        if(min(rows[i-k+1][j],columns[j-k+1][i]) >= k){\n                            mx = k;\n                            break;\n                        }\n                    }\n                }\n            }    \n        }\n        return mx*mx;\n    }\n    \n    \n} ; ", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 272871723, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571933971, "status_display": "Accepted", "runtime": "36 ms", "url": "/submissions/detail/272871723/", "is_pending": "Not Pending", "title": "Knight Probability in Chessboard", "memory": "13 MB", "code": "class Solution {\npublic:\n    double knightProbability(int N, int K, int r, int c) {\n        map<int,double> matrix;\n        matrix[r*N + c] = 1;\n        \n        vector<pair<int,int>> step ;\n        step.push_back(pair<int,int>(-1,-2));\n        step.push_back(pair<int,int>(-2,-1));\n        step.push_back(pair<int,int>(-2,1));\n        step.push_back(pair<int,int>(-1,2));\n        step.push_back(pair<int,int>(1,-2));\n        step.push_back(pair<int,int>(2,-1));\n        step.push_back(pair<int,int>(2,1));\n        step.push_back(pair<int,int>(1,2));\n        double sumf = 1;\n        for(int i = 0;i < K;i ++){\n            sumf = 0;\n            map<int,double> na;\n            for(auto it : matrix ){\n                int lr = it.first/N;\n                int lc = it.first%N;\n                for(auto st : step){\n                    int x = st.first;\n                    int y = st.second;\n                    // for(auto y : step){\n                        if((lr + x)>=0 && (lr+x)<N && (lc +y) >=0 && (lc+y) <N){\n                            int t = (lr+x)*N + lc + y;\n                            na[t] += it.second;\n                            sumf += it.second;\n                        }\n                    // }\n                }\n            }\n            matrix = na;\n        }\n        // cout << sumf << endl;\n        return sumf/(pow(8,K));\n    }\n};", "compare_result": "111111111111111111111"}, {"id": 272871497, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571933910, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/272871497/", "is_pending": "Not Pending", "title": "Knight Probability in Chessboard", "memory": "N/A", "code": "class Solution {\npublic:\n    double knightProbability(int N, int K, int r, int c) {\n        map<int,long> matrix;\n        matrix[r*N + c] = 1;\n        \n        vector<pair<int,int>> step ;\n        step.push_back(pair<int,int>(-1,-2));\n        step.push_back(pair<int,int>(-2,-1));\n        step.push_back(pair<int,int>(-2,1));\n        step.push_back(pair<int,int>(-1,2));\n        step.push_back(pair<int,int>(1,-2));\n        step.push_back(pair<int,int>(2,-1));\n        step.push_back(pair<int,int>(2,1));\n        step.push_back(pair<int,int>(1,2));\n        long sumf = 1;\n        for(int i = 0;i < K;i ++){\n            sumf = 0;\n            map<int,long> na;\n            for(auto it : matrix ){\n                int lr = it.first/N;\n                int lc = it.first%N;\n                for(auto st : step){\n                    int x = st.first;\n                    int y = st.second;\n                    // for(auto y : step){\n                        if((lr + x)>=0 && (lr+x)<N && (lc +y) >=0 && (lc+y) <N){\n                            int t = (lr+x)*N + lc + y;\n                            na[t] += it.second;\n                            sumf += it.second;\n                        }\n                    // }\n                }\n            }\n            matrix = na;\n        }\n        // cout << sumf << endl;\n        return sumf/(pow(8,K));\n    }\n};", "compare_result": "111111111110000000000"}, {"id": 272871462, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571933899, "status_display": "Compile Error", "runtime": "N/A", "url": "/submissions/detail/272871462/", "is_pending": "Not Pending", "title": "Knight Probability in Chessboard", "memory": "N/A", "code": "class Solution {\npublic:\n    double knightProbability(int N, int K, int r, int c) {\n        map<int,long> matrix;\n        matrix[r*N + c] = 1;\n        \n        vector<pair<int,int>> step ;\n        step.push_back(pair<int,int>(-1,-2));\n        step.push_back(pair<int,int>(-2,-1));\n        step.push_back(pair<int,int>(-2,1));\n        step.push_back(pair<int,int>(-1,2));\n        step.push_back(pair<int,int>(1,-2));\n        step.push_back(pair<int,int>(2,-1));\n        step.push_back(pair<int,int>(2,1));\n        step.push_back(pair<int,int>(1,2));\n        long sumf = 1;\n        for(int i = 0;i < K;i ++){\n            sumf = 0;\n            map<int,int> na;\n            for(auto it : matrix ){\n                int lr = it.first/N;\n                int lc = it.first%N;\n                for(auto st : step){\n                    int x = st.first;\n                    int y = st.second;\n                    // for(auto y : step){\n                        if((lr + x)>=0 && (lr+x)<N && (lc +y) >=0 && (lc+y) <N){\n                            int t = (lr+x)*N + lc + y;\n                            na[t] += it.second;\n                            sumf += it.second;\n                        }\n                    // }\n                }\n            }\n            matrix = na;\n        }\n        // cout << sumf << endl;\n        return sumf/(pow(8,K));\n    }\n};", "compare_result": null}, {"id": 272871318, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571933867, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/272871318/", "is_pending": "Not Pending", "title": "Knight Probability in Chessboard", "memory": "N/A", "code": "class Solution {\npublic:\n    double knightProbability(int N, int K, int r, int c) {\n        map<int,int> matrix;\n        matrix[r*N + c] = 1;\n        \n        vector<pair<int,int>> step ;\n        step.push_back(pair<int,int>(-1,-2));\n        step.push_back(pair<int,int>(-2,-1));\n        step.push_back(pair<int,int>(-2,1));\n        step.push_back(pair<int,int>(-1,2));\n        step.push_back(pair<int,int>(1,-2));\n        step.push_back(pair<int,int>(2,-1));\n        step.push_back(pair<int,int>(2,1));\n        step.push_back(pair<int,int>(1,2));\n        int sumf = 1;\n        for(int i = 0;i < K;i ++){\n            sumf = 0;\n            map<int,int> na;\n            for(auto it : matrix ){\n                int lr = it.first/N;\n                int lc = it.first%N;\n                for(auto st : step){\n                    int x = st.first;\n                    int y = st.second;\n                    // for(auto y : step){\n                        if((lr + x)>=0 && (lr+x)<N && (lc +y) >=0 && (lc+y) <N){\n                            int t = (lr+x)*N + lc + y;\n                            na[t] += it.second;\n                            sumf += it.second;\n                        }\n                    // }\n                }\n            }\n            matrix = na;\n        }\n        // cout << sumf << endl;\n        return sumf/(pow(8,K));\n    }\n};", "compare_result": "111111111110000000000"}, {"id": 272871094, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571933807, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/272871094/", "is_pending": "Not Pending", "title": "Knight Probability in Chessboard", "memory": "N/A", "code": "class Solution {\npublic:\n    double knightProbability(int N, int K, int r, int c) {\n        map<int,int> matrix;\n        matrix[r*N + c] = 1;\n        vector<pair<int,int>> step ;\n        step.push_back(pair<int,int>(-1,-2));\n        step.push_back(pair<int,int>(-2,-1));\n        step.push_back(pair<int,int>(-2,1));\n        step.push_back(pair<int,int>(-1,2));\n        step.push_back(pair<int,int>(1,-2));\n        step.push_back(pair<int,int>(2,-1));\n        step.push_back(pair<int,int>(2,1));\n        step.push_back(pair<int,int>(1,2));\n        int sumf = 0;\n        for(int i = 0;i < K;i ++){\n            sumf = 0;\n            map<int,int> na;\n            for(auto it : matrix ){\n                int lr = it.first/N;\n                int lc = it.first%N;\n                for(auto st : step){\n                    int x = st.first;\n                    int y = st.second;\n                    // for(auto y : step){\n                        if((lr + x)>=0 && (lr+x)<N && (lc +y) >=0 && (lc+y) <N){\n                            int t = (lr+x)*N + lc + y;\n                            na[t] += it.second;\n                            sumf += it.second;\n                        }\n                    // }\n                }\n            }\n            matrix = na;\n        }\n        // cout << sumf << endl;\n        return sumf/(pow(8,K));\n    }\n};", "compare_result": "101111111110000000000"}, {"id": 272858847, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571930084, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/272858847/", "is_pending": "Not Pending", "title": "Video Stitching", "memory": "9 MB", "code": "class Solution {\npublic:\n    static bool mycomp(vector<int>&a,vector<int>&b){\n        return a[0] < b[0];\n    }\n    int videoStitching(vector<vector<int>>& clips, int T) {\n        sort(clips.begin(),clips.end(),mycomp);\n        vector<int>dp(T+2,1000);\n        dp[0] = 0;\n        for(int j = 0;j < clips.size(); j ++){\n            for(int k = clips[j][0];k <= clips[j][1] && k <= T;k ++){\n                dp[k] = min(dp[k],dp[clips[j][0]]+1);\n            }\n        }\n        if (dp[T] > 800) return -1;\n        return dp[T];\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111"}, {"id": 272858766, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571930060, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/272858766/", "is_pending": "Not Pending", "title": "Video Stitching", "memory": "9 MB", "code": "class Solution {\npublic:\n    static bool mycomp(vector<int>&a,vector<int>&b){\n        return a[0] < b[0];\n    }\n    int videoStitching(vector<vector<int>>& clips, int T) {\n        sort(clips.begin(),clips.end(),mycomp);\n        vector<int>dp(T+2,1000);\n        dp[0] = 0;\n        // for(int i = 1;i < T;i ++){\n            for(int j = 0;j < clips.size(); j ++){\n                for(int k = clips[j][0];k <= clips[j][1] && k <= T;k ++){\n                    dp[k] = min(dp[k],dp[clips[j][0]]+1);\n                }\n            }\n        // if (dp )\n        if (dp[T] > 800) return -1;\n        return dp[T];\n        // }\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111"}, {"id": 272858370, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571929939, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/272858370/", "is_pending": "Not Pending", "title": "Video Stitching", "memory": "N/A", "code": "class Solution {\npublic:\n    static bool mycomp(vector<int>&a,vector<int>&b){\n        return a[0] < b[0];\n    }\n    int videoStitching(vector<vector<int>>& clips, int T) {\n        sort(clips.begin(),clips.end(),mycomp);\n        vector<int>dp(T+2,1000);\n        dp[0] = 0;\n        // for(int i = 1;i < T;i ++){\n            for(int j = 0;j < clips.size(); j ++){\n                for(int k = clips[j][0];k <= clips[j][1] && k <= T;k ++){\n                    dp[k+1] = min(dp[k+1],dp[clips[j][0]]+1);\n                }\n            }\n        // if (dp )\n        if (dp[T+1] > 800) return -1;\n        return dp[T+1];\n        // }\n    }\n};", "compare_result": "1111100111111111111111111111111111111111111000001111"}, {"id": 272858008, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571929826, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/272858008/", "is_pending": "Not Pending", "title": "Video Stitching", "memory": "N/A", "code": "class Solution {\npublic:\n    static bool mycomp(vector<int>&a,vector<int>&b){\n        return a[0] < b[0];\n    }\n    int videoStitching(vector<vector<int>>& clips, int T) {\n        sort(clips.begin(),clips.end(),mycomp);\n        vector<int>dp(T+2,INT_MAX);\n        dp[0] = 0;\n        // for(int i = 1;i < T;i ++){\n            for(int j = 0;j < clips.size(); j ++){\n                for(int k = clips[j][0];k <= clips[j][1] && k <= T;k ++){\n                    dp[k+1] = min(dp[k+1],dp[clips[j][0]]+1);\n                }\n            }\n        return dp[T+1];\n        // }\n    }\n};", "compare_result": "1011000000000000000000000000000000000000000000000000"}, {"id": 272853446, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571928323, "status_display": "Accepted", "runtime": "180 ms", "url": "/submissions/detail/272853446/", "is_pending": "Not Pending", "title": "Maximum Length of Repeated Subarray", "memory": "106.3 MB", "code": "class Solution {\npublic:\n    int findLength(vector<int>& A, vector<int>& B) {\n        //dp[i][j] A[0,i) and B[0,j) same length\n        // we want dp[]\n        vector<vector<int> > dp(A.size()+1,vector<int>(B.size()+1,0));\n        int ret = 0;\n        for(int i = 1;i <= A.size(); i ++){\n            for(int j = 1;j <= B.size();j ++){\n                if(A[i-1] == B[j-1]){\n                    dp[i][j] = dp[i-1][j-1]+1;\n                    ret = max(ret,dp[i][j]);\n                }\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111"}, {"id": 272852226, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571927904, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/272852226/", "is_pending": "Not Pending", "title": "Target Sum", "memory": "8.7 MB", "code": "class Solution {\npublic:\n     int findTargetSumWays(vector<int>& nums, int S) {\n         long sumf = 0;\n         for(int i : nums){\n             sumf += i;\n         }\n         long t = (sumf + S)/2;\n         if ((sumf + S)%2 != 0 || sumf < S) return 0;\n         vector<int>dp(t+1,0);\n         dp[0] = 1;\n         for(int i = 0;i < nums.size();i ++){\n             for(int j = t;j >=nums[i];j --){\n                dp[j] += dp[j-nums[i]];\n             }\n         }\n         return dp[t];\n         \n     }\n    \n//     int findTargetSumWays(vector<int>& nums, int S) {\n//         // vector<vector<int> > dp(nums.size()+1,vector<int>(1002,0));\n//         vector<int> leaf(nums.size(),0);\n//         int sum = 0;\n//         for(int i = nums.size()-1;i >= 0;i --){\n//             sum += nums[i];\n//             leaf[i] = sum;\n//         }\n//         int total = 0;\n//         help(nums,leaf,S,0,0,total);\n//         return total;\n//     }\n//     void help(vector<int>& nums,vector<int>& leaf,int S,int idx,int T,int &total){\n//         if(idx >= nums.size()){\n//             if (T==S){\n//                 total += 1;\n//             }\n//             return;\n//         }\n        \n//         if (T + leaf[idx] < S || T - leaf[idx] > S){\n//             return;\n//         }\n//         help(nums,leaf,S,idx+1,T+nums[idx],total);\n//         help(nums,leaf,S,idx+1,T-nums[idx],total);\n//     }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 272852166, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571927881, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/272852166/", "is_pending": "Not Pending", "title": "Target Sum", "memory": "N/A", "code": "class Solution {\npublic:\n     int findTargetSumWays(vector<int>& nums, int S) {\n         int sumf = 0;\n         for(int i : nums){\n             sumf += i;\n         }\n         int t = (sumf + S)/2;\n         if ((sumf + S)%2 != 0 || sumf < S) return 0;\n         vector<int>dp(t+1,0);\n         dp[0] = 1;\n         for(int i = 0;i < nums.size();i ++){\n             for(int j = t;j >=nums[i];j --){\n                dp[j] += dp[j-nums[i]];\n             }\n         }\n         return dp[t];\n         \n     }\n    \n//     int findTargetSumWays(vector<int>& nums, int S) {\n//         // vector<vector<int> > dp(nums.size()+1,vector<int>(1002,0));\n//         vector<int> leaf(nums.size(),0);\n//         int sum = 0;\n//         for(int i = nums.size()-1;i >= 0;i --){\n//             sum += nums[i];\n//             leaf[i] = sum;\n//         }\n//         int total = 0;\n//         help(nums,leaf,S,0,0,total);\n//         return total;\n//     }\n//     void help(vector<int>& nums,vector<int>& leaf,int S,int idx,int T,int &total){\n//         if(idx >= nums.size()){\n//             if (T==S){\n//                 total += 1;\n//             }\n//             return;\n//         }\n        \n//         if (T + leaf[idx] < S || T - leaf[idx] > S){\n//             return;\n//         }\n//         help(nums,leaf,S,idx+1,T+nums[idx],total);\n//         help(nums,leaf,S,idx+1,T-nums[idx],total);\n//     }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000"}, {"id": 272851962, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571927814, "status_display": "Memory Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/272851962/", "is_pending": "Not Pending", "title": "Target Sum", "memory": "N/A", "code": "class Solution {\npublic:\n     int findTargetSumWays(vector<int>& nums, int S) {\n         int sumf = 0;\n         for(int i : nums){\n             sumf += i;\n         }\n         int t = (sumf + S)/2;\n         if ((sumf + S)%2 != 0) return 0;\n         vector<int>dp(t+1,0);\n         dp[0] = 1;\n         for(int i = 0;i < nums.size();i ++){\n             for(int j = t;j >=nums[i];j --){\n                dp[j] += dp[j-nums[i]];\n             }\n         }\n         return dp[t];\n         \n     }\n    \n//     int findTargetSumWays(vector<int>& nums, int S) {\n//         // vector<vector<int> > dp(nums.size()+1,vector<int>(1002,0));\n//         vector<int> leaf(nums.size(),0);\n//         int sum = 0;\n//         for(int i = nums.size()-1;i >= 0;i --){\n//             sum += nums[i];\n//             leaf[i] = sum;\n//         }\n//         int total = 0;\n//         help(nums,leaf,S,0,0,total);\n//         return total;\n//     }\n//     void help(vector<int>& nums,vector<int>& leaf,int S,int idx,int T,int &total){\n//         if(idx >= nums.size()){\n//             if (T==S){\n//                 total += 1;\n//             }\n//             return;\n//         }\n        \n//         if (T + leaf[idx] < S || T - leaf[idx] > S){\n//             return;\n//         }\n//         help(nums,leaf,S,idx+1,T+nums[idx],total);\n//         help(nums,leaf,S,idx+1,T-nums[idx],total);\n//     }\n};", "compare_result": "1111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 272848510, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571926619, "status_display": "Accepted", "runtime": "496 ms", "url": "/submissions/detail/272848510/", "is_pending": "Not Pending", "title": "Target Sum", "memory": "8.6 MB", "code": "class Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int S) {\n        // vector<vector<int> > dp(nums.size()+1,vector<int>(1002,0));\n        vector<int> leaf(nums.size(),0);\n        int sum = 0;\n        for(int i = nums.size()-1;i >= 0;i --){\n            sum += nums[i];\n            leaf[i] = sum;\n        }\n        int total = 0;\n        help(nums,leaf,S,0,0,total);\n        return total;\n    }\n    void help(vector<int>& nums,vector<int>& leaf,int S,int idx,int T,int &total){\n        if(idx >= nums.size()){\n            if (T==S){\n                total += 1;\n            }\n            return;\n        }\n        \n        if (T + leaf[idx] < S || T - leaf[idx] > S){\n            return;\n        }\n        help(nums,leaf,S,idx+1,T+nums[idx],total);\n        help(nums,leaf,S,idx+1,T-nums[idx],total);\n        \n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 272842326, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571924300, "status_display": "Accepted", "runtime": "12 ms", "url": "/submissions/detail/272842326/", "is_pending": "Not Pending", "title": "Largest Sum of Averages", "memory": "9.3 MB", "code": "class Solution {\npublic:\n    double largestSumOfAverages(vector<int>& A, int K) {\n        vector<double> sumf(A.size()+1,0);\n        for(int i = 0;i < A.size();i ++){\n            sumf[i+1] = sumf[i] + A[i];\n        }\n        vector<vector<double> > dp(A.size()+1,vector<double> (K+1,INT_MIN));\n        // dp[0][1] = 0;\n        dp[0][0] = 0;\n        // for(int i = 0;i < A.size();i ++){\n        //     dp[i+1][1] = dp[i][1] + A[i];\n        // }\n        \n        for(int i =1;i <= A.size();i ++){\n            for(int k = 1;k <= K;k ++){\n                for(int j = 0;j < i;j ++){\n                    dp[i][k] = max(dp[i][k],dp[j][k-1]+(sumf[i]-sumf[j])/(i-j));\n                }\n            }\n        }\n        return dp[A.size()][K];\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111"}, {"id": 272825491, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571915398, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/272825491/", "is_pending": "Not Pending", "title": "Delete and Earn", "memory": "11 MB", "code": "class Solution {\npublic:\n    int deleteAndEarn(vector<int>& nums) {\n        // map<int,int> excludes;\n        // return help(nums,0,excludes);\n        // vector<int> dp \n        vector<int> sumf(10001,0);\n        for(int num: nums){\n            sumf[num] += num;\n        }\n        int take =0;\n        int skip = 0;\n        for(int i = 0;i < 10001;i ++){\n            int tmp_take = skip + sumf[i];\n            int tmp_skip = max(skip,take);\n            take = tmp_take;\n            skip = tmp_skip;\n        }\n        return max(take,skip);\n    }\n    \n    int help(vector<int>& nums,int idx,map<int,int>& excludes){\n        if(idx >= nums.size()) return 0;\n        int gain = help(nums,idx+1,excludes);\n        int cur = nums[idx];\n        if(excludes[cur] == 0){\n            excludes[cur-1] ++;\n            excludes[cur+1] ++;\n            gain = max(gain,help(nums,idx+1,excludes) +cur );\n            excludes[cur-1] --;\n            excludes[cur+1] --;\n        }\n        return gain;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111"}, {"id": 272823504, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571914030, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/272823504/", "is_pending": "Not Pending", "title": "Delete and Earn", "memory": "N/A", "code": "class Solution {\npublic:\n    int deleteAndEarn(vector<int>& nums) {\n        map<int,int> excludes;\n        return help(nums,0,excludes);\n    }\n    \n    int help(vector<int>& nums,int idx,map<int,int>& excludes){\n        if(idx >= nums.size()) return 0;\n        int gain = help(nums,idx+1,excludes);\n        int cur = nums[idx];\n        if(excludes[cur] == 0){\n            excludes[cur-1] ++;\n            excludes[cur+1] ++;\n            gain = max(gain,help(nums,idx+1,excludes) +cur );\n            excludes[cur-1] --;\n            excludes[cur+1] --;\n                \n        }\n        return gain;\n    }\n};", "compare_result": "1111111111111100000000000000000000000000000000"}, {"id": 272821914, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571912967, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/272821914/", "is_pending": "Not Pending", "title": "Predict the Winner", "memory": "8.5 MB", "code": "class Solution {\npublic:\n    bool PredictTheWinner(vector<int>& nums) {\n        int n = nums.size();\n        //dp[i][j] can win between [i,j]\n        //we want get dp[0][n-1];\n        //dp[i][j] = max(pi-dp[i+1][j],pj-dp[i][j-1]);\n        vector<vector<int> > dp(n,vector<int>(n,INT_MAX));\n        for(int i = 0;i < n;i ++){\n            dp[i][i] = nums[i];\n        }\n        for(int j = 1;j < n;j++){\n            for(int i = j-1;i >= 0;i--){\n                dp[i][j] = max(nums[i]-dp[i+1][j],nums[j]-dp[i][j-1]);\n            }\n        }\n        return dp[0][n-1] >= 0;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111"}, {"id": 272821831, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571912909, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/272821831/", "is_pending": "Not Pending", "title": "Predict the Winner", "memory": "N/A", "code": "class Solution {\npublic:\n    bool PredictTheWinner(vector<int>& nums) {\n        int n = nums.size();\n        //dp[i][j] can win between [i,j]\n        //we want get dp[0][n-1];\n        //dp[i][j] = max(pi-dp[i+1][j],pj-dp[i][j-1]);\n        vector<vector<int> > dp(n,vector<int>(n,INT_MAX));\n        for(int i = 0;i < n;i ++){\n            dp[i][i] = nums[i];\n        }\n        for(int j = 1;j < n;j++){\n            for(int i = j-1;i >= 0;i--){\n                dp[i][j] = max(nums[i]-dp[i+1][j],nums[j]-dp[i][j-1]);\n            }\n        }\n        return dp[0][n-1] > 0;\n    }\n};", "compare_result": "1101011111111111111111111111111111111111100011001111111111111"}, {"id": 272820288, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571911882, "status_display": "Accepted", "runtime": "40 ms", "url": "/submissions/detail/272820288/", "is_pending": "Not Pending", "title": "Length of Longest Fibonacci Subsequence", "memory": "61.4 MB", "code": "class Solution {\npublic:\n    int lenLongestFibSubseq_v1(vector<int>& A) {\n        //dp[i][k]\n        vector<unordered_map<int,int> > dp(A.size(),unordered_map<int,int>());\n        if(A.size() <= 2) return 0;\n        // cout << A.size() << endl;\n        int ret = 0; \n        dp[1][A[0]] = 1;\n        int sz = A.size();\n        int gap  = A[A.size()-1] -A[0];\n        for(int i = 2;i <sz;i ++){\n            for(int j = 0;j <i;j ++){\n                int dif = A[i]-A[j];\n                dp[i][A[j]] = 1;\n                int tmid = dp[j][dif];\n                if(tmid >0){\n                    dp[i][A[j]] = max(1,tmid+1);\n                }\n                ret= max(dp[i][A[j]],ret);\n            }\n        }\n        if(ret < 2) return 0;\n        return ret+1;\n    }\n    \n    int lenLongestFibSubseq(vector<int>& A) {\n        //dp[i][k]\n        \n        if(A.size() <= 2) return 0;\n        //dp[i][j] max subsequence end with A[i],A[j];\n        vector<vector<int> >dp(A.size(),vector<int>(A.size(),1));\n        \n        int ret = 0; \n        for(int i = 2;i < A.size();i ++){\n            int l = 0;\n            int r = i-1;\n            while(l < r){\n                int sum = A[l] + A[r];\n                // cout << sum << endl;\n                // dp[r][i] = 1;\n                if(sum < A[i]){\n                    l ++;\n                }else if (sum > A[i]){\n                    r --;\n                }else{\n                    dp[r][i] = max(1,dp[l][r]+1);\n                    // cout <<  dp[r][i] << endl;\n                    ret = max(dp[r][i],ret);\n                    l ++;\n                    r --;\n                }\n            }\n        }\n        \n        \n        if(ret < 2) return 0;\n        return ret+1;\n    }\n};", "compare_result": "111111111111111111111111111111111"}, {"id": 272817971, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571910567, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/272817971/", "is_pending": "Not Pending", "title": "Length of Longest Fibonacci Subsequence", "memory": "N/A", "code": "class Solution {\npublic:\n    int lenLongestFibSubseq(vector<int>& A) {\n        //dp[i][k]\n        vector<unordered_map<int,int> > dp(A.size(),unordered_map<int,int>());\n        if(A.size() <= 2) return 0;\n        // cout << A.size() << endl;\n        int ret = 0; \n        dp[1][A[0]] = 1;\n        int sz = A.size();\n        for(int i = 2;i <sz;i ++){\n            for(int j = 0;j <i;j ++){\n                int dif = A[i]-A[j];\n                if(dif > sz){\n                    break;\n                }\n                dp[i][A[j]] = 1;\n                int tmid = dp[j][dif];\n                if(tmid >0){\n                    dp[i][A[j]] = max(1,tmid+1);\n                }\n                ret= max(dp[i][A[j]],ret);\n            }\n        }\n        if(ret < 2) return 0;\n        return ret+1;\n    }\n};", "compare_result": "100000000110000000000000000000000"}, {"id": 272817764, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571910470, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/272817764/", "is_pending": "Not Pending", "title": "Length of Longest Fibonacci Subsequence", "memory": "N/A", "code": "class Solution {\npublic:\n    int lenLongestFibSubseq(vector<int>& A) {\n        //dp[i][k]\n        vector<unordered_map<int,int> > dp(A.size(),unordered_map<int,int>());\n        if(A.size() <= 2) return 0;\n        // cout << A.size() << endl;\n        int ret = 0; \n        dp[1][A[0]] = 1;\n        for(int i = 2;i <A.size();i ++){\n            for(int j = 0;j <i;j ++){\n                int dif = A[i]-A[j];\n                dp[i][A[j]] = 1;\n                int tmid = dp[j][dif];\n                if(tmid >0){\n                    dp[i][A[j]] = max(1,tmid+1);\n                }\n                ret= max(dp[i][A[j]],ret);\n            }\n        }\n        if(ret < 2) return 0;\n        return ret+1;\n    }\n};", "compare_result": "111111111111111111111111111000000"}, {"id": 272817350, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571910268, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/272817350/", "is_pending": "Not Pending", "title": "Length of Longest Fibonacci Subsequence", "memory": "N/A", "code": "class Solution {\npublic:\n    int lenLongestFibSubseq(vector<int>& A) {\n        //dp[i][k]\n        vector<unordered_map<int,int> > dp(A.size(),unordered_map<int,int>());\n        if(A.size() <= 2) return 0;\n        int ret = 0;\n        dp[1][A[0]] = 1;\n        for(int i = 2;i <A.size();i ++){\n            for(int j = 0;j <i;j ++){\n                int dif = A[i]-A[j];\n                dp[i][A[j]] = 1;\n                if(dp[j][dif] >0){\n                    dp[i][A[j]] = max(dp[i][A[j]],dp[j][dif]+1);\n                }\n                ret= max(dp[i][A[j]],ret);\n            }\n        }\n        if(ret < 2) return 0;\n        return ret+1;\n    }\n};", "compare_result": "111111111111111111111111111100000"}, {"id": 272817036, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571910089, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/272817036/", "is_pending": "Not Pending", "title": "Length of Longest Fibonacci Subsequence", "memory": "N/A", "code": "class Solution {\npublic:\n    int lenLongestFibSubseq(vector<int>& A) {\n        //dp[i][k]\n        vector<unordered_map<int,int> > dp(A.size(),unordered_map<int,int>());\n        if(A.size() <= 2) return 0;\n        int ret = 0;\n        dp[1][A[0]] = 1;\n        for(int i = 2;i <A.size();i ++){\n            for(int j = 1;j <i;j ++){\n                int dif = A[i]-A[j];\n                dp[i][A[j]] = 1;\n                if(dp[j][dif] >0){\n                    dp[i][A[j]] = max(dp[i][A[j]],dp[j][dif]+1);\n                    ret= max(dp[i][A[j]],ret);\n                }\n            }\n        }\n        if(ret < 2) return 0;\n        return ret+1;\n    }\n};", "compare_result": "111111011111101111111111111100000"}, {"id": 272814570, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571908774, "status_display": "Accepted", "runtime": "24 ms", "url": "/submissions/detail/272814570/", "is_pending": "Not Pending", "title": "2 Keys Keyboard", "memory": "8.5 MB", "code": "class Solution {\npublic:\n    int minSteps(int n) {\n        //dp[i][0] min,times;\n        //dp[i][1] nums last copyed\n        //dp[1][0] = 0\n        //dp[1][1] = 1;\n        // vector<vector<int> > dp(n+1,vector<int>(2,INT_MAX));\n        // dp[1][0] = 1;\n        // dp[1][1] = 1;\n        // for(int i = 2;i <= n;i ++){\n        //     if (i%2 ==0){\n        //         if(dp[i][0] < dp[i/2][0] +1){\n        //             dp[i][0] = dp[i/2][0] +1;\n        //             dp[i][1] = dp[i/2][0];\n        //         } \n        //     }\n        //     for(int k = 1;k < i;k ++){\n        //         if((k + dp[k][1] == i) && (dp[k][0] + 1 <= dp[i][0])){\n        //             if(dp[k][0] + 1 < dp[i][0] || dp[k][1] < dp[i][1]){\n        //                 dp[i][0] = dp[k][0] + 1;\n        //                 dp[i][1] = dp[k][1];\n        //             }\n        //         }\n        //     }\n        // }\n        // return dp[n][0];\n        if(n <= 1) return 0;\n        return help(n,1,1)+1;\n    }\n    \n    int help(int target,int cur,int last){\n        if(cur == target){\n            return 0;\n        }\n        if(cur > target ) {\n            return -1;\n        }\n        int ret = -1;\n        if(2*cur <= target){\n            int tmp = help(target,2*cur,cur);\n            if(tmp >= 0){\n                ret = tmp +2;\n            }\n        }\n        \n        if (cur + last <= target){\n            int tmp = help(target,cur + last,last);\n            if (tmp >= 0){\n                tmp += 1;\n                if(ret < 0){\n                    ret = tmp;\n                }else{\n                    ret = min(ret,tmp) ;\n                }\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 272814504, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571908742, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/272814504/", "is_pending": "Not Pending", "title": "2 Keys Keyboard", "memory": "N/A", "code": "class Solution {\npublic:\n    int minSteps(int n) {\n        //dp[i][0] min,times;\n        //dp[i][1] nums last copyed\n        //dp[1][0] = 0\n        //dp[1][1] = 1;\n        // vector<vector<int> > dp(n+1,vector<int>(2,INT_MAX));\n        // dp[1][0] = 1;\n        // dp[1][1] = 1;\n        // for(int i = 2;i <= n;i ++){\n        //     if (i%2 ==0){\n        //         if(dp[i][0] < dp[i/2][0] +1){\n        //             dp[i][0] = dp[i/2][0] +1;\n        //             dp[i][1] = dp[i/2][0];\n        //         } \n        //     }\n        //     for(int k = 1;k < i;k ++){\n        //         if((k + dp[k][1] == i) && (dp[k][0] + 1 <= dp[i][0])){\n        //             if(dp[k][0] + 1 < dp[i][0] || dp[k][1] < dp[i][1]){\n        //                 dp[i][0] = dp[k][0] + 1;\n        //                 dp[i][1] = dp[k][1];\n        //             }\n        //         }\n        //     }\n        // }\n        // return dp[n][0];\n        return help(n,1,1)+1;\n    }\n    \n    int help(int target,int cur,int last){\n        if(cur == target){\n            return 0;\n        }\n        if(cur > target ) {\n            return -1;\n        }\n        int ret = -1;\n        if(2*cur <= target){\n            int tmp = help(target,2*cur,cur);\n            if(tmp >= 0){\n                ret = tmp +2;\n            }\n        }\n        \n        if (cur + last <= target){\n            int tmp = help(target,cur + last,last);\n            if (tmp >= 0){\n                tmp += 1;\n                if(ret < 0){\n                    ret = tmp;\n                }else{\n                    ret = min(ret,tmp) ;\n                }\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 272809305, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571906316, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/272809305/", "is_pending": "Not Pending", "title": "Shopping Offers", "memory": "9 MB", "code": "class Solution {\npublic:\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\n        int ret = 0;\n        for(int i =0;i <price.size();i ++){\n            ret += needs[i]*price[i];\n        }\n        \n        for(int i  =0;i < special.size();i ++){\n            if(can(needs,special[i])){\n                for(int j = 0;j < needs.size();j ++){\n                    needs[j] -= special[i][j];\n                }\n                \n                ret = min(ret,special[i][needs.size()]+shoppingOffers(price,special,needs));\n                for(int j = 0;j < needs.size();j ++){\n                    needs[j] += special[i][j];\n                }\n            }\n        }\n        return ret;\n    }\n    \n    int can(vector<int>& needs,vector<int>&offer){\n        for(int i = 0;i < needs.size();i++){\n            if(needs[i] < offer[i]){\n                return false;\n            }\n        }\n        return true;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111"}, {"id": 272808339, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571905893, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/272808339/", "is_pending": "Not Pending", "title": "Number of Dice Rolls With Target Sum", "memory": "8.9 MB", "code": "class Solution {\npublic:\n    const static int md=pow(10,9)+7;\n    int numRollsToTarget(int d, int f, int target) {\n        if(d*f < target) return 0;\n        //dp[i][j] with dice i and target j\n        //we want dice[n][target];\n        vector<vector<int> > dp(d+1,vector<int>(target+1,0));\n        dp[0][0] =1;\n        for(int i = 1;i <= d;i ++){\n            for(int j = 1;j <= target;j ++){\n                for(int k = 1;k <= f && j-k >=0;k ++){\n                    if(dp[i-1][j-k] > 0){\n                        dp[i][j]  = (dp[i-1][j-k] + dp[i][j] )%md;\n                    }\n                    // dp[i][j] =((max(dp[i-1][j-k],0))%md + dp[i][j]%md)%md ;\n                }\n            }\n        }\n        \n        return dp[d][target];\n        \n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111"}, {"id": 272573316, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571849309, "status_display": "Accepted", "runtime": "0 ms", "url": "/submissions/detail/272573316/", "is_pending": "Not Pending", "title": "Count Numbers with Unique Digits", "memory": "8.3 MB", "code": "class Solution {\npublic:\n    int countNumbersWithUniqueDigits(int n) {\n        if (n <1) return 1;\n        \n        int res = 10;\n        int avaliable = 9;\n        int tsm = 9;\n        while (n-- >1 && avaliable > 0){\n            tsm *= avaliable;\n            avaliable --;\n            res += tsm;\n        }\n        return res;\n    }\n};", "compare_result": "111111111"}, {"id": 272573159, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571849262, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/272573159/", "is_pending": "Not Pending", "title": "Count Numbers with Unique Digits", "memory": "N/A", "code": "class Solution {\npublic:\n    int countNumbersWithUniqueDigits(int n) {\n        if (n <=1) return 0;\n        \n        int res = 10;\n        int avaliable = 9;\n        int tsm = 9;\n        while (n-- >1 && avaliable > 0){\n            tsm *= avaliable;\n            avaliable --;\n            res += tsm;\n        }\n        return res;\n    }\n};", "compare_result": "100111111"}, {"id": 272573057, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571849234, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/272573057/", "is_pending": "Not Pending", "title": "Count Numbers with Unique Digits", "memory": "N/A", "code": "class Solution {\npublic:\n    int countNumbersWithUniqueDigits(int n) {\n        // if (n > 10) return 0;\n        \n        int res = 10;\n        int avaliable = 9;\n        int tsm = 9;\n        while (n-- >1 && avaliable > 0){\n            tsm *= avaliable;\n            avaliable --;\n            res += tsm;\n        }\n        return res;\n    }\n};", "compare_result": "101111111"}, {"id": 272567831, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571847774, "status_display": "Accepted", "runtime": "0 ms", "url": "/submissions/detail/272567831/", "is_pending": "Not Pending", "title": "Integer Break", "memory": "8.5 MB", "code": "class Solution {\npublic:\n    int integerBreak(int n) {\n        vector<int>dp(n+6,0);\n        dp[0] = 1;\n        dp[1] = 1;\n        \n        // dp[2] = 1;\n        // dp[3] = 2;\n        // dp[4] = 4;\n        // dp[5] = 6;\n        for(int j =2;j <= n;j ++){\n            for(int i = 1;i <j;i ++){\n                dp[j] = max(dp[i]*(j-i),dp[j]);\n                dp[j] = max(dp[j],i*(j-i));\n            }\n        }\n        return dp[n];\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111"}, {"id": 272567626, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571847713, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/272567626/", "is_pending": "Not Pending", "title": "Integer Break", "memory": "N/A", "code": "class Solution {\npublic:\n    int integerBreak(int n) {\n        vector<int>dp(n+6,0);\n        dp[0] = 1;\n        dp[1] = 1;\n        // dp[2] = 1;\n        // dp[3] = 2;\n        // dp[4] = 4;\n        // dp[5] = 6;\n        for(int j =2;j <= n;j ++){\n            for(int i = 0;i <j;i ++){\n                dp[j] = max(dp[i]*(j-i),dp[j]);\n                dp[j] = max(dp[j],i*(j-i));\n            }\n        }\n        return dp[n];\n    }\n};", "compare_result": "01011111111111111111111111111111111111111111111111"}, {"id": 272567511, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571847683, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/272567511/", "is_pending": "Not Pending", "title": "Integer Break", "memory": "N/A", "code": "class Solution {\npublic:\n    int integerBreak(int n) {\n        vector<int>dp(n+6,0);\n        dp[0] = 1;\n        dp[1] = 1;\n        // dp[2] = 1;\n        // dp[3] = 2;\n        // dp[4] = 4;\n        // dp[5] = 6;\n        for(int j =2;j <= n;j ++){\n            for(int i = 0;i <j;i ++){\n                dp[j] = max(dp[i]*(j-i),i*(j-i));\n            }\n        }\n        return dp[n];\n    }\n};", "compare_result": "10100000000000000000000000000000000000000000000000"}, {"id": 272567255, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571847610, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/272567255/", "is_pending": "Not Pending", "title": "Integer Break", "memory": "N/A", "code": "class Solution {\npublic:\n    int integerBreak(int n) {\n        vector<int>dp(n+6,0);\n        dp[0] = 1;\n        dp[1] = 1;\n        dp[2] = 1;\n        dp[3] = 2;\n        dp[4] = 4;\n        dp[5] = 6;\n        for(int j = 6;j <= n;j ++){\n            for(int i = 0;i <j;i ++){\n                dp[j] = max(dp[i]*(j-i),dp[j]);\n            }\n        }\n        return dp[n];\n    }\n};", "compare_result": "11111011010110110110110110110110110110110110110110"}, {"id": 272566676, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571847442, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/272566676/", "is_pending": "Not Pending", "title": "Integer Break", "memory": "N/A", "code": "class Solution {\npublic:\n    int integerBreak(int n) {\n        vector<int>dp(n+3,0);\n        dp[0] = 1;\n        dp[1] = 1;\n        dp[2] = 1;\n        dp[3] = 2;\n        for(int j = 4;j <= n;j ++){\n            for(int i = 0;i <j;i ++){\n                dp[j] = max(dp[i]*(j-i),dp[j]);\n            }\n        }\n        return dp[n];\n    }\n};", "compare_result": "11110010000100100100100100100100100100100100100100"}, {"id": 272566634, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571847429, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/272566634/", "is_pending": "Not Pending", "title": "Integer Break", "memory": "N/A", "code": "class Solution {\npublic:\n    int integerBreak(int n) {\n        vector<int>dp(n+3,0);\n        dp[0] = 1;\n        dp[1] = 1;\n        dp[2] = 1;\n        dp[3] = 1;\n        for(int j = 3;j <= n;j ++){\n            for(int i = 0;i <j;i ++){\n                dp[j] = max(dp[i]*(j-i),dp[j]);\n            }\n        }\n        return dp[n];\n    }\n};", "compare_result": "11011111111111111111111111111111111111111111111111"}, {"id": 272566584, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571847416, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/272566584/", "is_pending": "Not Pending", "title": "Integer Break", "memory": "N/A", "code": "class Solution {\npublic:\n    int integerBreak(int n) {\n        vector<int>dp(n+3,0);\n        dp[0] = 1;\n        dp[1] = 1;\n        dp[3] = 1;\n        for(int j = 3;j <= n;j ++){\n            for(int i = 0;i <j;i ++){\n                dp[j] = max(dp[i]*(j-i),dp[j]);\n            }\n        }\n        return dp[n];\n    }\n};", "compare_result": "01011111111111111111111111111111111111111111111111"}, {"id": 272565886, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571847209, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/272565886/", "is_pending": "Not Pending", "title": "Integer Break", "memory": "N/A", "code": "class Solution {\npublic:\n    int integerBreak(int n) {\n        vector<int>dp(n+2,0);\n        dp[0] = 1;\n        dp[1] = 1;\n        dp[2] = 1;\n        for(int j = 3;j <= n;j ++){\n            for(int i = 0;i <j;i ++){\n                dp[j] = max(dp[i]*(j-i),dp[j]);\n            }\n        }\n        return dp[n];\n    }\n};", "compare_result": "11011111111111111111111111111111111111111111111111"}, {"id": 272565660, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571847140, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/272565660/", "is_pending": "Not Pending", "title": "Integer Break", "memory": "N/A", "code": "class Solution {\npublic:\n    int integerBreak(int n) {\n        vector<int>dp(n+1,0);\n        dp[0] = 1;\n        dp[1] = 1;\n        for(int j = 2;j <= n;j ++){\n            for(int i = 0;i <j;i ++){\n                dp[j] = max(dp[i]*(j-i),dp[j]);\n            }\n        }\n        return dp[n];\n    }\n};", "compare_result": "01011111111111111111111111111111111111111111111111"}, {"id": 272563708, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571846583, "status_display": "Accepted", "runtime": "0 ms", "url": "/submissions/detail/272563708/", "is_pending": "Not Pending", "title": "Unique Binary Search Trees", "memory": "8.4 MB", "code": "class Solution {\npublic:\n    int numTrees(int n) {\n        vector<int> dp(n+1,0);\n        dp[1] = 1;\n        dp[0] = 1;\n        for(int i = 2;i <= n;i ++){\n            for(int j =0;j <i;j ++){\n                dp[i] += dp[j] * dp[i-j-1];\n            }\n            // cout << i << dp[i]  << endl;\n        }\n        return dp[n];\n    }\n};", "compare_result": "1111111111111111111"}, {"id": 272559703, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571845509, "status_display": "Accepted", "runtime": "84 ms", "url": "/submissions/detail/272559703/", "is_pending": "Not Pending", "title": "Longest Palindromic Subsequence", "memory": "69.2 MB", "code": "class Solution {\npublic:\n    int longestPalindromeSubseq(string s) {\n        int sz = s.size();\n        //dp[i][j] max subsquence [j,i]\n        // we want get dp[sz-1][0];\n        vector<vector<int> > dp(sz,vector<int>(sz ,0 ));\n        for(int i = 0;i < sz;i ++){\n            dp[i][i] = 1;\n        }\n        for(int i = 1;i < sz;i++){\n            for(int j = i-1;j >=0;j --){\n                if(s[i]==s[j]){\n                    if(i-1 < j+1){\n                        dp[i][j] = 2;\n                    }else{\n                        dp[i][j] = max(dp[i][j],dp[i-1][j+1]+2);\n                    }\n                }else{\n                    dp[i][j] = max(dp[i][j+1],dp[i-1][j]);\n                }\n            }\n        }\n        \n        return dp[sz-1][0];\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 272553197, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571843669, "status_display": "Accepted", "runtime": "12 ms", "url": "/submissions/detail/272553197/", "is_pending": "Not Pending", "title": "Minimum Path Sum", "memory": "10.8 MB", "code": "class Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        if(grid.size() <= 0){\n            return 0;\n        }\n        int m = grid.size();\n        int n = grid[0].size();\n        vector< vector<int> > dp(m, vector<int>(n,INT_MAX));\n        dp[0][0] = grid[0][0];\n        for(int i = 1;i < n;i ++){\n            dp[0][i] = dp[0][i-1] + grid[0][i];\n        }\n        \n        for(int i = 1;i < m;i ++){\n            dp[i][0] = dp[i-1][0] + grid[i][0];\n        }\n        \n        for(int i = 1;i < m;i ++){\n            for(int j = 1;j < n;j ++){\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j];\n            }\n        }\n        return dp[m-1][n-1];\n        \n        \n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111"}, {"id": 272235835, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571757143, "status_display": "Accepted", "runtime": "908 ms", "url": "/submissions/detail/272235835/", "is_pending": "Not Pending", "title": "Longest String Chain", "memory": "271.2 MB", "code": "class Solution {\npublic:\n    static bool compare(string a,string b)\n    {\n      return a.size()<b.size(); \n    }\n    int longestStrChain(vector<string>& words) {\n        sort(words.begin(),words.end(),compare);\n        // for(int i = 0;i <  words.size();i ++){\n        //     cout << words[i] << \"\\t\";\n        // }\n        int ret = 1;\n        vector<int> dp(words.size(),1);\n        for(int i = 1;i < words.size();i ++){\n            for(int j = 0;j < i;j ++){\n                if(isPredecessor(words[j],words[i])){\n                    dp[i] = max(dp[i],dp[j]+1);\n                    ret = max(dp[i],ret);\n                }\n            }\n        }\n        return ret;\n    }\n    \n    // a is a predecessor of b\n    bool isPredecessor(string&a,string&b){\n        if (a.size() + 1 != b.size()){\n            return false;\n        }\n        unordered_map<char,int> mp;\n        for(int i = 0;i < b.size();i ++){\n            mp[b[i]] += 1;\n        }\n        for(int i = 0;i < a.size();i ++){\n            mp[a[i]] -=1;\n            if(mp[a[i]] < 0){\n                return false;\n            }\n        }\n        return true;\n        \n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 272235756, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571757119, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/272235756/", "is_pending": "Not Pending", "title": "Longest String Chain", "memory": "N/A", "code": "class Solution {\npublic:\n    static bool compare(string a,string b)\n    {\n      return a.size()<b.size(); \n    }\n    int longestStrChain(vector<string>& words) {\n        sort(words.begin(),words.end(),compare);\n        for(int i = 0;i <  words.size();i ++){\n            cout << words[i] << \"\\t\";\n        }\n        int ret = 0;\n        vector<int> dp(words.size(),1);\n        for(int i = 1;i < words.size();i ++){\n            for(int j = 0;j < i;j ++){\n                if(isPredecessor(words[j],words[i])){\n                    dp[i] = max(dp[i],dp[j]+1);\n                    ret = max(dp[i],ret);\n                }\n            }\n        }\n        return ret;\n    }\n    \n    // a is a predecessor of b\n    bool isPredecessor(string&a,string&b){\n        if (a.size() + 1 != b.size()){\n            return false;\n        }\n        unordered_map<char,int> mp;\n        for(int i = 0;i < b.size();i ++){\n            mp[b[i]] += 1;\n        }\n        for(int i = 0;i < a.size();i ++){\n            mp[a[i]] -=1;\n            if(mp[a[i]] < 0){\n                return false;\n            }\n        }\n        return true;\n        \n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111110000000000"}, {"id": 272235332, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571756993, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/272235332/", "is_pending": "Not Pending", "title": "Longest String Chain", "memory": "N/A", "code": "class Solution {\npublic:\n    static bool compare(string a,string b)\n    {\n      return a.size()<b.size(); \n    }\n    int longestStrChain(vector<string>& words) {\n        sort(words.begin(),words.end(),compare);\n        for(int i = 0;i <  words.size();i ++){\n            cout << words[i] << \"\\t\";\n        }\n        vector<int> dp(words.size(),1);\n        for(int i = 1;i < words.size();i ++){\n            for(int j = 0;j < i;j ++){\n                if(isPredecessor(words[j],words[i])){\n                    dp[i] = max(dp[i],dp[j]+1);\n                }\n            }\n        }\n        return dp[words.size()-1];\n    }\n    \n    // a is a predecessor of b\n    bool isPredecessor(string&a,string&b){\n        if (a.size() + 1 != b.size()){\n            return false;\n        }\n        unordered_map<char,int> mp;\n        for(int i = 0;i < b.size();i ++){\n            mp[b[i]] += 1;\n        }\n        for(int i = 0;i < a.size();i ++){\n            mp[a[i]] -=1;\n            if(mp[a[i]] < 0){\n                return false;\n            }\n        }\n        return true;\n        \n    }\n};", "compare_result": "11000101111000000011001000110101000000001100000011100000000001111111111"}, {"id": 272234334, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571756692, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/272234334/", "is_pending": "Not Pending", "title": "Longest String Chain", "memory": "N/A", "code": "class Solution {\npublic:\n    int longestStrChain(vector<string>& words) {\n        vector<int> dp(words.size(),1);\n        for(int i = 1;i < words.size();i ++){\n            for(int j = 0;j < i;j ++){\n                if(isPredecessor(words[j],words[i])){\n                    dp[i] = max(dp[i],dp[j]+1);\n                }\n            }\n        }\n        return dp[words.size()-1];\n    }\n    \n    // a is a predecessor of b\n    bool isPredecessor(string&a,string&b){\n        if (a.size() + 1 != b.size()){\n            return false;\n        }\n        unordered_map<char,int> mp;\n        for(int i = 0;i < b.size();i ++){\n            mp[b[i]] += 1;\n        }\n        for(int i = 0;i < a.size();i ++){\n            mp[a[i]] -=1;\n            if(mp[a[i]] < 0){\n                return false;\n            }\n        }\n        return true;\n        \n    }\n};", "compare_result": "10000000000000000000000000000000000000000000000000000000000001111111111"}, {"id": 272231618, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571755843, "status_display": "Accepted", "runtime": "1560 ms", "url": "/submissions/detail/272231618/", "is_pending": "Not Pending", "title": "Longest Arithmetic Sequence", "memory": "184.4 MB", "code": "class Solution {\npublic:\n    int longestArithSeqLength(vector<int>& A) {\n        int n = A.size();\n        int ret = 2;\n        vector<unordered_map<int,int> > dp(n,unordered_map<int,int>());\n        for(int i = 1;i < n;i ++){\n            for(int j = 0;j < i;j ++){\n                int dif = A[i]- A[j];\n                if(dp[j].find(dif) == dp[j].end()){\n                    dp[i][dif] = 2;\n                }else{\n                    dp[i][dif] = dp[j][dif] +1;\n                }\n                ret = max(ret,dp[i][dif]);\n            }\n        }\n        return ret;\n    }\n};", "compare_result": "11111111111111111111111111111111111"}, {"id": 272226464, "lang": "cpp", "time": "2\u00a0months, 1\u00a0week", "timestamp": 1571754239, "status_display": "Accepted", "runtime": "24 ms", "url": "/submissions/detail/272226464/", "is_pending": "Not Pending", "title": "Minimum Cost Tree From Leaf Values", "memory": "9.1 MB", "code": "class Solution {\npublic:\n    int mctFromLeafValues(vector<int>& arr) {\n        //dp[i][j] max value between [i,j]\n        //we want dp[0][arr.size()-1];\n        vector<vector<int> > dp(arr.size(),vector<int>(arr.size(),INT_MAX)); \n        for(int i =0;i < arr.size(); i ++){\n            dp[i][i] = 0;\n        }\n        for(int i =arr.size()-1;i >=0;i --){\n            for(int j = i+1;j < arr.size();j ++){\n                for(int k = i;k < j;k ++){\n                    dp[i][j] = min(dp[i][j],dp[i][k] + dp[k+1][j] + getMax(arr,i,k)*getMax(arr,k+1,j) );\n                }\n            }\n        }\n        return dp[0][arr.size()-1];\n        \n    }\n    \n    int getMax(vector<int>& arr,int start,int end){\n        int ma = arr[start];\n        for(int i = start;i <= end;i ++){\n            ma = max(ma,arr[i]);\n        }\n        return ma;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 271931821, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571675463, "status_display": "Accepted", "runtime": "0 ms", "url": "/submissions/detail/271931821/", "is_pending": "Not Pending", "title": "Airplane Seat Assignment Probability", "memory": "8.4 MB", "code": "class Solution {\npublic:\n    double nthPersonGetsNthSeat(int n) {\n        return n>1 ? 0.5:1;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 271927254, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571674156, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/271927254/", "is_pending": "Not Pending", "title": "Airplane Seat Assignment Probability", "memory": "N/A", "code": "class Solution {\npublic:\n    double nthPersonGetsNthSeat(int n) {\n        return 1.0/n;\n    }\n};", "compare_result": "1100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 271926275, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571673891, "status_display": "Accepted", "runtime": "12 ms", "url": "/submissions/detail/271926275/", "is_pending": "Not Pending", "title": "Stone Game", "memory": "17.2 MB", "code": "class Solution {\npublic:\n    bool stoneGame(vector<int>& piles) {\n        int psize = piles.size();\n        //dp[i][j],alex get maximum between[i,j)\n        //and we want get dp[0][psize];\n        vector<vector<int> > dp(psize,vector<int>(psize,0));\n        for(int i =0;i <psize; i ++){\n            dp[i][i] = piles[i];\n        }\n        \n        for(int d = 1; d < psize; d ++){\n            for(int i = 0;i < psize - d;i ++ ){\n                dp[i][i+d] = max(piles[i] - dp[i+1][i+d],piles[i+d]-dp[i][i+d-1]);\n            }\n        }\n        \n        return dp[0][psize-1] > 0;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111"}, {"id": 271910424, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571669503, "status_display": "Accepted", "runtime": "16 ms", "url": "/submissions/detail/271910424/", "is_pending": "Not Pending", "title": "Stone Game II", "memory": "9 MB", "code": "class Solution {\npublic:\n    int stoneGameII(vector<int>& piles) {\n        int psize = piles.size();\n        vector<int> sumf(psize+1,0);\n        // dp[i][j] index i with M = j ,max alex get\n        // alex wants maximum dp[0][1]\n        vector<vector<int> > dp(psize+1,vector<int>(psize+1,0));\n        for(int i = psize-1; i >= 0;i --){\n            sumf[i] =  sumf[i+1] + piles[i];\n        }\n        \n        for(int i = 0;i <= psize;i ++){\n            dp[i][psize] = sumf[i];\n        }\n        \n        for(int i = psize-1;i >= 0; i --){\n            for(int j  = psize-1; j >= 1;j --){\n                for(int k = 1;k <= 2*j && i+k <= psize; k ++){\n                    dp[i][j] = max(dp[i][j],sumf[i]-dp[i+k][max(k,j)]);\n                }\n            }\n        }\n        return dp[0][1];\n    }\n};", "compare_result": "111111111111111111111"}, {"id": 271909715, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571669296, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/271909715/", "is_pending": "Not Pending", "title": "Stone Game II", "memory": "N/A", "code": "class Solution {\npublic:\n    int stoneGameII(vector<int>& piles) {\n        int psize = piles.size();\n        vector<int> sumf(psize+1,0);\n        // dp[i][j] index i with M = j ,max alex get\n        // alex wants maximum dp[0][1]\n        vector<vector<int> > dp(psize+1,vector<int>(psize+1,0));\n        for(int i = psize-1; i >= 0;i --){\n            sumf[i] =  sumf[i+1] + piles[i];\n        }\n        \n        for(int i = 0;i <= psize;i ++){\n            dp[i][psize] = sumf[i];\n        }\n        \n        for(int i = psize-1;i >= 0; i --){\n            for(int j  = psize; j >= 1;j --){\n                for(int k = 1;k <= 2*j && i+k < psize; k ++){\n                    dp[i][j] = max(dp[i][j],sumf[i]-dp[i+k][max(k,j)]);\n                }\n            }\n        }\n        return dp[0][1];\n    }\n};", "compare_result": "100100111111111111111"}, {"id": 271903998, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571667496, "status_display": "Accepted", "runtime": "12 ms", "url": "/submissions/detail/271903998/", "is_pending": "Not Pending", "title": "Longest Common Subsequence", "memory": "14.8 MB", "code": "class Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int sz1 = text1.size();\n        int sz2 = text2.size();\n        vector<vector<int> > dp(sz1+1,vector<int>(sz2+1,0));\n        for(int i = 1;i <= sz1;i ++){\n            for(int j = 1;j <= sz2;j ++){\n                if(text1[i-1] == text2[j-1]){\n                    dp[i][j] = dp[i-1][j-1]+1;\n                }else{\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\n                }\n            }\n        }\n        return dp[sz1][sz2];\n    }\n};", "compare_result": "1111111111111111111111111111111111111"}, {"id": 271533644, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571561331, "status_display": "Accepted", "runtime": "28 ms", "url": "/submissions/detail/271533644/", "is_pending": "Not Pending", "title": "Edit Distance", "memory": "11.9 MB", "code": "class Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int sz1 = word1.size();\n        int sz2 = word2.size();\n        vector<vector<int> > dp ;\n        for(int i = 0;i <= sz2;i ++){\n            dp.push_back(vector<int>(sz1+1,0));\n        }\n        for(int i = 0;i <= sz1;i ++){\n            dp[0][i] = i;\n        }\n        \n        for(int i = 0;i <= sz2;i ++){\n            dp[i][0] = i;\n        }\n        \n        for(int i = 1;i <=sz2;i ++){\n            for(int j = 1;j <= sz1;j ++){\n                if(word2[i-1] == word1[j-1]){\n                    dp[i][j] = dp[i-1][j-1];\n                }else{\n                    dp[i][j] = min(dp[i-1][j-1] +1,min(dp[i][j-1]+1,dp[i-1][j]+1));\n                }\n            }\n        }\n        \n        return dp[sz2][sz1];\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 271527927, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571559177, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/271527927/", "is_pending": "Not Pending", "title": "Maximum Product Subarray", "memory": "N/A", "code": "class Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        int mx = nums[0];\n        divideAndConqure(nums,0,nums.size()-1,mx);\n        return mx;\n        \n    }\n    void divideAndConqure(vector<int>& nums,int start, int end,int &mx){\n        if(start == end) {\n            if (mx < nums[start]){\n                mx = nums[start];\n            }\n            return;\n        }\n        int mid = (start+end)/2;\n        divideAndConqure(nums,start,mid,mx);\n        divideAndConqure(nums,mid+1,end,mx);\n        \n        for (int i = mid+1;i <= end;i ++){\n            for(int j = mid;j >= start; j --){\n                int sum = 1;\n                for(int k = j;k <= i;k ++){\n                    sum *= nums[k];\n                    if (sum > mx){\n                        mx = sum;\n                    }\n                }\n            }\n        }\n        \n    }\n    \n    \n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110"}, {"id": 271523911, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571557764, "status_display": "Accepted", "runtime": "36 ms", "url": "/submissions/detail/271523911/", "is_pending": "Not Pending", "title": "Copy List with Random Pointer", "memory": "22 MB", "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* next;\n    Node* random;\n\n    Node() {}\n\n    Node(int _val, Node* _next, Node* _random) {\n        val = _val;\n        next = _next;\n        random = _random;\n    }\n};\n*/\nclass Solution {\npublic:\n    Node* copyRandomList(Node* head) {\n        if (head == NULL) return NULL;\n        Node *p = head;\n        while (p != NULL){\n            Node *q  = new Node(p->val,p->next,NULL);\n            p->next = q;\n            \n            p = q->next;\n        }\n        p = head;\n        while(p != NULL){\n            Node *q = p->next;\n            if(p->random != NULL)\n            {\n                q->random = p->random->next; \n            }\n            p = p->next->next;\n        \n        }\n        Node *rh = head->next;\n        p = head;\n        while(p != NULL){\n            Node *q = p->next;\n            p->next = q->next;\n            if(q->next != NULL)\n                q->next = q->next->next;\n            p = p->next;\n        }\n        \n        return rh;\n    }\n};", "compare_result": "111111111"}, {"id": 271522790, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571557380, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/271522790/", "is_pending": "Not Pending", "title": "Copy List with Random Pointer", "memory": "N/A", "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* next;\n    Node* random;\n\n    Node() {}\n\n    Node(int _val, Node* _next, Node* _random) {\n        val = _val;\n        next = _next;\n        random = _random;\n    }\n};\n*/\nclass Solution {\npublic:\n    Node* copyRandomList(Node* head) {\n        if (head == NULL) return NULL;\n        Node *p = head;\n        while (p != NULL){\n            Node *q  = new Node(p->val,p->next,NULL);\n            p->next = q;\n            \n            p = q->next;\n        }\n        \n        Node *rh = head->next;\n        p = head;\n        while(p != NULL){\n            Node *q = p->next;\n            if(p->random != NULL){\n                q->random = p->random->next; \n            }\n            p->next = q->next;\n            if(q->next != NULL)\n                q->next = q->next->next;\n            p = p->next;\n        }\n        \n        return rh;\n    }\n};", "compare_result": "111111000"}, {"id": 271515571, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571555117, "status_display": "Accepted", "runtime": "12 ms", "url": "/submissions/detail/271515571/", "is_pending": "Not Pending", "title": "Longest Consecutive Sequence", "memory": "10 MB", "code": "class Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        unordered_set<int> st(nums.begin(),nums.end());\n        int res = 0;\n        for(auto n : nums){\n            if (st.find(n) == st.end()) continue;\n            st.erase(n);\n            int prev = n-1;\n            int next = n+1;\n            while(st.find(prev) != st.end()) st.erase(prev--);\n            while(st.find(next) != st.end()) st.erase(next++);\n            res = max(res,next-prev-1);\n        }\n        return res;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 271507098, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571552893, "status_display": "Accepted", "runtime": "24 ms", "url": "/submissions/detail/271507098/", "is_pending": "Not Pending", "title": "Count of Smaller Numbers After Self", "memory": "19.9 MB", "code": "class Solution {\npublic:\n    vector<int> countSmaller(vector<int>& nums) {\n        BinaryTree bt;\n        vector<int> vec ;\n        // cout << bt.insert(bt.head,1);\n        // cout << bt.insert(bt.head,6);\n        // cout << bt.insert(bt.head,2);\n        // cout << bt.insert(bt.head,5);\n        // cout << bt.insert(bt.head,3);\n        for(int i = nums.size()-1; i >= 0;i --){\n            vec.push_back(bt.insert(bt.head,nums[i]));\n        }\n        reverse(vec.begin(),vec.end());\n        return vec;\n    }\n    struct BinaryTreeNode{\n        int val;\n        BinaryTreeNode *left = NULL;\n        BinaryTreeNode *right = NULL;\n        int leftsize = 0;\n        int counts = 1;\n        \n        BinaryTreeNode(int vale):val(vale){\n            \n        }\n    };\n    class BinaryTree{\n        \n    public:\n        BinaryTreeNode * head;\n        BinaryTree(){\n            head = NULL;\n        }\n        \n        int insert(BinaryTreeNode *root,int val){\n            if (root == NULL){\n                this->head = new BinaryTreeNode(val);\n                return 0;\n            }\n            \n            if (root->val == val){\n                root->counts ++;\n                return root->leftsize;\n            }\n            \n            if (root->val > val){\n                root->leftsize ++;\n                if (root->left == NULL){\n                    root->left = new BinaryTreeNode(val);\n                    return 0;\n                }\n                return insert(root->left,val);\n            }\n            \n            if (root->val < val){\n                if (root->right == NULL){\n                    root->right = new BinaryTreeNode(val);\n                    return root->counts + root->leftsize;\n                }\n                return root->counts + root->leftsize + insert(root->right,val);\n            }\n            return 0;\n            \n        }\n        \n    };\n    \n   \n};", "compare_result": "1111111111111111"}, {"id": 271495177, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571549961, "status_display": "Accepted", "runtime": "60 ms", "url": "/submissions/detail/271495177/", "is_pending": "Not Pending", "title": "Sliding Window Maximum", "memory": "13.2 MB", "code": "class Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        deque<int> dq;\n        vector<int> vec;\n        for(int i =0 ;i < nums.size();i ++){\n            if(!dq.empty() && dq.front() == i-k) dq.pop_front();\n            while(!dq.empty() && nums[dq.back()] < nums[i]) dq.pop_back();\n            dq.push_back(i);\n            if(i>=k-1){\n                vec.push_back(nums[dq.front()]);\n            }\n        }\n        return vec;\n    }\n};", "compare_result": "111111111111111111"}, {"id": 271494111, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571549726, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/271494111/", "is_pending": "Not Pending", "title": "Sliding Window Maximum", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        deque<int> dq;\n        vector<int> vec;\n        for(int i =0 ;i < nums.size();i ++){\n            if(!dq.empty() && dq.front() == i-k) dq.pop_front();\n            while(!dq.empty() && nums[dq.front()] < nums[i]) dq.pop_front();\n            dq.push_back(i);\n            if(i>=k-1){\n                vec.push_back(nums[dq.front()]);\n            }\n        }\n        return vec;\n    }\n};", "compare_result": "111111111101011010"}, {"id": 271493800, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571549653, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/271493800/", "is_pending": "Not Pending", "title": "Sliding Window Maximum", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        deque<int> dq;\n        vector<int> vec;\n        for(int i =0 ;i < nums.size();i ++){\n            if(!dq.empty() && dq.front() == i-k) dq.pop_front();\n            while(!dq.empty() && dq.front() < nums[i]) dq.pop_front();\n            dq.push_back(i);\n            if(i>=k-1){\n                vec.push_back(nums[dq.front()]);\n            }\n        }\n        return vec;\n    }\n};", "compare_result": "111111101100000000"}, {"id": 271276638, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571505642, "status_display": "Accepted", "runtime": "12 ms", "url": "/submissions/detail/271276638/", "is_pending": "Not Pending", "title": "Jump Game", "memory": "9.7 MB", "code": "class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int i = 0;\n        for(int reach = 0; i < nums.size() && i <= reach; ++ i){\n            reach = max(reach,nums[i]+i);\n        }\n        return i == nums.size();\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 271273173, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571504646, "status_display": "Accepted", "runtime": "0 ms", "url": "/submissions/detail/271273173/", "is_pending": "Not Pending", "title": "Unique Paths", "memory": "8.3 MB", "code": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        long counts = 1;\n        int ma = max(m,n);\n        int mi = min(m,n);\n        for (int i = ma;i <= (m+n-2); i++){\n            counts *= i;\n        }\n        for(int i = 1;i <= m+n-1-ma;i ++){\n            counts = counts/i;\n        }\n        return counts;\n        \n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111"}, {"id": 271267756, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571503100, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/271267756/", "is_pending": "Not Pending", "title": "Sort Colors", "memory": "8.6 MB", "code": "class Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        vector<int> help(3,0);\n        for(int i = 0;i < nums.size();i ++){\n            help[nums[i]] ++;\n        }\n        int idx = 0;\n        for(int i = 0;i < 3;i ++){\n            for (int k =0;k < help[i];k ++){\n                nums[idx++] = i;\n            }\n        }\n        return ;\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 271262902, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571501671, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/271262902/", "is_pending": "Not Pending", "title": "Binary Tree Inorder Traversal", "memory": "9 MB", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        stack<TreeNode*> stks;\n        vector<int> vec;\n        TreeNode *p = root;\n        while(p != NULL || !stks.empty()){\n            while(p != NULL){\n                stks.push(p);\n                p = p->left;\n            }\n            p = stks.top();\n            stks.pop();\n            vec.push_back(p->val);\n            p = p->right;\n        }\n        \n        return vec;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 271261690, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571501323, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/271261690/", "is_pending": "Not Pending", "title": "Subsets", "memory": "9.2 MB", "code": "class Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        vector<vector<int>> vec;\n        vec.push_back(vector<int>());\n        for(int i = 0;i < nums.size();i ++){\n            vec.push_back(vector<int>(1,nums[i]));\n        }\n        for(int i = 1;i <=nums.size();i ++){\n            int idx = vec.size()-1;\n            while(vec[idx].size()==i){\n                int last = vec[idx][i-1];\n                // cout << last << endl;\n                for(int j = 0;j < nums.size();j ++){\n                    if (nums[j] > last){\n                        vector<int> tmp = vector<int>(vec[idx].begin(),vec[idx].end());\n                        tmp.push_back(nums[j]);\n                        vec.push_back(tmp);\n                    }\n                }\n                idx --;\n            }\n        }\n        \n        return vec;\n        \n    }\n};", "compare_result": "1111111111"}, {"id": 271256814, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571500056, "status_display": "Accepted", "runtime": "152 ms", "url": "/submissions/detail/271256814/", "is_pending": "Not Pending", "title": "Word Search", "memory": "68.4 MB", "code": "class Solution {\npublic:\n    bool exist(vector<vector<char>>& board, string word) {\n        int m = board.size();\n        if (m < 1) return false;\n        int n = board[0].size();\n        if (n < 1) return false;\n        map<pair<int,int>,int> trace;\n        for(int i = 0;i < m;i ++){\n            for(int j = 0;j < n;j ++){\n                trace[make_pair(i,j)] = 1;\n                if (board[i][j] == word[0] && findx(board,word,1,i,j,trace,m,n)){\n                    return true;\n                }\n                trace[make_pair(i,j)] = 0;\n            }\n        }\n        return false;\n         \n    }\n    \n    bool findx(vector<vector<char>>& board, string word,int idx,int i,int j,map<pair<int,int>,int>& trace,int m,int n){\n        if(idx >= word.size()) return true;\n        bool status = false ;\n        \n        \n        if (i-1 >=0 && board[i-1][j] == word[idx] && trace[make_pair(i-1,j)] == 0){\n            trace[make_pair(i-1,j)] = 1;\n            status  |= findx(board,word,idx+1,i-1,j,trace,m,n);\n            trace[make_pair(i-1,j)] = 0;\n        }\n        if(status) return true;\n        \n        if (i+1 < m && board[i+1][j] == word[idx] && trace[make_pair(i+1,j)] == 0){\n            trace[make_pair(i+1,j)] = 1;\n            status  |= findx(board,word,idx+1,i+1,j,trace,m,n);\n            trace[make_pair(i+1,j)] = 0;\n        }\n        \n        if(status) return true;\n        if (j-1 >=0 && board[i][j-1] == word[idx] && trace[make_pair(i,j-1)] == 0){\n            trace[make_pair(i,j-1)] = 1;\n            status  |= findx(board,word,idx+1,i,j-1,trace,m,n);\n            trace[make_pair(i,j-1)] = 0;\n        }\n        if(status) return true;\n        \n        if (j+1  < n && board[i][j+1]== word[idx] && trace[make_pair(i,j+1)] == 0){\n            trace[make_pair(i,j+1)] = 1;\n            status  |= findx(board,word,idx+1,i,j+1,trace,m,n);\n            trace[make_pair(i,j+1)] = 0;\n        }\n        return status;\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 271255493, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571499745, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/271255493/", "is_pending": "Not Pending", "title": "Word Search", "memory": "N/A", "code": "class Solution {\npublic:\n    bool exist(vector<vector<char>>& board, string word) {\n        int m = board.size();\n        if (m < 1) return false;\n        int n = board[0].size();\n        if (n < 1) return false;\n        map<pair<int,int>,int> trace;\n        for(int i = 0;i < m;i ++){\n            for(int j = 0;j < n;j ++){\n                \n                if (board[i][j]==word[0] && findx(board,word,1,i,j,trace,m,n)){\n                    return true;\n                }\n            }\n        }\n        return false;\n         \n    }\n    \n    bool findx(vector<vector<char>>& board, string word,int idx,int i,int j,map<pair<int,int>,int>& trace,int m,int n){\n        if(idx >= word.size()) return true;\n        bool status = false ;\n        \n        if (i-1 >=0 && board[i-1][j] == word[idx] && trace[make_pair(i-1,j)] == 0){\n            trace[make_pair(i-1,j)] = 1;\n            status  |= findx(board,word,idx+1,i-1,j,trace,m,n);\n            trace[make_pair(i-1,j)] = 0;\n        }\n        if(status) return true;\n        \n        if (i+1 < m && board[i+1][j] == word[idx] && trace[make_pair(i+1,j)] == 0){\n            trace[make_pair(i+1,j)] = 1;\n            status  |= findx(board,word,idx+1,i+1,j,trace,m,n);\n            trace[make_pair(i+1,j)] = 0;\n        }\n        \n        if(status) return true;\n        if (j-1 >=0 && board[i][j-1] == word[idx] && trace[make_pair(i,j-1)] == 0){\n            trace[make_pair(i,j-1)] = 1;\n            status  |= findx(board,word,idx+1,i,j-1,trace,m,n);\n            trace[make_pair(i,j-1)] = 0;\n        }\n        if(status) return true;\n        \n        if (j+1  < n && board[i][j+1]== word[idx] && trace[make_pair(i,j+1)] == 0){\n            trace[make_pair(i,j+1)] = 1;\n            status  |= findx(board,word,idx+1,i,j+1,trace,m,n);\n            trace[make_pair(i,j+1)] = 0;\n        }\n        return status;\n    }\n};", "compare_result": "111111011011111111111111111111111111110111111111111111111111111111111111111111111111011"}, {"id": 271254825, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571499590, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/271254825/", "is_pending": "Not Pending", "title": "Word Search", "memory": "N/A", "code": "class Solution {\npublic:\n    bool exist(vector<vector<char>>& board, string word) {\n        int m = board.size();\n        if (m < 1) return false;\n        int n = board[0].size();\n        if (n < 1) return false;\n        map<pair<int,int>,int> trace;\n        for(int i = 0;i < m;i ++){\n            for(int j = 0;j < n;j ++){\n                \n                if (findx(board,word,0,i,j,trace,m,n)){\n                    return true;\n                }\n            }\n        }\n        return false;\n         \n    }\n    \n    bool findx(vector<vector<char>>& board, string word,int idx,int i,int j,map<pair<int,int>,int>& trace,int m,int n){\n        if(idx >= word.size()) return true;\n        bool status =(board[i][j] == word[idx]);\n        \n        if (i-1 >=0 && board[i-1][j] == word[idx] && trace[make_pair(i-1,j)] == 0){\n            trace[make_pair(i-1,j)] = 1;\n            status  |= findx(board,word,idx+1,i-1,j,trace,m,n);\n            trace[make_pair(i-1,j)] = 0;\n        }\n        if(status) return true;\n        \n        if (i+1 < m && board[i+1][j] == word[idx] && trace[make_pair(i+1,j)] == 0){\n            trace[make_pair(i+1,j)] = 1;\n            status  |= findx(board,word,idx+1,i+1,j,trace,m,n);\n            trace[make_pair(i+1,j)] = 0;\n        }\n        \n        if(status) return true;\n        if (j-1 >=0 && board[i][j-1] == word[idx] && trace[make_pair(i,j-1)] == 0){\n            trace[make_pair(i,j-1)] = 1;\n            status  |= findx(board,word,idx+1,i,j-1,trace,m,n);\n            trace[make_pair(i,j-1)] = 0;\n        }\n        if(status) return true;\n        \n        if (j+1  < n && board[i][j+1]== word[idx] && trace[make_pair(i,j+1)] == 0){\n            trace[make_pair(i,j+1)] = 1;\n            status  |= findx(board,word,idx+1,i,j+1,trace,m,n);\n            trace[make_pair(i,j+1)] = 0;\n        }\n        return status;\n    }\n};", "compare_result": "110111011001111111101111101111110010010010101111011111111100011111101111010000000000011"}, {"id": 271254226, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571499449, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/271254226/", "is_pending": "Not Pending", "title": "Word Search", "memory": "N/A", "code": "class Solution {\npublic:\n    bool exist(vector<vector<char>>& board, string word) {\n        int m = board.size();\n        if (m < 1) return false;\n        int n = board[0].size();\n        if (n < 1) return false;\n        map<pair<int,int>,int> trace;\n        for(int i = 0;i < m;i ++){\n            for(int j = 0;j < n;j ++){\n                if (findx(board,word,0,i,j,trace,m,n)){\n                    return true;\n                }\n            }\n        }\n        return false;\n         \n    }\n    \n    bool findx(vector<vector<char>>& board, string word,int idx,int i,int j,map<pair<int,int>,int>& trace,int m,int n){\n        if(idx >= word.size()) return true;\n        bool status = false;\n        if (i-1 >=0 && board[i-1][j] == word[idx] && trace[make_pair(i-1,j)] == 0){\n            trace[make_pair(i-1,j)] = 1;\n            status  |= findx(board,word,idx+1,i-1,j,trace,m,n);\n            trace[make_pair(i-1,j)] = 0;\n        }\n        if(status) return true;\n        \n        if (i+1 < m && board[i+1][j] == word[idx] && trace[make_pair(i+1,j)] == 0){\n            trace[make_pair(i+1,j)] = 1;\n            status  |= findx(board,word,idx+1,i+1,j,trace,m,n);\n            trace[make_pair(i+1,j)] = 0;\n        }\n        \n        if(status) return true;\n        if (j-1 >=0 && board[i][j-1] == word[idx] && trace[make_pair(i,j-1)] == 0){\n            trace[make_pair(i,j-1)] = 1;\n            status  |= findx(board,word,idx+1,i,j-1,trace,m,n);\n            trace[make_pair(i,j-1)] = 0;\n        }\n        if(status) return true;\n        \n        if (j+1  < n && board[i][j+1]== word[idx] && trace[make_pair(i,j+1)] == 0){\n            trace[make_pair(i,j+1)] = 1;\n            status  |= findx(board,word,idx+1,i,j+1,trace,m,n);\n            trace[make_pair(i,j+1)] = 0;\n        }\n        return status;\n    }\n};", "compare_result": "101111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 271246271, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571497584, "status_display": "Accepted", "runtime": "648 ms", "url": "/submissions/detail/271246271/", "is_pending": "Not Pending", "title": "Largest Rectangle in Histogram", "memory": "9.8 MB", "code": "class Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        \n        int maxsize = 0;\n        int last = -1;\n        for(int i = 0;i < heights.size() ; i++){\n            int minx = heights[i];\n            if (heights[i] <= last) continue;\n            for(int j = i;j < heights.size(); j ++){\n                int width = (j-i+1);\n                minx = min(minx,heights[j]);\n                if(maxsize < width * minx){\n                    maxsize  = width * minx;\n                }\n            }\n            last = minx;\n        }\n        return maxsize;\n        \n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 271245276, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571497350, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/271245276/", "is_pending": "Not Pending", "title": "Largest Rectangle in Histogram", "memory": "N/A", "code": "class Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        \n        int maxsize = 0;\n        int last = -1;\n        for(int i = 0;i < heights.size() ; i++){\n            int minx = heights[i];\n            if (heights[i] <= last) continue;\n            for(int j = i;j < heights.size(); j ++){\n                int width = (j-i+1);\n                minx = min(minx,heights[j]);\n                if(maxsize < width * minx){\n                    maxsize  = width * minx;\n                }\n            }\n            last = heights[i];\n        }\n        return maxsize;\n        \n    }\n};", "compare_result": "111111111111111111111111101101110000111111111111111111101101101011001011110101110001001101000011"}, {"id": 271245047, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571497293, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/271245047/", "is_pending": "Not Pending", "title": "Largest Rectangle in Histogram", "memory": "N/A", "code": "class Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        \n        int maxsize = 0;\n        int last = heights[0];\n        for(int i = 0;i < heights.size() ; i++){\n            int minx = heights[i];\n            if (heights[i] < last) continue;\n            for(int j = i;j < heights.size(); j ++){\n                int width = (j-i+1);\n                minx = min(minx,heights[j]);\n                if(maxsize < width * minx){\n                    maxsize  = width * minx;\n                }\n            }\n            last = heights[i];\n        }\n        return maxsize;\n        \n    }\n};", "compare_result": "100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 271244375, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571497142, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/271244375/", "is_pending": "Not Pending", "title": "Largest Rectangle in Histogram", "memory": "N/A", "code": "class Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        \n        int maxsize = 0;\n        for(int i = 0;i < heights.size() ; i++){\n            int minx = heights[i];\n            for(int j = i;j < heights.size(); j ++){\n                int width = (j-i+1);\n                minx = min(minx,heights[j]);\n                if(maxsize < width * minx){\n                    maxsize  = width * minx;\n                }\n            }\n        }\n        return maxsize;\n        \n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110"}, {"id": 271243568, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571496942, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/271243568/", "is_pending": "Not Pending", "title": "Decode Ways", "memory": "8.4 MB", "code": "class Solution {\npublic:\n    int numDecodings(string s) {\n        vector<int> vec(s.size()+1,0);\n        vec[0] = 1;\n        if(s.size() == 0) return 0;\n        if(int(s[0]-'0') > 0){\n            vec[1] = 1;\n        }else{\n            return 0;\n        }\n        for(int i = 2;i <= s.size();i ++){\n            int id = int(s[i-1]-'0');\n            if (id > 0 && id < 10){\n                vec[i] += vec[i-1];\n            }\n            \n            id = int(s[i-1]-'0') + 10*int(s[i-2]-'0');\n            if (id >= 10 && id <= 26){\n                vec[i] += vec[i-2];\n            }\n            // cout << vec[i] << ' ' << i << endl;\n        } \n        \n        return vec[s.size()];\n    }\n    \n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 271233187, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571493834, "status_display": "Accepted", "runtime": "28 ms", "url": "/submissions/detail/271233187/", "is_pending": "Not Pending", "title": "Validate Binary Search Tree", "memory": "20.6 MB", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool isValidBST(TreeNode* root) {\n        TreeNode *prev = NULL;\n        return isValidBST(root,prev);\n    }\n    \n    bool isValidBST(TreeNode* root, TreeNode * &prev){\n        if(root == NULL){\n            return true;\n        }\n        bool status = isValidBST(root->left,prev);\n        if(!status){\n            return status;\n        } \n        if (prev != NULL && prev->val >= root->val){\n           \n            return false;\n        }\n        prev = root;\n        status &= isValidBST(root->right,prev);\n        return status;\n    }\n    \n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 271232560, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571493508, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/271232560/", "is_pending": "Not Pending", "title": "Validate Binary Search Tree", "memory": "N/A", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool isValidBST(TreeNode* root) {\n       return isValidBST(root,NULL);\n    }\n    \n    bool isValidBST(TreeNode* root, TreeNode *prev){\n        if(root == NULL){\n            return true;\n        }\n        bool status = isValidBST(root->left,prev);\n        if(!status){\n            return status;\n        }\n        if (prev != NULL && prev->val >= root->val){\n            return false;\n        }\n        prev = root;\n        status = isValidBST(root->right,prev);\n        return status;\n    }\n    \n};", "compare_result": "111110111010110011111111111111111111101111111011110010011110011111011111111"}, {"id": 271229577, "lang": "cpp", "time": "2\u00a0months, 2\u00a0weeks", "timestamp": 1571491998, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/271229577/", "is_pending": "Not Pending", "title": "Validate Binary Search Tree", "memory": "N/A", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool isValidBST(TreeNode* root) {\n        if(root == NULL ) return true;\n        bool status = isValidBST(root->left) &&isValidBST(root->right);\n        if ((root->left != NULL && root->left->val >= root->val)  ||(root->right != NULL && root->right->val <= root->val)) {\n            status = false;\n        }\n        return status;\n    }\n};", "compare_result": "111111111111010011111111111111111111111111111111111111111111111111111011110"}, {"id": 269471168, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570970617, "status_display": "Accepted", "runtime": "0 ms", "url": "/submissions/detail/269471168/", "is_pending": "Not Pending", "title": "Pow(x, n)", "memory": "8.3 MB", "code": "class Solution {\npublic:\n    double myPow(double x, int m) {\n        double r = 1;\n        double t = x;\n        long n = m;\n        if (m < 0){\n            n = -n;\n        }\n        while(n > 0){\n            if (n % 2 == 1){\n                r *= t ;\n            }\n            t = t*t;\n            n = n >> 1;\n        }\n        if (m < 0){\n            r = 1/r;\n        }\n        return r;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 269471143, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570970601, "status_display": "Compile Error", "runtime": "N/A", "url": "/submissions/detail/269471143/", "is_pending": "Not Pending", "title": "Pow(x, n)", "memory": "N/A", "code": "class Solution {\npublic:\n    double myPow(double x, int m) {\n        double r = 1;\n        double t = x;\n        long n = m;\n        if (m < 0){\n            n = -n;\n        }\n        while(n > 0){\n            if (n % 2 = 1){\n                r *= t;\n            }\n            t = t*t;\n            n = n >> 1;\n        }\n        if (m < 0){\n            r = 1/r;\n        }\n        return r;\n    }\n};", "compare_result": null}, {"id": 269471077, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570970562, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/269471077/", "is_pending": "Not Pending", "title": "Pow(x, n)", "memory": "N/A", "code": "class Solution {\npublic:\n    double myPow(double x, int m) {\n        double r = 1;\n        double t = x;\n        long n = m;\n        if (m < 0){\n            n = -n;\n        }\n        while(n > 0){\n            if (!(n&2)){\n                r *= t;\n            }\n            t = t*t;\n            n = n >> 1;\n        }\n        if (m < 0){\n            r = 1/r;\n        }\n        return r;\n    }\n};", "compare_result": "1011001111111001001111011011111111001111111101111110011101001111000010111011011100110101100101110011110100011001111100100111111111111001111111101110011101001111101001011111101111101100001001110100101100111111100001000000110000000000010000100101100000010000000100001000000000000000001000100001000000011100"}, {"id": 269471003, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570970516, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/269471003/", "is_pending": "Not Pending", "title": "Pow(x, n)", "memory": "N/A", "code": "class Solution {\npublic:\n    double myPow(double x, int m) {\n        double r = 1;\n        double t = x;\n        long n = m;\n        if (m < 0){\n            n = -n;\n        }\n        while(n > 0){\n            if (!(n&2)){\n                r *= t;\n            }\n            t = t*t;\n            n = n>>2;\n        }\n        if (m < 0){\n            r = 1/r;\n        }\n        return r;\n    }\n};", "compare_result": "0000000010001000000110011001111111001001111100011010001101000000000010100001011100100101000100000011100100000000111000000100011111100000100100000110010001000110000000010010001100101100000000000000001000001110000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000011100"}, {"id": 269470916, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570970471, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/269470916/", "is_pending": "Not Pending", "title": "Pow(x, n)", "memory": "N/A", "code": "class Solution {\npublic:\n    double myPow(double x, int m) {\n        double r = 1;\n        double t = x;\n        long n = m;\n        if (m < 0){\n            n = -n;\n        }\n        while(n > 0){\n            if (n&2){\n                r *= t;\n            }\n            t = t*t;\n            n = n/2;\n        }\n        if (m < 0){\n            r = 1/r;\n        }\n        return r;\n    }\n};", "compare_result": "0000000010000000000000001000001000000001010100000010000001000000000000000001011000000000000000000000100000000000000000000000010000000000000100000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000011111"}, {"id": 269470769, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570970396, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/269470769/", "is_pending": "Not Pending", "title": "Pow(x, n)", "memory": "8.4 MB", "code": "class Solution {\npublic:\n    double myPow(double x, int m) {\n        double r = 1;\n        double t = x;\n        long n = m;\n        if (m < 0){\n            n = -n;\n        }\n        while(n > 0){\n            if (n%2 == 1){\n                r *= t;\n            }\n            t = t*t;\n            n = n/2;\n        }\n        if (m < 0){\n            r = 1/r;\n        }\n        return r;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 269470713, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570970366, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/269470713/", "is_pending": "Not Pending", "title": "Pow(x, n)", "memory": "N/A", "code": "class Solution {\npublic:\n    double myPow(double x, int m) {\n        double r = 1;\n        double t = x;\n        long n = m;\n        if (m < 0){\n            n = -m;\n        }\n        while(n > 0){\n            if (n%2 == 1){\n                r *= t;\n            }\n            t = t*t;\n            n = n/2;\n        }\n        if (m < 0){\n            r = 1/r;\n        }\n        return r;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000"}, {"id": 269470513, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570970261, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/269470513/", "is_pending": "Not Pending", "title": "Pow(x, n)", "memory": "N/A", "code": "class Solution {\npublic:\n    double myPow(double x, int n) {\n        double r = 1;\n        double t = x;\n        while(n > 0){\n            if (n%2 == 1){\n                r *= t;\n            }\n            t = t*t;\n            n = n/2;\n        }\n        return r;\n    }\n};", "compare_result": "1101101010010100011101001110011101000011010110000110010001000111000001111011011111010111101000001000101100110001011111100101111000101100010100001110001110100101000010111011001101000000110000001010100110010011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111011"}, {"id": 269463238, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570966075, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/269463238/", "is_pending": "Not Pending", "title": "Rotate Image", "memory": "N/A", "code": "class Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int width = matrix.size();\n        int N = width -1;\n        for(int i = 0;i <  width/2;i ++){\n            for(int j = i;j <= width/2-i;j ++){\n                int tmp = matrix[i][j];\n                matrix[i][j] = matrix[N-j][i];\n                matrix[N-j][i] = matrix[N-i][N-j];\n                matrix[N-i][N-j] = matrix[j][N-i];\n                matrix[j][N-i] = tmp;\n            }\n        }\n    }\n};", "compare_result": "111010000000000000000"}, {"id": 269459744, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570964068, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/269459744/", "is_pending": "Not Pending", "title": "Permutations", "memory": "9.3 MB", "code": "class Solution {\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int>> vec;\n        permute(nums,0,vec);\n        return vec;\n    }\n    \n    void permute(vector<int>&nums,int k,vector<vector<int>>&vec){\n        if (k == nums.size()){\n           vec.push_back(vector<int>(nums.begin(),nums.end()));\n           return;\n        }\n        for(int i = k;i < nums.size();i ++){\n            swap(nums[i],nums[k]);\n            permute(nums,k+1,vec);\n            swap(nums[i],nums[k]);\n        }\n    }\n    void swap(int &a,int &b){\n        int c = a;\n        a = b;\n        b = c;\n    }\n};", "compare_result": "1111111111111111111111111"}, {"id": 269458410, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570963377, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/269458410/", "is_pending": "Not Pending", "title": "Trapping Rain Water", "memory": "9.1 MB", "code": "class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int sum = 0;\n        for(int i = 0;i < height.size();){\n            int t = height[i];\n            \n            if (t >0 && (i+1) < height.size() ){\n                int kmax = height[i+1];\n                int kidx = i+1; \n                for(int k = i+1;k < height.size();k ++){\n                    if (height[k] >= kmax){\n                        kmax = height[k];\n                        kidx = k;\n                    }\n                    if (kmax >= t){\n                        break;\n                    }\n                }\n                \n                int s1 = 0;\n                for(int m = i+1; m < kidx;m ++){\n                    s1 += height[m];\n                }\n                int s2 = min(kmax,t) * (kidx-i-1);\n                sum += s2 - s1;\n                i = kidx;\n            }else{\n                i += 1;\n            }\n        }\n        return sum;\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 269453281, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570960563, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/269453281/", "is_pending": "Not Pending", "title": "Find First and Last Position of Element in Sorted Array", "memory": "10.2 MB", "code": "class Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        vector<int> vec;\n        vec.push_back(b1(nums,target));\n        vec.push_back(b2(nums,target));\n        return vec;\n    }\n    int b1(vector<int>& nums, int target){\n        if (nums.size() == 0) return -1;\n        int left = 0;\n        int right = nums.size()-1;\n        while(left <= right){\n            int mid = right - (right-left)/2;\n            if(nums[mid] < target){\n                left = mid +1;\n            }else{\n                right = mid -1;\n            }\n        }\n        return left < nums.size() &&  nums[left] == target ? left:-1;\n    }\n    int b2(vector<int>& nums, int target){\n        if (nums.size() == 0) return -1;\n        int left = 0;\n        int right = nums.size()-1;\n        while(left <= right){\n            int mid = right - (right-left)/2;\n            if(nums[mid] <= target){\n                left = mid +1;\n            }else{\n                right = mid -1;\n            }\n        }\n        return right >=0 && nums[right] == target ? right:-1;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 269452402, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570960147, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/269452402/", "is_pending": "Not Pending", "title": "Find First and Last Position of Element in Sorted Array", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        vector<int> vec;\n        vec.push_back(b1(nums,target));\n        vec.push_back(b2(nums,target));\n        return vec;\n    }\n    int b1(vector<int>& nums, int target){\n        if (nums.size() == 0) return -1;\n        int left = 0;\n        int right = nums.size();\n        while(left <= right){\n            int mid = right - (right-left)/2;\n            if(nums[mid] < target){\n                left = mid +1;\n            }else{\n                right = mid -1;\n            }\n        }\n        return nums[left] == target ? left:-1;\n    }\n    int b2(vector<int>& nums, int target){\n        if (nums.size() == 0) return -1;\n        int left = 0;\n        int right = nums.size();\n        while(left <= right){\n            int mid = right - (right-left)/2;\n            if(nums[mid] <= target){\n                left = mid +1;\n            }else{\n                right = mid -1;\n            }\n        }\n        return nums[right] == target ? right:-1;\n    }\n};", "compare_result": "1110000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 269452258, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570960073, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/269452258/", "is_pending": "Not Pending", "title": "Find First and Last Position of Element in Sorted Array", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        vector<int> vec;\n        vec.push_back(b1(nums,target));\n        vec.push_back(b2(nums,target));\n        return vec;\n    }\n    int b1(vector<int>& nums, int target){\n        int left = 0;\n        int right = nums.size();\n        while(left <= right){\n            int mid = right - (right-left)/2;\n            if(nums[mid] < target){\n                left = mid +1;\n            }else{\n                right = mid -1;\n            }\n        }\n        return nums[left] == target ? left:-1;\n    }\n    int b2(vector<int>& nums, int target){\n        int left = 0;\n        int right = nums.size();\n        while(left <= right){\n            int mid = right - (right-left)/2;\n            if(nums[mid] <= target){\n                left = mid +1;\n            }else{\n                right = mid -1;\n            }\n        }\n        return nums[right] == target ? right:-1;\n    }\n};", "compare_result": "1100000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 269451026, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570959435, "status_display": "Accepted", "runtime": "12 ms", "url": "/submissions/detail/269451026/", "is_pending": "Not Pending", "title": "Search in Rotated Sorted Array", "memory": "8.7 MB", "code": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int left = 0;\n        int right = nums.size() -1;\n        // cout << search(nums,target,0,2);\n        while(left <= right){\n            int mid = right - (right-left)/2;\n            // cout << mid << \" \" << nums[mid]  << ' '<< left << \" \" << right << endl;\n            if (nums[mid] == target){\n                return mid;\n            }else if (nums[mid] < target){\n                if (nums[left] < nums[mid]){\n                    left = mid + 1;\n                }else{\n                    int idx = search(nums,target,mid+1,right);\n                    if (idx > -1) return idx;\n                    right = mid -1;\n                }\n            }else if (nums[mid] > target){\n                if (nums[left] < nums[mid]){\n                    int idx = search(nums,target,left,mid-1);\n                    if (idx > -1) return idx;\n                    left = mid+1;\n                }else{\n                    right = mid -1;\n                }\n            }\n        }\n        return -1;\n    }\n    \n    int search(vector<int>& nums, int target,int left,int right){\n        while (left <= right){\n            int mid = right - (right-left)/2;\n            if (nums[mid] == target){\n                return mid;\n            }else if (nums[mid] < target){\n                left = mid +1 ;\n            }else if (nums[mid] > target){\n                right = mid -1;\n            }\n        }\n        return -1;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 269450949, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570959393, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/269450949/", "is_pending": "Not Pending", "title": "Search in Rotated Sorted Array", "memory": "N/A", "code": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int left = 0;\n        int right = nums.size() -1;\n        cout << search(nums,target,0,2);\n        while(left <= right){\n            int mid = right - (right-left)/2;\n            // cout << mid << \" \" << nums[mid]  << ' '<< left << \" \" << right << endl;\n            if (nums[mid] == target){\n                return mid;\n            }else if (nums[mid] < target){\n                if (nums[left] < nums[mid]){\n                    left = mid + 1;\n                }else{\n                    int idx = search(nums,target,mid+1,right);\n                    if (idx > -1) return idx;\n                    right = mid -1;\n                }\n            }else if (nums[mid] > target){\n                if (nums[left] < nums[mid]){\n                    int idx = search(nums,target,left,mid-1);\n                    if (idx > -1) return idx;\n                    left = mid+1;\n                }else{\n                    right = mid -1;\n                }\n            }\n        }\n        return -1;\n    }\n    \n    int search(vector<int>& nums, int target,int left,int right){\n        while (left <= right){\n            int mid = right - (right-left)/2;\n            if (nums[mid] == target){\n                return mid;\n            }else if (nums[mid] < target){\n                left = mid +1 ;\n            }else if (nums[mid] > target){\n                right = mid -1;\n            }\n        }\n        return -1;\n    }\n};", "compare_result": "1100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 269450064, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570958964, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/269450064/", "is_pending": "Not Pending", "title": "Search in Rotated Sorted Array", "memory": "N/A", "code": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int left = 0;\n        int right = nums.size() -1;\n        while(left <= right){\n            int mid = right - (right-left)/2;\n            // cout << mid << \" \" << nums[mid]  << ' '<< left << \" \" << right << endl;\n            if (nums[mid] == target){\n                return mid;\n            }else if (nums[mid] < target){\n                if (nums[left] < nums[mid]){\n                    left = mid + 1;\n                }else{\n                    int idx = search(nums,target,mid+1,right);\n                    if (idx > -1) return idx;\n                    right = mid -1;\n                }\n            }else if (nums[mid] > target){\n                if (nums[left] < nums[mid]){\n                    int idx = search(nums,target,left,mid-1);\n                    if (idx > -1) return idx;\n                    left = mid+1;\n                }else{\n                    right = mid -1;\n                }\n            }\n        }\n        return -1;\n    }\n    \n    int search(vector<int>& nums, int target,int left,int right){\n        while (left <= right){\n            int mid = right - (right-left)/2;\n            if (nums[mid] == target){\n                return mid;\n            }else if (nums[mid] < target){\n                right = mid-1;\n            }else if (nums[mid] > target){\n                left = mid +1;\n            }\n        }\n        return -1;\n    }\n};", "compare_result": "1111111111111111111111111111111111111110101111111011111100011011010000011000001111111111111111111111111111111111111111110111111111111111111110111001011001111111111111000101000011010010111011110111"}, {"id": 269449964, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570958919, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/269449964/", "is_pending": "Not Pending", "title": "Search in Rotated Sorted Array", "memory": "N/A", "code": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int left = 0;\n        int right = nums.size() -1;\n        while(left < right){\n            int mid = right - (right-left)/2;\n            // cout << mid << \" \" << nums[mid]  << ' '<< left << \" \" << right << endl;\n            if (nums[mid] == target){\n                return mid;\n            }else if (nums[mid] < target){\n                if (nums[left] < nums[mid]){\n                    left = mid + 1;\n                }else{\n                    int idx = search(nums,target,mid+1,right);\n                    if (idx > -1) return idx;\n                    right = mid -1;\n                }\n            }else if (nums[mid] > target){\n                if (nums[left] < nums[mid]){\n                    int idx = search(nums,target,left,mid-1);\n                    if (idx > -1) return idx;\n                    left = mid+1;\n                }else{\n                    right = mid -1;\n                }\n            }\n        }\n        return -1;\n    }\n    \n    int search(vector<int>& nums, int target,int left,int right){\n        while (left <= right){\n            int mid = right - (right-left)/2;\n            if (nums[mid] == target){\n                return mid;\n            }else if (nums[mid] < target){\n                right = mid-1;\n            }else if (nums[mid] > target){\n                left = mid +1;\n            }\n        }\n        return -1;\n    }\n};", "compare_result": "1111011111111101111110110111111111101100101111111011111100011010010000011000001111111101111111111111111111111111111011110111101111111111111110110001011001111111111111000100000011010010111011110111"}, {"id": 269445030, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570956804, "status_display": "Accepted", "runtime": "16 ms", "url": "/submissions/detail/269445030/", "is_pending": "Not Pending", "title": "Remove Duplicates from Sorted Array", "memory": "10 MB", "code": "class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if (nums.size() <=1 ) return nums.size();\n        \n        int idx = 1;\n        int cur = nums[0];\n        for(int i = 1;i < nums.size();i ++){\n            if (cur != nums[i]){\n                nums[idx] =  nums[i];\n                idx ++;\n                cur = nums[i];\n            }\n        }\n        return idx;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 269441973, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570955488, "status_display": "Accepted", "runtime": "60 ms", "url": "/submissions/detail/269441973/", "is_pending": "Not Pending", "title": "Generate Parentheses", "memory": "20 MB", "code": "class Solution {\npublic:\n    vector<string> generateParenthesis(int n) {\n        if (n == 0){\n            return vector<string>();\n        }\n        vector<string> *pvec = new vector<string>();\n        pvec->push_back(\"()\");\n        // string t = \"()\";\n        // cout << t.substr(0,0) + \"[\" + t.substr(0,1) + \"]\" + t.substr(1,0) << endl;\n        for(int i = 1;i < n;i ++){\n            int vsize = pvec->size();\n            vector<string> *ptem = new vector<string>();\n            for(int j = 0;j < vsize;j ++){\n                string s = pvec->at(j);\n                int ssize = s.size();\n                for(int k = 0;k <= ssize;k ++){\n                    for(int m = k;m <= ssize; m ++){\n                        // cout << k << \" \" << m << endl;\n                        ptem->push_back(s.substr(0,k) + \"(\" + s.substr(k,m-k) + \")\" + s.substr(m,ssize-m));\n                    }\n                }\n            }\n            pvec = ptem;\n            set<string> vset(pvec->begin(),pvec->end());\n            pvec = new  vector<string>(vset.begin(),vset.end());\n        }\n        \n        \n        return *pvec;\n    }\n    \n};", "compare_result": "11111111"}, {"id": 269441653, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570955363, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/269441653/", "is_pending": "Not Pending", "title": "Generate Parentheses", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<string> generateParenthesis(int n) {\n        if (n == 0){\n            return vector<string>();\n        }\n        vector<string> *pvec = new vector<string>();\n        pvec->push_back(\"()\");\n        // string t = \"()\";\n        // cout << t.substr(0,0) + \"[\" + t.substr(0,1) + \"]\" + t.substr(1,0) << endl;\n        for(int i = 1;i < n;i ++){\n            int vsize = pvec->size();\n            vector<string> *ptem = new vector<string>();\n            for(int j = 0;j < vsize;j ++){\n                string s = pvec->at(j);\n                int ssize = s.size();\n                for(int k = 0;k <= ssize;k ++){\n                    for(int m = k;m <= ssize; m ++){\n                        // cout << k << \" \" << m << endl;\n                        ptem->push_back(s.substr(0,k) + \"(\" + s.substr(k,m-k) + \")\" + s.substr(m,ssize-m));\n                    }\n                }\n            }\n            pvec = ptem;\n        }\n        set<string> vset(pvec->begin(),pvec->end());\n        \n        return vector<string>(vset.begin(),vset.end());\n    }\n    \n};", "compare_result": "11111000"}, {"id": 269435738, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570953172, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/269435738/", "is_pending": "Not Pending", "title": "Generate Parentheses", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<string> generateParenthesis(int n) {\n        if (n == 0){\n            return vector<string>();\n        }\n        vector<string> vec;\n        vec.push_back(\"()\");\n        \n        for(int i = 1;i < n;i ++){\n            int vsize = vec.size();\n            for(int j = 0;j < vsize;j ++){\n                vec.push_back(\"()\"+vec[j] );\n                vec.push_back(vec[j]+\"()\" );\n                vec[j] = \"(\" + vec[j] + \")\";\n            }\n        }\n        set<string> vset(vec.begin(),vec.end());\n        \n        return vector<string>(vset.begin(),vset.end());\n    }\n    \n};", "compare_result": "11100000"}, {"id": 269432890, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570952160, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/269432890/", "is_pending": "Not Pending", "title": "Merge Two Sorted Lists", "memory": "8.9 MB", "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        ListNode * head = NULL;\n        ListNode * ret = NULL;\n        ListNode *p1 = l1;\n        ListNode *p2 = l2;\n        while(p1 != NULL && p2 != NULL){\n            if (head == NULL){\n                ret = p1->val < p2->val ? p1: p2;\n                head = ret;\n            }else{\n                ret->next = p1->val < p2->val ? p1: p2;\n                ret = ret->next;\n            }\n            p1->val < p2->val ? p1 = p1->next : p2 = p2->next;\n        }\n        while(p1 != NULL){\n            if (head == NULL){\n                ret = p1;\n                head = ret;\n            }else{\n                ret->next = p1;\n                ret = ret->next;\n            }\n            p1 = p1->next;\n        }\n        while(p2 != NULL){\n            if (head == NULL){\n                ret = p2;\n                head = ret;\n            }else{\n                ret->next = p2;\n                ret = ret->next;\n            }\n            p2 = p2->next;\n        }\n        return head;\n        \n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 269431914, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570951804, "status_display": "Accepted", "runtime": "0 ms", "url": "/submissions/detail/269431914/", "is_pending": "Not Pending", "title": "Valid Parentheses", "memory": "8.6 MB", "code": "class Solution {\npublic:\n    bool isValid(string s) {\n        map<char,int> mp;\n        mp['('] =1;\n        mp['['] =2;\n        mp['{'] =3;\n        mp[')'] =-1;\n        mp[']'] =-2;\n        mp['}'] =-3;\n        stack<int> istack;\n        for(int i =0;i < s.size(); i ++){\n            if (mp[s[i]] > 0 ){\n                istack.push(mp[s[i]]);\n            }else{\n                if (!istack.empty() && (istack.top() + mp[s[i]] == 0)){\n                    istack.pop();\n                }else{\n                    return false;\n                }\n            }\n        }\n        return istack.empty();\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 269431768, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570951753, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/269431768/", "is_pending": "Not Pending", "title": "Valid Parentheses", "memory": "N/A", "code": "class Solution {\npublic:\n    bool isValid(string s) {\n        map<char,int> mp;\n        mp['('] =1;\n        mp['['] =2;\n        mp['{'] =3;\n        mp[')'] =-1;\n        mp[']'] =-2;\n        mp['}'] =-3;\n        stack<int> istack;\n        for(int i =0;i < s.size(); i ++){\n            if (mp[s[i]] > 0 ){\n                istack.push(mp[s[i]]);\n            }else{\n                if (istack.top() + mp[s[i]] == 0){\n                    istack.pop();\n                }else{\n                    return false;\n                }\n            }\n        }\n        return istack.empty();\n    }\n};", "compare_result": "1111111000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 269430073, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570951184, "status_display": "Accepted", "runtime": "0 ms", "url": "/submissions/detail/269430073/", "is_pending": "Not Pending", "title": "Letter Combinations of a Phone Number", "memory": "8.5 MB", "code": "class Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        string pString[10] = {\"\",\n            \"\",\n            \"abc\",\n            \"def\",\n            \"ghi\",\n            \"jkl\",\n            \"mno\",\n            \"pqrs\",\n            \"tuv\",\n            \"wxyz\"\n        };\n        long N = 1;\n        vector<int> dN;\n        vector<int> sc;\n        for(int i =0;i < digits.size();i ++){\n            int c = int(digits[i] - '0');\n            // cout << c << endl;\n            N = N*pString[c].size();\n            sc.push_back(c);\n            dN.push_back(pString[c].size());\n        }\n        vector<string> vec;\n        for(int i = 0;i < N;i ++){\n            int tn = N;\n            int ti = i;\n            string s = \"\";\n            for (int j = 0;j < digits.size();j ++){\n                tn = tn/dN[j];\n                int idx = ti/(tn);\n                s += pString[sc[j]][idx];\n                ti = ti %(tn);\n            }\n            if(s.size() > 0)\n                vec.push_back(s);\n        }\n        return vec;\n    }\n};", "compare_result": "1111111111111111111111111"}, {"id": 269429077, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570950876, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/269429077/", "is_pending": "Not Pending", "title": "Letter Combinations of a Phone Number", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        string pString[10] = {\"\",\n            \"\",\n            \"abc\",\n            \"def\",\n            \"ghi\",\n            \"jkl\",\n            \"mno\",\n            \"pqrs\",\n            \"tuv\",\n            \"wxyz\"\n        };\n        long N = 1;\n        vector<int> dN;\n        vector<int> sc;\n        for(int i =0;i < digits.size();i ++){\n            int c = int(digits[i] - '0');\n            // cout << c << endl;\n            N = N*pString[c].size();\n            sc.push_back(c);\n            dN.push_back(pString[c].size());\n        }\n        vector<string> vec;\n        for(int i = 0;i < N;i ++){\n            int tn = N;\n            int ti = i;\n            string s = \"\";\n            for (int j = 0;j < digits.size();j ++){\n                tn = tn/dN[j];\n                int idx = ti/(tn);\n                s += pString[sc[j]][idx];\n                ti = ti %(tn);\n            }\n            vec.push_back(s);\n        }\n        return vec;\n    }\n};", "compare_result": "1011111111111111111111111"}, {"id": 269421568, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570948631, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/269421568/", "is_pending": "Not Pending", "title": "Remove Nth Node From End of List", "memory": "8.3 MB", "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        int cur = 0;\n        return remoteNthFromEnd(head,n,cur);\n    }\n    \n    ListNode* remoteNthFromEnd(ListNode*head,int n,int &cur){\n        if (head == NULL){\n            return head;\n        }\n        head->next = remoteNthFromEnd(head->next,n,cur);\n        cur += 1;\n        if (n == cur){\n            return head->next;\n        }\n        return head;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 269419528, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570948020, "status_display": "Accepted", "runtime": "32 ms", "url": "/submissions/detail/269419528/", "is_pending": "Not Pending", "title": "Longest Substring Without Repeating Characters", "memory": "10.8 MB", "code": "class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        map<char,int> onlyOne;\n        int maxSize = 0;\n        int ilast = 0;\n        int totalElements = 0;\n        for (int i = 0;i < s.size() ;i ++){\n            onlyOne[s[i]] = onlyOne[s[i]]+1;\n            totalElements += 1;\n            while(onlyOne[s[i]] > 1){\n                    onlyOne[s[ilast]] = onlyOne[s[ilast]] -1;\n                    // if (onlyOne[s[ilast]] == 0){\n                    //     onlyOne.erase(s[ilast]);\n                    // }\n                    totalElements -= 1;\n                    ilast += 1; \n            }\n            maxSize = max(maxSize,totalElements) ;\n        }\n        return maxSize;\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 269413789, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570946455, "status_display": "Accepted", "runtime": "20 ms", "url": "/submissions/detail/269413789/", "is_pending": "Not Pending", "title": "Add Two Numbers", "memory": "10.4 MB", "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode *head = NULL;\n        ListNode *ret = NULL;\n        ListNode *pl1 = l1;\n        ListNode *pl2 = l2;\n        int  c = 0;\n        while (pl1 != NULL && pl2 != NULL){\n            int s = (pl1->val + pl2->val+c)%10;\n            c = (pl1->val + pl2->val+c)/10;\n            // cout << s << endl;\n            if (head == NULL){\n                ret = new ListNode(s);\n                head = ret;\n            }else{\n                ret->next = new ListNode(s);\n                ret = ret->next;\n            }\n            pl1 = pl1->next;\n            pl2 = pl2->next;\n        }\n        while (pl1 != NULL){\n            int s = (pl1->val+c)%10;\n            c = (pl1->val+c)/10;\n            if (head == NULL){\n                ret = new ListNode(s);\n                head = ret;\n            }else{\n                ret->next = new ListNode(s);\n                ret = ret->next;\n            }\n            pl1 = pl1->next;\n            // pl2 = pl2->next;\n            \n        }\n        while (pl2 != NULL){\n            int s = (pl2->val+c)%10;\n            c = (pl2->val+c)/10;\n            if (head == NULL){\n                ret = new ListNode(s);\n                head = ret;\n            }else{\n                ret->next = new ListNode(s);\n                ret = ret->next;\n            }\n            // pl1 = pl1->next;\n            pl2 = pl2->next;\n            \n        }\n        if (c != 0){\n            int s = c;\n            if (head == NULL){\n                ret = new ListNode(s);\n                head = ret;\n            }else{\n                ret->next = new ListNode(s);\n                ret = ret->next;\n            }\n            // pl1 = pl1->next;\n            // pl2 = pl2->next;\n            \n        }\n        \n        return head;\n        \n        \n        \n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 268619589, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570706742, "status_display": "Accepted", "runtime": "0 ms", "url": "/submissions/detail/268619589/", "is_pending": "Not Pending", "title": "Sqrt(x)", "memory": "8.2 MB", "code": "class Solution {\npublic:\n    int mySqrt(int x) {\n        \n        long left = 0;\n        long right = x;\n        long mid = 0;\n        while(left < right){\n            mid = (left +right) >> 1;\n            if (mid*mid > x){\n                right = mid-1;\n            }else {\n                left = mid+1;\n            }\n        }\n        while(mid*mid < x) mid = mid +1;\n        while (mid *mid > x) mid = mid-1;\n        return mid;\n        \n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 268619513, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570706695, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/268619513/", "is_pending": "Not Pending", "title": "Sqrt(x)", "memory": "N/A", "code": "class Solution {\npublic:\n    int mySqrt(int x) {\n        \n        long left = 0;\n        long right = x;\n        long mid = 0;\n        while(left < right){\n            mid = (left +right) >> 1;\n            if (mid*mid > x){\n                right = mid-1;\n            }else {\n                left = mid+1;\n            }\n        }\n        if(mid*mid < x) mid = mid +1;\n        if (mid *mid > x) mid = mid-1;\n        return mid;\n        \n    }\n};", "compare_result": "111111011111111011111111111011111011111111110111101101110101111110111110111110111111111111111111011110111111101111010111011111011111010111111011111111111111110110011101011111111101111111111011111111111111011011111111100111111111111001101100111111110111110111101111111011010111110011111111111110111110011111111111111111110111111111011111111101111111101110111111111101111111111111111100111111101110110101110111111111101101011111011111111011011101111110110111111111110111000111101011001101111011111111110111101010111111111101111111110111110100111011011011111000011111101111111011111101111111111111111111100110111111110111111111101111010111111110111101110111111111110111111111111111111111111111011111000011101011111011111111100111011111111001010111101110111111111101011111011011111111101111111111111111111111100111100100111111111111111111111111111111111111111111011111111110101000101011111111011111111101110101111110011101111111111111111001111111111100111111011111111111100111111101111111110111111111111111011101111111111"}, {"id": 268618757, "lang": "cpp", "time": "2\u00a0months, 3\u00a0weeks", "timestamp": 1570706182, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/268618757/", "is_pending": "Not Pending", "title": "Sqrt(x)", "memory": "N/A", "code": "class Solution {\npublic:\n    int mySqrt(int x) {\n        \n        int left = 0;\n        int right = x;\n        while(left < right){\n            int mid = (left +right) >> 1;\n            if (mid*mid > x){\n                right = mid-1;\n            }else {\n                left = mid;\n            }\n        }\n        return left;\n        \n    }\n};", "compare_result": "100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 223954450, "lang": "cpp", "time": "8\u00a0months, 2\u00a0weeks", "timestamp": 1555849373, "status_display": "Accepted", "runtime": "200 ms", "url": "/submissions/detail/223954450/", "is_pending": "Not Pending", "title": "Maximum Length of Pair Chain", "memory": "17.3 MB", "code": "class Solution {\npublic:\n    int findLongestChain(vector<vector<int>>& pairs) {\n        if (pairs.size() <=1) return 0;\n        sort(pairs.begin(),pairs.end(),cmp);\n        int N = pairs.size();\n        int dp[N];\n        dp[0] = 1;\n        for(int i = 1;i < N;i ++){\n            dp[i] = 1;\n            for(int j =0;j < i;j ++){\n                dp[i] = max(dp[i],pairs[i][0] > pairs[j][1] ? dp[j]+1:dp[j]);\n            }\n        }\n        return dp[N-1];\n    }\n    static bool cmp(vector<int>& a, vector<int>&b) {\n        return a[1] < b[1] || a[1] == b[1] && a[0] < b[0];\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 223948538, "lang": "cpp", "time": "8\u00a0months, 2\u00a0weeks", "timestamp": 1555845780, "status_display": "Accepted", "runtime": "148 ms", "url": "/submissions/detail/223948538/", "is_pending": "Not Pending", "title": "Best Time to Buy and Sell Stock with Transaction Fee", "memory": "15.5 MB", "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices, int fee) {\n        int N = prices.size();\n        int buy[N];\n        int sell[N];\n        buy[0] = -prices[0] - fee;\n        sell[0] = 0;\n        for(int i = 1;i < N;i ++){\n            buy[i] = max(buy[i-1],sell[i-1]-prices[i]-fee);\n            sell[i] = max(sell[i-1],buy[i]+prices[i]);\n        }\n        return sell[N-1];\n        \n    }\n};", "compare_result": "11111111111111111111111111111111111111111111"}, {"id": 223948460, "lang": "cpp", "time": "8\u00a0months, 2\u00a0weeks", "timestamp": 1555845731, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/223948460/", "is_pending": "Not Pending", "title": "Best Time to Buy and Sell Stock with Transaction Fee", "memory": "N/A", "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices, int fee) {\n        int N = prices.size();\n        int buy[N];\n        int sell[N];\n        buy[0] = -prices[0] - fee;\n        \n        for(int i = 1;i < N;i ++){\n            buy[i] = max(buy[i-1],sell[i-1]-prices[i]-fee);\n            sell[i] = max(sell[i-1],buy[i]+prices[i]);\n        }\n        return sell[N-1];\n        \n    }\n};", "compare_result": "00001000011111111111111100000000001111111111"}, {"id": 223947051, "lang": "cpp", "time": "8\u00a0months, 2\u00a0weeks", "timestamp": 1555844792, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/223947051/", "is_pending": "Not Pending", "title": "Best Time to Buy and Sell Stock with Transaction Fee", "memory": "N/A", "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices, int fee) {\n        int N = prices.size();\n        cout << endl;\n        int dp[N];\n        dp[0]=0;\n        for(int i = 1;i < N;i ++){\n            int mi = 0;\n            for(int j = 0;j < i;j ++){\n                mi = max(dp[j],mi);\n                mi = max(dp[j]+prices[i]-prices[j]-fee,mi);\n            }\n            dp[i] = mi;\n        }\n        return dp[N-1];\n        \n    }\n};", "compare_result": "11111111111111111111111111111111110000000000"}, {"id": 223946418, "lang": "cpp", "time": "8\u00a0months, 2\u00a0weeks", "timestamp": 1555844379, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/223946418/", "is_pending": "Not Pending", "title": "Best Time to Buy and Sell Stock with Transaction Fee", "memory": "N/A", "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices, int fee) {\n        int N = prices.size();\n        int profit[N];\n        for(int i = 0;i < N;i ++){\n            profit[i] = prices[i] - prices[0];\n            cout << profit[i] << ' ';\n        }\n        int dp[N];\n        dp[0]=0;\n        for(int i = 1;i < N;i ++){\n            int mi = 0;\n            for(int j = 0;j < i;j ++){\n                mi = max(dp[j],mi);\n                mi = max(dp[j]+profit[i]-profit[j]-2,mi);\n            }\n            dp[i] = mi;\n        }\n        \n        return dp[N-1];\n        \n    }\n};", "compare_result": "10110111000000000100000000000000000000000000"}, {"id": 223945277, "lang": "cpp", "time": "8\u00a0months, 2\u00a0weeks", "timestamp": 1555843596, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/223945277/", "is_pending": "Not Pending", "title": "Minimum Cost For Tickets", "memory": "8.7 MB", "code": "class Solution {\npublic:\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\n        int dy[366];\n        int dp[366];\n        memset(dp,0,sizeof(dp));\n        memset(dy,0,sizeof(dy));\n        for(int i = 0;i < days.size();i ++){\n            dy[days[i]] = 1;\n        }\n        \n        for(int i =1;i <= 365;i ++){\n            if(dy[i] == 0){\n                dp[i] = dp[i-1];\n            }else{\n                int mi = dp[i-1] + costs[0];\n                mi = min(mi,dp[max(i-7,0)]+costs[1]);\n                mi = min(mi,dp[max(0,i-30)]+costs[2]);\n                dp[i] = mi;\n            }            \n        }\n        return dp[365];\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 223945027, "lang": "cpp", "time": "8\u00a0months, 2\u00a0weeks", "timestamp": 1555843436, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/223945027/", "is_pending": "Not Pending", "title": "Minimum Cost For Tickets", "memory": "N/A", "code": "class Solution {\npublic:\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\n        int dy[366];\n        int dp[366];\n        memset(dp,0,sizeof(dp));\n        memset(dy,0,sizeof(dy));\n        for(int i = 0;i < days.size();i ++){\n            dy[days[i]] = 1;\n        }\n        \n        for(int i =1;i <= 365;i ++){\n            if(dy[i] == 0){\n                dp[i] = dp[i-1];\n            }else{\n                int mi = dp[i-1] + costs[0];\n                if (i > 7)\n                    mi = min(mi,dp[i-7]+costs[1]);\n                if(i > 30){\n                    mi = min(mi,dp[i-30]+costs[2]);\n                }\n                dp[i] = mi;\n            }            \n        }\n        return dp[365];\n    }\n};", "compare_result": "111111111110111111111101011111111111111111111111110110111111111111"}, {"id": 223930039, "lang": "cpp", "time": "8\u00a0months, 2\u00a0weeks", "timestamp": 1555835312, "status_display": "Accepted", "runtime": "100 ms", "url": "/submissions/detail/223930039/", "is_pending": "Not Pending", "title": "Arithmetic Slices", "memory": "8.7 MB", "code": "class Solution {\npublic:\n    int numberOfArithmeticSlices(vector<int>& A) {\n        int N = A.size();\n        if (N < 3) return 0;\n        int dp[N];\n        int count = 0;\n        for(int i = 0;i < N;i ++){\n           \n            for(int j = i+2;j <N;j ++){\n                dp[i+1]=1;\n                if(A[j] + A[j-2] == 2*A[j-1] && dp[j-1] == 1){\n                    dp[j]=1;\n                    count ++;\n                }else{\n                    dp[j]= 0;\n                }\n            }\n        }\n        return count;\n    }\n};", "compare_result": "111111111111111"}, {"id": 223929480, "lang": "cpp", "time": "8\u00a0months, 2\u00a0weeks", "timestamp": 1555835069, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/223929480/", "is_pending": "Not Pending", "title": "Arithmetic Slices", "memory": "N/A", "code": "class Solution {\npublic:\n    int numberOfArithmeticSlices(vector<int>& A) {\n        int N = A.size();\n        if (N < 3) return 0;\n        int dp[N][N];\n        for(int i = 0;i < N;i ++){\n            for(int j = 0;j < N;j ++){\n                if (j < i+2){\n                    dp[i][j] = 1;\n                }else{\n                    dp[i][j] = 0;\n                }\n            }\n        }\n        \n        for(int i = 0;i < N;i ++){\n            for(int j = i+2;j <N;j ++){\n                if(A[j] + A[j-2] == 2*A[j-1] && dp[i][j-1] == 1){\n                    dp[i][j]=1;\n                }else{\n                    dp[i][j]= 0;\n                }\n            }\n        }\n        int count = 0;\n        for(int i = 0;i < N;i ++){\n            for(int j = i+2;j <N;j ++){\n                if(dp[i][j] > 0){\n                    count ++;\n                }\n            }\n        }\n        return count;\n    }\n};", "compare_result": "111111111111100"}, {"id": 223929387, "lang": "cpp", "time": "8\u00a0months, 2\u00a0weeks", "timestamp": 1555835030, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/223929387/", "is_pending": "Not Pending", "title": "Arithmetic Slices", "memory": "N/A", "code": "class Solution {\npublic:\n    int numberOfArithmeticSlices(vector<int>& A) {\n        int N = A.size();\n        int dp[N][N];\n        for(int i = 0;i < N;i ++){\n            for(int j = 0;j < N;j ++){\n                if (j < i+2){\n                    dp[i][j] = 1;\n                }else{\n                    dp[i][j] = 0;\n                }\n            }\n        }\n        \n        for(int i = 0;i < N;i ++){\n            for(int j = i+2;j <N;j ++){\n                if(A[j] + A[j-2] == 2*A[j-1] && dp[i][j-1] == 1){\n                    dp[i][j]=1;\n                }else{\n                    dp[i][j]= 0;\n                }\n            }\n        }\n        int count = 0;\n        for(int i = 0;i < N;i ++){\n            for(int j = i+2;j <N;j ++){\n                if(dp[i][j] > 0){\n                    count ++;\n                }\n            }\n        }\n        return count;\n    }\n};", "compare_result": "100000000000000"}, {"id": 223926477, "lang": "cpp", "time": "8\u00a0months, 2\u00a0weeks", "timestamp": 1555833746, "status_display": "Accepted", "runtime": "28 ms", "url": "/submissions/detail/223926477/", "is_pending": "Not Pending", "title": "Minimum ASCII Delete Sum for Two Strings", "memory": "9.2 MB", "code": "class Solution {\npublic:\n    int minimumDeleteSum(string s1, string s2) {\n        int N = s1.length();\n        int M = s2.length();\n        int dp[N+1][M+1];\n        dp[0][0] = 0;\n        for (int j = 1; j <= M; j++)\n            dp[0][j] = dp[0][j-1]+s2[j-1];\n        \n        \n        for(int i = 1;i <=N;i ++){\n            for(int j = 1;j <= M;j ++){\n                dp[i][0] = dp[i-1][0] + s1[i-1];\n                if(s1[i-1]==s2[j-1]){\n                    dp[i][j] = dp[i-1][j-1];\n                }else{\n                    dp[i][j] = min(dp[i-1][j]+s1[i-1],dp[i][j-1]+s2[j-1]);\n                }\n            }\n        }\n        return dp[N][M];\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 223922683, "lang": "cpp", "time": "8\u00a0months, 2\u00a0weeks", "timestamp": 1555832288, "status_display": "Accepted", "runtime": "12 ms", "url": "/submissions/detail/223922683/", "is_pending": "Not Pending", "title": "Palindromic Substrings", "memory": "15.2 MB", "code": "class Solution {\npublic:\n    int count = 0;\n    int countSubstrings(string s) {\n        for(int i = 0;i < s.length();i ++){\n            extends(s,i,i);\n            extends(s,i,i+1);\n        }\n        return count;\n    }\n    \n    void extends(string s, int start,int end){\n        while(start >=0 && end < s.length() && (s[start] == s[end])){\n            count ++;\n            start --;\n            end ++;\n        }\n    }\n    \n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 223916423, "lang": "cpp", "time": "8\u00a0months, 2\u00a0weeks", "timestamp": 1555829963, "status_display": "Accepted", "runtime": "16 ms", "url": "/submissions/detail/223916423/", "is_pending": "Not Pending", "title": "Minimum Falling Path Sum", "memory": "9.6 MB", "code": "class Solution {\npublic:\n    int minFallingPathSum(vector<vector<int>>& A) {\n        // int N = A.size();\n        int M = A[0].size();\n        int dp[M];\n        for(int i = 0;i < M;i ++){\n            dp[i] = 0;\n        }\n        \n        for(int i =0;i < A.size();i ++){\n            int dtmp[M];\n            for(int j = 0;j < M;j ++){\n                int cur = dp[j];\n                if (j > 0){\n                    cur = min(cur,dp[j-1]);\n                }\n                if ((j+1) <M){\n                    cur = min(cur,dp[j+1]);\n                }\n                dtmp[j] = cur + A[i][j];\n                // cout << dp[i] << ' ';\n            }\n            for(int j = 0;j < M;j ++){\n                dp[j] = dtmp[j];\n            }\n            // cout << endl;\n        }\n        \n        int mx = INT_MAX;\n        for(int i = 0;i < M;i ++){\n            if (mx > dp[i]){\n                mx = dp[i];\n            }\n        }\n        return mx;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111"}, {"id": 223915035, "lang": "cpp", "time": "8\u00a0months, 2\u00a0weeks", "timestamp": 1555829480, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/223915035/", "is_pending": "Not Pending", "title": "Minimum Falling Path Sum", "memory": "N/A", "code": "class Solution {\npublic:\n    int minFallingPathSum(vector<vector<int>>& A) {\n        // int N = A.size();\n        int M = A[0].size();\n        int dp[M];\n        for(int i = 0;i < M;i ++){\n            dp[i] = 0;\n        }\n        \n        for(int i =0;i < A.size();i ++){\n            for(int j = 0;j < M;j ++){\n                int cur = A[i][j];\n                if (j > 0){\n                    cur = min(cur,A[i][j-1]);\n                }\n                if ((j+1) <A[i].size()){\n                    cur = min(cur,A[i][j+1]);\n                }\n                dp[j] += cur;\n            }\n        }\n        \n        int mx = INT_MAX;\n        for(int i = 0;i < M;i ++){\n            if (mx > dp[i]){\n                mx = dp[i];\n            }\n        }\n        return mx;\n    }\n};", "compare_result": "1111111111101011001110000000000000000000000000"}, {"id": 223706089, "lang": "cpp", "time": "8\u00a0months, 2\u00a0weeks", "timestamp": 1555753810, "status_display": "Accepted", "runtime": "72 ms", "url": "/submissions/detail/223706089/", "is_pending": "Not Pending", "title": "Counting Bits", "memory": "9.5 MB", "code": "class Solution {\npublic:\n    vector<int> countBits(int num) {\n        vector<int> ret = vector<int>(num+1,0);\n        \n        for(int i = 1;i <= num;i ++){\n            ret[i] = ret[i&(i-1)] +1;\n        }\n        return ret;\n    }\n};", "compare_result": "111111111111111"}, {"id": 223705320, "lang": "cpp", "time": "8\u00a0months, 2\u00a0weeks", "timestamp": 1555753293, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/223705320/", "is_pending": "Not Pending", "title": "House Robber", "memory": "8.6 MB", "code": "class Solution {\npublic:\n    int rob(vector<int>& nums) {\n        \n        int N = nums.size();\n        if (N <1) return 0;\n        int rob[N+1];\n        rob[0] = 0;\n        rob[1] = nums[0];\n        for(int i = 1;i < N;i ++){\n            rob[i+1] = max(rob[i],rob[i-1]+nums[i]);\n            \n        }\n        return rob[N];\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 223705196, "lang": "cpp", "time": "8\u00a0months, 2\u00a0weeks", "timestamp": 1555753209, "status_display": "Accepted", "runtime": "48 ms", "url": "/submissions/detail/223705196/", "is_pending": "Not Pending", "title": "Range Sum Query - Immutable", "memory": "17.3 MB", "code": "class NumArray {\npublic:\n    vector<long>sums;\n    NumArray(vector<int>& nums) {\n        sums.push_back(0);\n        long cs = 0;\n        for(int i = 0;i < nums.size();i ++){\n            cs += nums[i];\n            sums.push_back(cs);\n        }\n    }\n    \n    int sumRange(int i, int j) {\n        return sums[j+1] - sums[i];\n    }\n};\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray* obj = new NumArray(nums);\n * int param_1 = obj->sumRange(i,j);\n */", "compare_result": "1111111111111111"}, {"id": 223705102, "lang": "cpp", "time": "8\u00a0months, 2\u00a0weeks", "timestamp": 1555753155, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/223705102/", "is_pending": "Not Pending", "title": "House Robber", "memory": "N/A", "code": "class Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int N = nums.size();\n        int rob[N+1];\n        rob[0] = 0;\n        rob[1] = nums[0];\n        for(int i = 1;i < N;i ++){\n            rob[i+1] = max(rob[i],rob[i-1]+nums[i]);\n            \n        }\n        return rob[N];\n    }\n};", "compare_result": "110000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 223703610, "lang": "cpp", "time": "8\u00a0months, 2\u00a0weeks", "timestamp": 1555752293, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/223703610/", "is_pending": "Not Pending", "title": "Climbing Stairs", "memory": "8.2 MB", "code": "class Solution {\npublic:\n    int climbStairs(int n) {\n        \n        // long step1 = 1;\n        long step2 = 1;\n        long step3 = 1;\n        int idx = 1;\n        while(idx < n){\n            long tmp = step3;\n            step3 = step3 + step2;\n            // step1 = step2;\n            step2 = tmp;\n            // cout << step1 <<','<< step2 <<','<< step3 << '\\t';\n            idx ++;\n        }\n        return step3;\n        \n    }\n};", "compare_result": "111111111111111111111111111111111111111111111"}, {"id": 223702559, "lang": "cpp", "time": "8\u00a0months, 2\u00a0weeks", "timestamp": 1555751664, "status_display": "Accepted", "runtime": "16 ms", "url": "/submissions/detail/223702559/", "is_pending": "Not Pending", "title": "Maximum Subarray", "memory": "9.2 MB", "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        \n        int cur = 0;\n        int mx = nums[0];\n        for (int i = 0; i < nums.size();i ++){\n            cur += nums[i];\n            if(cur > mx){\n                mx = cur;\n            }\n            if (cur <0){\n                cur = 0;\n            }\n        }\n        return mx;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 223699361, "lang": "cpp", "time": "8\u00a0months, 2\u00a0weeks", "timestamp": 1555750011, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/223699361/", "is_pending": "Not Pending", "title": "Min Cost Climbing Stairs", "memory": "8.7 MB", "code": "class Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        int N = cost.size();\n        int dp[N+1];\n        dp[0] = 0;\n        dp[1] = 0;\n        // dp[2] = 0;\n        for(int i = 2;i <=N;i ++){\n            dp[i] = min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);\n            // cout<<dp[i] << endl;\n        }\n        return dp[N];\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 223686838, "lang": "cpp", "time": "8\u00a0months, 2\u00a0weeks", "timestamp": 1555744235, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/223686838/", "is_pending": "Not Pending", "title": "Best Time to Buy and Sell Stock", "memory": "9.6 MB", "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        vector<int> diff = vector<int>(prices.size(),0);\n        for(int i = 1;i < prices.size();i ++){\n            diff[i] = prices[i]-prices[i-1];\n        }\n        \n        int max_profit= 0;\n        int cp = 0;\n        for(int i = 0;i < diff.size();i ++){\n            cp += diff[i];\n            if(cp > max_profit){\n                max_profit = cp;\n            }\n            \n            if (cp <0){\n                cp = 0;\n            }\n            \n        }\n        return max_profit;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 223685069, "lang": "cpp", "time": "8\u00a0months, 2\u00a0weeks", "timestamp": 1555743484, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/223685069/", "is_pending": "Not Pending", "title": "Divisor Game", "memory": "8.5 MB", "code": "class Solution {\npublic:\n    bool divisorGame(int N) {\n        vector<int> dp = vector<int>(N+1,0);\n        dp[0] = 1;\n        for(int i = 1;i <=N; i++ ){\n            for(int j = 1;j < i;j ++){\n                if(i%j == 0 && dp[i-j] ==0){\n                    dp[i] = 1;\n                    break;\n                }\n            }\n        }\n        \n        return dp[N];\n        \n    }\n};", "compare_result": "1111111111111111111111111111111111111111"}, {"id": 222098707, "lang": "cpp", "time": "8\u00a0months, 3\u00a0weeks", "timestamp": 1555151249, "status_display": "Accepted", "runtime": "12 ms", "url": "/submissions/detail/222098707/", "is_pending": "Not Pending", "title": "Minimum Window Substring", "memory": "9.9 MB", "code": "class Solution {\npublic:\n    string minWindow(string s, string t) {\n        \n        int begin=0,end=0,d=INT_MAX,head=0;\n        vector<int> mp(256,0);\n        for (auto c : t){\n            mp[c]++;\n        }\n        int count = t.size();\n        \n        while(end < s.size()){\n            // cout << mp[s[end]]\n            if((mp[s[end++]]--) >0)\n            {\n                // cout << end << '\\t';\n                count--;\n            }\n            while(count == 0){\n                // cout << end;\n                if((end-begin) < d){\n                    d = end-(head=begin);\n                }\n                // count ++;\n                if(begin >= s.size() || mp[s[begin++]]++ == 0) count ++;\n            }\n        }\n        \n        return d==INT_MAX? \"\":s.substr(head, d);   \n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 222096393, "lang": "cpp", "time": "8\u00a0months, 3\u00a0weeks", "timestamp": 1555149711, "status_display": "Accepted", "runtime": "44 ms", "url": "/submissions/detail/222096393/", "is_pending": "Not Pending", "title": "Three Equal Parts", "memory": "12 MB", "code": "class Solution {\npublic:\n    vector<int> threeEqualParts(vector<int>& A) {\n        int ones = 0;\n        for (auto x : A){\n            if (x == 1) ones ++;\n        }\n        if (ones%3 != 0 || A.size() < 3){\n            return vector<int>(2,-1);\n        }\n        \n        vector<int> iret = vector<int>();\n        if(ones ==0){\n            iret.push_back(0);\n            iret.push_back(A.size()-1);\n            return iret;\n        }\n        \n        int p1 = ones/3;\n        int idx1 = 0;\n        while (idx1 < A.size()){\n            if (A[idx1] == 1){\n                p1 --;\n            }\n            if (p1 == 0){\n                break;\n            }\n            idx1 ++;\n        }\n        \n        int idx2 = A.size()-1;\n        while (idx2 > 0){\n            if(A[idx2]==1){\n                break;\n            }\n            idx2 --;\n        }\n        idx1 += (A.size()-1-idx2);\n        \n        int idx3 = 0;\n        while(A[idx3] == 0){\n            idx3 ++;\n        }\n        \n        if((idx1-idx3+1)*3 > A.size()) return vector<int>(2,-1);\n        \n        int idx4 = idx1+1;\n        while(A[idx4]==0)\n        {\n            idx4 ++;\n        }\n        int idx31 = idx3;\n        \n        cout << idx1 <<' ' << idx3 <<' ' << idx4 << endl;\n        \n        while(idx31 <= idx1){\n            if(A[idx31] != A[idx4]){\n                return  vector<int>(2,-1);\n            }\n            idx31 ++;\n            idx4 ++;\n        }\n        \n        int idx5 = idx4;\n        \n        while(A[idx5] == 0){\n            idx5 ++;\n        }\n        cout << idx5 << endl;\n        int idx32 = idx3;\n        \n        while(idx32 <= idx1){\n            if(idx5 >= A.size() || A[idx32] != A[idx5]){\n                return  vector<int>(2,-1);\n            }\n            idx32 ++;\n            idx5 ++;\n        }\n        \n        iret.push_back(idx1);\n        iret.push_back(idx4);\n        return iret;\n        \n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 222096198, "lang": "cpp", "time": "8\u00a0months, 3\u00a0weeks", "timestamp": 1555149597, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/222096198/", "is_pending": "Not Pending", "title": "Three Equal Parts", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<int> threeEqualParts(vector<int>& A) {\n        int ones = 0;\n        for (auto x : A){\n            if (x == 1) ones ++;\n        }\n        if (ones%3 != 0 || A.size() < 3){\n            return vector<int>(2,-1);\n        }\n        \n        vector<int> iret = vector<int>();\n        if(ones ==0){\n            iret.push_back(0);\n            iret.push_back(1);\n            return iret;\n        }\n        \n        int p1 = ones/3;\n        int idx1 = 0;\n        while (idx1 < A.size()){\n            if (A[idx1] == 1){\n                p1 --;\n            }\n            if (p1 == 0){\n                break;\n            }\n            idx1 ++;\n        }\n        \n        int idx2 = A.size()-1;\n        while (idx2 > 0){\n            if(A[idx2]==1){\n                break;\n            }\n            idx2 --;\n        }\n        idx1 += (A.size()-1-idx2);\n        \n        int idx3 = 0;\n        while(A[idx3] == 0){\n            idx3 ++;\n        }\n        \n        if((idx1-idx3+1)*3 > A.size()) return vector<int>(2,-1);\n        \n        int idx4 = idx1+1;\n        while(A[idx4]==0)\n        {\n            idx4 ++;\n        }\n        int idx31 = idx3;\n        \n        cout << idx1 <<' ' << idx3 <<' ' << idx4 << endl;\n        \n        while(idx31 <= idx1){\n            if(A[idx31] != A[idx4]){\n                return  vector<int>(2,-1);\n            }\n            idx31 ++;\n            idx4 ++;\n        }\n        \n        int idx5 = idx4;\n        \n        while(A[idx5] == 0){\n            idx5 ++;\n        }\n        cout << idx5 << endl;\n        int idx32 = idx3;\n        \n        while(idx32 <= idx1){\n            if(idx5 >= A.size() || A[idx32] != A[idx5]){\n                return  vector<int>(2,-1);\n            }\n            idx32 ++;\n            idx5 ++;\n        }\n        \n        iret.push_back(idx1);\n        iret.push_back(idx4);\n        return iret;\n        \n    }\n};", "compare_result": "11111111111101111111111111111111111111111111111111111111111111111111111111111111111111101111111111111111"}, {"id": 222095902, "lang": "cpp", "time": "8\u00a0months, 3\u00a0weeks", "timestamp": 1555149426, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/222095902/", "is_pending": "Not Pending", "title": "Three Equal Parts", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<int> threeEqualParts(vector<int>& A) {\n        int ones = 0;\n        for (auto x : A){\n            if (x == 1) ones ++;\n        }\n        if (ones%3 != 0 || A.size() < 3){\n            return vector<int>(2,-1);\n        }\n        \n        vector<int> iret = vector<int>();\n        if(ones ==0){\n            iret.push_back(0);\n            iret.push_back(1);\n            return iret;\n        }\n        \n        int p1 = ones/3;\n        int idx1 = 0;\n        while (idx1 < A.size()){\n            if (A[idx1] == 1){\n                p1 --;\n            }\n            if (p1 == 0){\n                break;\n            }\n            idx1 --;\n        }\n        \n        int idx2 = A.size()-1;\n        while (idx2 > 0){\n            if(A[idx2]==1){\n                break;\n            }\n            idx2 --;\n        }\n        idx1 += (A.size()-1-idx2);\n        \n        int idx3 = 0;\n        while(A[idx3] == 0){\n            idx3 ++;\n        }\n        \n        if((idx1-idx3+1)*3 > A.size()) return vector<int>(2,-1);\n        \n        int idx4 = idx1+1;\n        while(A[idx4]==0)\n        {\n            idx4 ++;\n        }\n        int idx31 = idx3;\n        \n        cout << idx1 <<' ' << idx3 <<' ' << idx4 << endl;\n        \n        while(idx31 <= idx1){\n            if(A[idx31] != A[idx4]){\n                return  vector<int>(2,-1);\n            }\n            idx31 ++;\n            idx4 ++;\n        }\n        \n        int idx5 = idx4;\n        \n        while(A[idx5] == 0){\n            idx5 ++;\n        }\n        cout << idx5 << endl;\n        int idx32 = idx3;\n        \n        while(idx32 <= idx1){\n            if(idx5 >= A.size() || A[idx32] != A[idx5]){\n                return  vector<int>(2,-1);\n            }\n            idx32 ++;\n            idx5 ++;\n        }\n        \n        iret.push_back(idx1);\n        iret.push_back(idx4);\n        return iret;\n        \n    }\n};", "compare_result": "11110100111001000000000100000000000000000001000000000100000000010000000001100000000100000000000100000000"}, {"id": 222081459, "lang": "cpp", "time": "8\u00a0months, 3\u00a0weeks", "timestamp": 1555142180, "status_display": "Accepted", "runtime": "36 ms", "url": "/submissions/detail/222081459/", "is_pending": "Not Pending", "title": "Binary Tree Maximum Path Sum", "memory": "25.1 MB", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int maxPathSum(TreeNode* root) {\n        long global = root->val;\n        maxPath(global,root);\n        return global;\n    }\n    \n    long maxPath(long &global,TreeNode*root){\n        if (root == NULL) return INT_MIN;\n        \n        long ml = maxPath(global,root->left);\n        long mr = maxPath(global,root->right);\n        \n        long mv =  max(max(max(max(max(root->val*1L,ml),mr),root->val + ml),root->val + mr ),root->val + ml + mr);\n        global = max(global,mv);\n        \n        long mc = max(ml,mr);\n        long ret = root->val;\n        if(mc > 0){\n            ret += mc;\n        }\n        \n        \n        return ret;\n    \n        \n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 222080841, "lang": "cpp", "time": "8\u00a0months, 3\u00a0weeks", "timestamp": 1555141918, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/222080841/", "is_pending": "Not Pending", "title": "Binary Tree Maximum Path Sum", "memory": "N/A", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int maxPathSum(TreeNode* root) {\n        int global = root->val;\n        maxPath(global,root);\n        return global;\n    }\n    \n    int maxPath(int &global,TreeNode*root){\n        if (root == NULL) return 0;\n        \n        int ml = maxPath(global,root->left);\n        int mr = maxPath(global,root->right);\n        \n        int mv =  max(max(max(max(max(root->val,ml),mr),root->val + ml),root->val + mr ),root->val + ml + mr);\n        global = max(global,mv);\n        \n        int mc = max(ml,mr);\n        int ret = root->val;\n        if(mc > 0){\n            ret += mc;\n        }\n        \n        \n        return ret;\n    \n        \n    }\n};", "compare_result": "111101110011110111111111111111111111111111111111111111111111111111111101111111101111111111111"}, {"id": 218689682, "lang": "cpp", "time": "9\u00a0months, 1\u00a0week", "timestamp": 1553941531, "status_display": "Accepted", "runtime": "28 ms", "url": "/submissions/detail/218689682/", "is_pending": "Not Pending", "title": "Candy", "memory": "10.5 MB", "code": "class Solution {\npublic:\n    int candy(vector<int>& ratings) {\n        vector<int> nums = vector<int>(ratings.size(),1);\n        \n        for(int i = 1;i < ratings.size();i ++){\n            if(ratings[i] > ratings[i-1]){\n                nums[i] = nums[i-1]+1;\n            }\n        }\n        \n        for(int i = ratings.size()-2;i >= 0;i --){\n            if(ratings[i]  > ratings[i+1]){\n                nums[i] = max(nums[i],nums[i+1]+1);\n            }\n        }\n        int s = 0;\n        for(int i = 0;i < nums.size();i ++){\n            // cout << nums[i] << \" \";\n            s += nums[i];\n        }   \n        return s;\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111"}, {"id": 218688672, "lang": "cpp", "time": "9\u00a0months, 1\u00a0week", "timestamp": 1553940818, "status_display": "Accepted", "runtime": "136 ms", "url": "/submissions/detail/218688672/", "is_pending": "Not Pending", "title": "LFU Cache", "memory": "41.1 MB", "code": "class LFUCache {\n    int cap ;\n    int minfre = 1;\n    unordered_map<int,pair<int,int> > mp1 = unordered_map<int,pair<int,int> >();\n    \n    unordered_map<int,list<int> > mp2 = unordered_map<int,list<int> > ();\n    unordered_map<int,list<int>::iterator > mp3 = unordered_map<int,list<int>::iterator >();\n    \n    \n    \npublic:\n    LFUCache(int capacity) {\n        cap = capacity;\n        minfre = 1;\n    }\n    \n    int get(int key) {\n        if(mp1.count(key) == 0) return -1;\n        //remove old place\n        mp2[mp1[key].first].erase(mp3[key]);\n        //add to new place\n        mp2[++mp1[key].first].push_back(key);\n        mp3[key] = --mp2[mp1[key].first].end();\n        if(mp2[minfre].size() == 0){\n            minfre ++;\n        }\n        return mp1[key].second;        \n    }\n    \n    void put(int key, int value) {\n        if (cap <= 0) return;\n        \n        // key exist \n        int v = get(key);\n        if (v != -1){\n            mp1[key].second = value;\n            return;\n        }\n        \n        //need remove one\n        if(mp1.size() == cap){\n            int ky =  mp2[minfre].front();\n            int freq = mp1[ky].first;\n            mp1.erase(ky);\n            mp2[freq].erase(mp3[ky]);\n            mp3.erase(ky);\n        }\n        //need to add new one\n        \n        mp1[key] = pair<int,int>(1,value);\n        mp2[1].push_back(key);\n        mp3[key] = -- mp2[1].end();\n        \n        minfre = 1;\n        \n        \n    }\n    \n    \n    \n};\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * LFUCache* obj = new LFUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */", "compare_result": "11111111111111111111111"}, {"id": 218688417, "lang": "cpp", "time": "9\u00a0months, 1\u00a0week", "timestamp": 1553940646, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/218688417/", "is_pending": "Not Pending", "title": "LFU Cache", "memory": "N/A", "code": "class LFUCache {\n    int cap ;\n    int minfre = 1;\n    unordered_map<int,pair<int,int> > mp1 = unordered_map<int,pair<int,int> >();\n    \n    unordered_map<int,list<int> > mp2 = unordered_map<int,list<int> > ();\n    unordered_map<int,list<int>::iterator > mp3 = unordered_map<int,list<int>::iterator >();\n    \n    \n    \npublic:\n    LFUCache(int capacity) {\n        cap = capacity;\n        minfre = 1;\n    }\n    \n    int get(int key) {\n        if(mp1.count(key) == 0) return -1;\n        //remove old place\n        mp2[mp1[key].first].erase(mp3[key]);\n        //add to new place\n        mp2[++mp1[key].first].push_back(key);\n        mp3[key] = --mp2[mp1[key].first].end();\n        if(mp2[minfre].size() == 0){\n            minfre ++;\n        }\n        return mp1[key].second;        \n    }\n    \n    void put(int key, int value) {\n        \n        // key exist \n        int v = get(key);\n        if (v != -1){\n            mp1[key].second = value;\n            return;\n        }\n        \n        //need remove one\n        if(mp1.size() == cap){\n            int ky =  mp2[minfre].front();\n            int freq = mp1[ky].first;\n            mp1.erase(ky);\n            mp2[freq].erase(mp3[ky]);\n            mp3.erase(ky);\n        }\n        //need to add new one\n        \n        mp1[key] = pair<int,int>(1,value);\n        mp2[1].push_back(key);\n        mp3[key] = -- mp2[1].end();\n        \n        minfre = 1;\n        \n        \n    }\n    \n    \n    \n};\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * LFUCache* obj = new LFUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */", "compare_result": "11110000000000000000000"}, {"id": 218687976, "lang": "cpp", "time": "9\u00a0months, 1\u00a0week", "timestamp": 1553940368, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/218687976/", "is_pending": "Not Pending", "title": "LFU Cache", "memory": "N/A", "code": "class LFUCache {\n    int cap ;\n    int minfre = 1;\n    unordered_map<int,pair<int,int> > mp1 = unordered_map<int,pair<int,int> >();\n    \n    unordered_map<int,list<int> > mp2 = unordered_map<int,list<int> > ();\n    unordered_map<int,list<int>::iterator > mp3 = unordered_map<int,list<int>::iterator >();\n    \n    \n    \npublic:\n    LFUCache(int capacity) {\n        cap = capacity;\n        minfre = 1;\n    }\n    \n    int get(int key) {\n        if(mp1.count(key) == 0) return -1;\n        //remove old place\n        mp2[mp1[key].first].erase(mp3[key]);\n        //add to new place\n        mp2[++mp1[key].first].push_back(key);\n        mp3[key] = --mp2[mp1[key].first].end();\n        if(mp2[minfre].size() == 0){\n            minfre ++;\n        }\n        return mp1[key].second;        \n    }\n    \n    void put(int key, int value) {\n        \n        // key exist \n        int v = get(key);\n        if (v != -1){\n            mp1[key].second = value;\n            return;\n        }\n        \n        //need remove one\n        if(mp1.size() == cap){\n            int ky =  mp2[minfre].front();\n            int freq = mp1[ky].first;\n            mp1.erase(ky);\n            mp2[freq].erase(mp3[ky]);\n            mp3.erase(ky);\n        }\n        //need to add new one\n        \n        mp1[key] = pair<int,int>(1,value);\n        mp2[1].push_back(key);\n        mp3[key] = -- mp2[1].end();\n        \n        minfre = 1;\n        \n        \n    }\n    \n    \n    \n};\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * LFUCache* obj = new LFUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */", "compare_result": "11110000000000000000000"}, {"id": 218677845, "lang": "cpp", "time": "9\u00a0months, 1\u00a0week", "timestamp": 1553934751, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/218677845/", "is_pending": "Not Pending", "title": "K Inverse Pairs Array", "memory": "N/A", "code": "class Solution {\npublic:\n    int kInversePairs(int n, int k) {\n        const int mod = pow(10, 9) + 7;\n        vector<vector<long>> dp(n + 1, vector<long>(k+1, 0));\n        dp[0][0] =1 ;\n        for(int i =1;i <= n;i ++){\n            for(int j = 0;j < i ;j ++){\n                for(int m = 0; m <= k; ++m){ //dp[i][m] +=  dp[i-1][m-j]\n                    if(m - j >= 0 && m - j <= k){\n                        dp[i][m] = (dp[i][m] + dp[i-1][m-j]) % mod; \n                    }\n                }\n \n             }\n            }\n        \n        return dp[n][k];\n    }\n};", "compare_result": "11111111111111111111111111111111111000000000000000000000000000000000000000000000"}, {"id": 218657498, "lang": "cpp", "time": "9\u00a0months, 1\u00a0week", "timestamp": 1553926540, "status_display": "Accepted", "runtime": "16 ms", "url": "/submissions/detail/218657498/", "is_pending": "Not Pending", "title": "Find K-th Smallest Pair Distance", "memory": "9.5 MB", "code": "class Solution {\npublic:\n    int smallestDistancePair(vector<int>& nums, int k) {\n        int n = nums.size();\n        sort(nums.begin(),nums.end());\n        \n        int start = 0,end = 1000000;\n        while(start < end){\n            int mid = start + (end-start)/2;\n            \n            int cnt = 0;\n            for(int i = 0,j = 0;i < n;i ++){\n                while(j < n && (nums[j]-nums[i]) <= mid) j++;\n                cnt += j-i-1;\n            }\n            if (cnt < k){\n                start = mid +1;\n            }else{\n                end = mid;\n            }\n        }\n        \n        return start;\n    }\n};", "compare_result": "1111111111111111111"}, {"id": 218657399, "lang": "cpp", "time": "9\u00a0months, 1\u00a0week", "timestamp": 1553926502, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/218657399/", "is_pending": "Not Pending", "title": "Find K-th Smallest Pair Distance", "memory": "N/A", "code": "class Solution {\npublic:\n    int smallestDistancePair(vector<int>& nums, int k) {\n        int n = nums.size();\n        sort(nums.begin(),nums.end());\n        \n        int start = 0,end = 100000;\n        while(start < end){\n            int mid = start + (end-start)/2;\n            \n            int cnt = 0;\n            for(int i = 0,j = 0;i < n;i ++){\n                while(j < n && (nums[j]-nums[i]) <= mid) j++;\n                cnt += j-i-1;\n            }\n            if (cnt < k){\n                start = mid +1;\n            }else{\n                end = mid;\n            }\n        }\n        \n        return start;\n    }\n};", "compare_result": "1111111111110110110"}, {"id": 218653878, "lang": "cpp", "time": "9\u00a0months, 1\u00a0week", "timestamp": 1553925177, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/218653878/", "is_pending": "Not Pending", "title": "First Missing Positive", "memory": "8.7 MB", "code": "class Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        nums.push_back(0);\n        int st = nums.size();\n        // if(st == 1 ){\n        //     return nums[0] == 1 ? 2 : 1;\n        // }\n        \n        for(int i = 0;i < st;i ++){\n            int tmp = i;\n            while (nums[tmp] != tmp && nums[tmp] >=0 && nums[tmp] < st){\n                if(nums[tmp] == nums[nums[tmp]]) break;  \n                swap(nums[tmp],nums[nums[tmp]]);\n                tmp = i;\n            }\n        }\n        int idx = 1;\n        bool status = false;\n        for(int i = 1;i < nums.size();i ++){\n            if(nums[i] != i){\n                idx = i;\n                break;\n            }else{\n                status = true;\n            }\n        }\n        if (idx == 1 && status == true){\n            idx = nums.size();\n        }\n        return idx;\n    }\n    \n    void swap(int&a,int &b){\n        int tmp = a;\n        a = b;\n        b = tmp;\n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 218653407, "lang": "cpp", "time": "9\u00a0months, 1\u00a0week", "timestamp": 1553925010, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/218653407/", "is_pending": "Not Pending", "title": "First Missing Positive", "memory": "N/A", "code": "class Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        int st = nums.size();\n        if(st == 1 ){\n            return nums[0] == 1 ? 2 : 1;\n        }\n        \n        for(int i = 0;i < st;i ++){\n            int tmp = i;\n            while (nums[tmp] != tmp && nums[tmp] >=0 && nums[tmp] < st){\n                if(nums[tmp] == nums[nums[tmp]]) break;  \n                swap(nums[tmp],nums[nums[tmp]]);\n                tmp = i;\n            }\n        }\n        int idx = 1;\n        bool status = false;\n        // for(int i = 0;i < nums.size();i ++)\n        //     cout << nums[i] << '\\t';\n        for(int i = 1;i < nums.size();i ++){\n            if(nums[i] != i){\n                idx = i;\n                break;\n            }else{\n                status = true;\n            }\n        }\n        if (idx == 1 && status == true){\n            idx = nums.size();\n        }\n        return idx;\n    }\n    \n    void swap(int&a,int &b){\n        int tmp = a;\n        a = b;\n        b = tmp;\n    }\n};", "compare_result": "111111111111110111111011011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110101"}, {"id": 218653158, "lang": "cpp", "time": "9\u00a0months, 1\u00a0week", "timestamp": 1553924918, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/218653158/", "is_pending": "Not Pending", "title": "First Missing Positive", "memory": "N/A", "code": "class Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        int st = nums.size();\n        if(st == 1 ){\n            return nums[0] == 1 ? 2 : 1;\n        }\n        \n        for(int i = 0;i < st;i ++){\n            int tmp = i;\n            while (nums[tmp] != tmp && nums[tmp] >=0 && nums[tmp] < st){\n                swap(nums[tmp],nums[nums[tmp]]);\n                tmp = i;\n            }\n        }\n        int idx = 1;\n        bool status = false;\n        for(int i = 0;i < nums.size();i ++)\n            cout << nums[i] << '\\t';\n        for(int i = 1;i < nums.size();i ++){\n            if(nums[i] != i){\n                idx = i;\n                break;\n            }else{\n                status = true;\n            }\n        }\n        if (idx == 1 && status == true){\n            idx = nums.size();\n        }\n        return idx;\n    }\n    \n    void swap(int&a,int &b){\n        int tmp = a;\n        a = b;\n        b = tmp;\n    }\n};", "compare_result": "111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 218652346, "lang": "cpp", "time": "9\u00a0months, 1\u00a0week", "timestamp": 1553924623, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/218652346/", "is_pending": "Not Pending", "title": "First Missing Positive", "memory": "N/A", "code": "class Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        int st = nums.size();\n        for(int i = 0;i < st;i ++){\n            int tmp = i;\n            while (nums[tmp] != tmp && nums[tmp] >=0 && nums[tmp] < st){\n                swap(nums[tmp],nums[nums[tmp]]);\n                tmp = i;\n            }\n        }\n        int idx = 1;\n        bool status = false;\n        // for(int i = 0;i < nums.size();i ++)\n        //     cout << nums[i] << '\\t';\n        for(int i = 1;i < nums.size();i ++){\n            if(nums[i] != i){\n                idx = i;\n                break;\n            }else{\n                status = true;\n            }\n        }\n        if (idx == 1 && status == true){\n            idx = nums.size();\n        }\n        return idx;\n    }\n    \n    void swap(int&a,int &b){\n        int tmp = a;\n        a = b;\n        b = tmp;\n    }\n};", "compare_result": "111110111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"id": 217198513, "lang": "cpp", "time": "9\u00a0months, 2\u00a0weeks", "timestamp": 1553417528, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/217198513/", "is_pending": "Not Pending", "title": "Count The Repetitions", "memory": "N/A", "code": "class Solution {\npublic:\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\n        \n        int repeat_count = 0;\n        \n        int index = 0;\n        int s1_size = s1.length();\n        int s2_size = s2.length();\n        for (int i = 0;i < n1;i ++){\n            for (int j = 0;j < s1_size;j ++){\n                if(s1[j] == s2[index]){\n                    index ++;\n                }\n                if(index >= s2_size){\n                    index = 0;\n                    repeat_count += 1;\n                }\n            }\n        }\n        \n        return repeat_count/n2;\n    \n    }\n    \n    \n    \n};", "compare_result": "11111111111111111111111111111111111110000"}, {"id": 217198322, "lang": "cpp", "time": "9\u00a0months, 2\u00a0weeks", "timestamp": 1553417435, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/217198322/", "is_pending": "Not Pending", "title": "Count The Repetitions", "memory": "N/A", "code": "class Solution {\npublic:\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\n        \n        int repeat_count = 0;\n        \n        int index = 0;\n        for (int i = 0;i < n1;i ++){\n            for (int j = 0;j < s1.length();j ++){\n                if(s1[j] == s2[index]){\n                    index ++;\n                }\n                if(index >= s2.length()){\n                    index = 0;\n                    repeat_count += 1;\n                }\n            }\n        }\n        \n        return repeat_count/n2;\n    \n    }\n    \n    \n    \n};", "compare_result": "11111111111111111111111111111110000000000"}, {"id": 217196274, "lang": "cpp", "time": "9\u00a0months, 2\u00a0weeks", "timestamp": 1553416549, "status_display": "Accepted", "runtime": "472 ms", "url": "/submissions/detail/217196274/", "is_pending": "Not Pending", "title": "Palindrome Partitioning II", "memory": "8.4 MB", "code": "class Solution {\npublic:\n    int minCut(string s) {\n        int A[s.length()+1];\n        \n        for(int i =0;i < s.length();i ++){\n            A[i+1] = i;\n        }\n        A[0] = -1;\n        \n        \n        for(int i = 2;i <= s.length();i ++){\n            for(int j =1;j < i;j ++){\n                if(isParadime(s,j-1,i-1)){\n                    // cout << i << \"\\t\" <<  j << endl;\n                    A[i] = min(A[i],A[j-1]+1);\n                    // break;\n                }\n            }\n            \n            A[i] = min(A[i],A[i-1]+1);\n            // cout << A[i] << \"\\t\";\n        }\n        \n        return A[s.length()];\n    }\n    \n    \n    bool isParadime(string &s,int start,int end){\n        while(start < end){\n            if(s[start] != s[end]){\n                return false;\n            }\n            start += 1;\n            end -= 1;\n        }\n        return true;\n    }\n};", "compare_result": "11111111111111111111111111111"}, {"id": 217187610, "lang": "cpp", "time": "9\u00a0months, 2\u00a0weeks", "timestamp": 1553413275, "status_display": "Accepted", "runtime": "12 ms", "url": "/submissions/detail/217187610/", "is_pending": "Not Pending", "title": "Jump Game II", "memory": "10.5 MB", "code": "class Solution {\npublic:\n//     int jump(vector<int>& nums) {\n        \n//         int A[nums.size()] ;\n//         for(int i = 1;i < nums.size();i ++){\n//             A[i] = 0x7fffffff;\n//         }\n//         A[0] = 0;\n        \n//         cout << nums.size() << endl;\n        \n//         for (int i =0 ;i < nums.size();i ++){\n            \n//             for(int j = 1;(j <= nums[i])&&((i+j) < nums.size()) ;j ++){\n//                 A[i+j] = min(A[i+j],A[i]+1);\n//             }\n            \n//             if ((i+nums[i]) >= (nums.size()-1)){\n//                 break;\n//             }\n//         }\n        \n//         return A[nums.size()-1];\n//     }\n    \n    int jump(vector<int>& nums){\n        \n        int steps = 0;\n        int start = 0;\n        int end = 0;\n        int n = nums.size();\n        \n        while(end < (n-1)){\n            \n            int maxend = end+1;\n            steps += 1;\n            for(int i = start;i <= end ;i ++){\n                if((i+nums[i] >= (n-1))) return steps; \n                maxend = max(maxend,i+nums[i]);\n            }\n            start = end;\n            end = maxend;\n        }\n        \n        return steps;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 217184389, "lang": "cpp", "time": "9\u00a0months, 2\u00a0weeks", "timestamp": 1553412183, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/217184389/", "is_pending": "Not Pending", "title": "Jump Game II", "memory": "N/A", "code": "class Solution {\npublic:\n    int jump(vector<int>& nums) {\n        \n        int A[nums.size()] ;\n        for(int i = 1;i < nums.size();i ++){\n            A[i] = 0x7fffffff;\n        }\n        A[0] = 0;\n        \n        for (int i =0 ;i < nums.size();i ++){\n            \n            for(int j = 1;(j <= nums[i])&&((i+j) < nums.size()) ;j ++){\n                A[i+j] = min(A[i+j],A[i]+1);\n            }\n            \n            if ((i+nums[i]) >= (nums.size()-1)){\n                break;\n            }\n        }\n        \n        return A[nums.size()-1];\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110"}, {"id": 217183970, "lang": "cpp", "time": "9\u00a0months, 2\u00a0weeks", "timestamp": 1553412047, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/217183970/", "is_pending": "Not Pending", "title": "Jump Game II", "memory": "N/A", "code": "class Solution {\npublic:\n    int jump(vector<int>& nums) {\n        \n        int A[nums.size()] ;\n        for(int i = 1;i < nums.size();i ++){\n            A[i] = 0x7fffffff;\n        }\n        A[0] = 0;\n        \n        for (int i =0 ;i < nums.size();i ++){\n            for(int j = 1;(j <= nums[i])&&((i+j) < nums.size()) ;j ++){\n                A[i+j] = min(A[i+j],A[i]+1);\n            } \n        }\n        \n        return A[nums.size()-1];\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110"}, {"id": 217179369, "lang": "cpp", "time": "9\u00a0months, 2\u00a0weeks", "timestamp": 1553410525, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/217179369/", "is_pending": "Not Pending", "title": "Interleaving String", "memory": "8.4 MB", "code": "class Solution {\npublic:\n    bool isInterleave(string s1, string s2, string s3) {\n        if ((s1.length() + s2.length()) != s3.length()) return false;\n        \n        //A represents whethere s3 is made by s1 and s2\n        int A[s1.length()+1][s2.length()+1] ;\n        \n        \n        for(int i = 0;i <= s1.length();i ++){\n            for(int j = 0;j <= s2.length();j ++){\n                A[i][j] = 0;\n            }\n        }\n        A[0][0] = 1;\n        for(int i = 0;i <= s1.length();i ++){\n            for (int j = 0;j <=s2.length();j ++){\n                if (((i-1) >= 0) && (A[i-1][j] == 1) && (s3[i+j-1] == s1[i-1])){\n                    A[i][j] = 1;\n                }\n                \n                if (((j-1) >= 0) && (A[i][j-1] == 1) &&(s3[i+j-1] == s2[j-1])){\n                    A[i][j] = 1;\n                }\n            }\n        }\n        \n        for(int i = 0;i < s1.length();i ++)\n            cout << A[i][0] << '\\t';\n        return A[s1.length()][s2.length()] == 1;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 216755166, "lang": "cpp", "time": "9\u00a0months, 2\u00a0weeks", "timestamp": 1553254783, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/216755166/", "is_pending": "Not Pending", "title": "Shortest Palindrome", "memory": "N/A", "code": "class Solution {\npublic:\n    string shortestPalindrome(string s) {\n        int size = s.length();\n        if (size <= 1) return s;\n        \n        int idx = 0;\n        int move = 0;\n        string stmp ;\n        for(size_t i = s.length()/2;i >= 1;i --){\n            stmp = s.substr(i,i);\n            string stmp2 = s.substr(i+1,i);\n            reverse(stmp.begin(),stmp.end());\n            reverse(stmp2.begin(),stmp2.end());\n            // cout << s.substr(0,i) << \"\\t\" << stmp << endl;\n             if(s.substr(0,i) == stmp2){\n                idx = i;\n                move = 1;\n                break;\n            }\n            if(s.substr(0,i) == stmp){\n                idx = i;\n                break;\n            }\n            \n        }\n        // cout << idx << \" \" << move << endl;\n        if (idx >0){\n            stmp = string(\"\");\n            if ((s.length()-2*idx-move) >0){\n                stmp = s.substr(idx*2+move,s.length()-2*idx-move);\n            }\n            reverse(stmp.begin(),stmp.end());\n            return  stmp + s;\n        }else{\n            stmp = s.substr(1,s.length()-1);\n            reverse(stmp.begin(),stmp.end());\n            return stmp + s;\n        }\n        \n        return s;\n            \n            \n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 216754203, "lang": "cpp", "time": "9\u00a0months, 2\u00a0weeks", "timestamp": 1553254038, "status_display": "Output Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/216754203/", "is_pending": "Not Pending", "title": "Shortest Palindrome", "memory": "N/A", "code": "class Solution {\npublic:\n    string shortestPalindrome(string s) {\n        int size = s.length();\n        if (size <= 1) return s;\n        \n        int idx = 0;\n        int move = 0;\n        string stmp ;\n        for(size_t i = s.length()/2;i >= 1;i --){\n            stmp = s.substr(i,i);\n            string stmp2 = s.substr(i+1,i);\n            reverse(stmp.begin(),stmp.end());\n            reverse(stmp2.begin(),stmp2.end());\n            cout << s.substr(0,i) << \"\\t\" << stmp << endl;\n             if(s.substr(0,i) == stmp2){\n                idx = i;\n                move = 1;\n                break;\n            }\n            if(s.substr(0,i) == stmp){\n                idx = i;\n                break;\n            }\n            \n        }\n        cout << idx << \" \" << move << endl;\n        if (idx >0){\n            stmp = string(\"\");\n            if ((s.length()-2*idx-move) >0){\n                stmp = s.substr(idx*2+move,s.length()-2*idx-move);\n            }\n            reverse(stmp.begin(),stmp.end());\n            return  stmp + s;\n        }else{\n            stmp = s.substr(1,s.length()-1);\n            reverse(stmp.begin(),stmp.end());\n            return stmp + s;\n        }\n        \n        return s;\n            \n            \n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110"}, {"id": 215623440, "lang": "cpp", "time": "9\u00a0months, 3\u00a0weeks", "timestamp": 1552875869, "status_display": "Output Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/215623440/", "is_pending": "Not Pending", "title": "Shortest Palindrome", "memory": "N/A", "code": "class Solution {\npublic:\n    string shortestPalindrome(string s) {\n        int size = s.length();\n        if (size <= 1) return s;\n        \n        int idx = 0;\n        int move = 0;\n        string stmp ;\n        for(size_t i = s.length()/2;i >= 1;i --){\n            stmp = s.substr(i,i);\n            string stmp2 = s.substr(i+1,i);\n            reverse(stmp.begin(),stmp.end());\n            reverse(stmp2.begin(),stmp2.end());\n            cout << s.substr(0,i) << \"\\t\" << stmp << endl;\n             if(s.substr(0,i) == stmp2){\n                idx = i;\n                move = 1;\n                break;\n            }\n            if(s.substr(0,i) == stmp){\n                idx = i;\n                break;\n            }\n            \n        }\n        // cout << idx << \" \" << move << endl;\n        if (idx >0){\n            stmp = string(\"\");\n            if ((s.length()-2*idx-move) >0){\n                stmp = s.substr(idx*2+move,s.length()-2*idx-move);\n            }\n            reverse(stmp.begin(),stmp.end());\n            return  stmp + s;\n        }else{\n            stmp = s.substr(1,s.length()-1);\n            reverse(stmp.begin(),stmp.end());\n            return stmp + s;\n        }\n        \n        return s;\n            \n            \n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110"}, {"id": 215198040, "lang": "cpp", "time": "9\u00a0months, 3\u00a0weeks", "timestamp": 1552735363, "status_display": "Output Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/215198040/", "is_pending": "Not Pending", "title": "Shortest Palindrome", "memory": "N/A", "code": "class Solution {\npublic:\n    string shortestPalindrome(string s) {\n        int size = s.length();\n        if (size <= 1) return s;\n        \n        int idx = 0;\n        int move = 0;\n        string stmp ;\n        for(int i = size/2;i >= 1;i --){\n            stmp = s.substr(i,i);\n            string stmp2 = s.substr(i+1,i);\n            reverse(stmp.begin(),stmp.end());\n            reverse(stmp2.begin(),stmp2.end());\n            cout << s.substr(0,i) << \"\\t\" << stmp << endl;\n             if(s.substr(0,i) == stmp2){\n                idx = i;\n                move = 1;\n                break;\n            }\n            if(s.substr(0,i) == stmp){\n                idx = i;\n                break;\n            }\n            \n        }\n        cout << idx << \" \" << move << endl;\n        if (idx >0){\n            stmp = s.substr(idx*2+move,s.length()-2*idx-move);\n            reverse(stmp.begin(),stmp.end());\n            return  stmp + s;\n        }else{\n            stmp = s.substr(1,s.length()-1);\n            reverse(stmp.begin(),stmp.end());\n            return stmp + s;\n        }\n        \n            \n            \n            \n    }\n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110"}, {"id": 215197550, "lang": "cpp", "time": "9\u00a0months, 3\u00a0weeks", "timestamp": 1552735010, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/215197550/", "is_pending": "Not Pending", "title": "Shortest Palindrome", "memory": "N/A", "code": "class Solution {\npublic:\n    string shortestPalindrome(string s) {\n        int size = s.length();\n        if (size <= 1) return s;\n        \n        int idx = 0;\n        int move = 0;\n        string stmp ;\n        for(int i = size/2;i >= 1;i --){\n            stmp = s.substr(i,i);\n            string stmp2 = s.substr(i+1,i);\n            reverse(stmp.begin(),stmp.end());\n            reverse(stmp2.begin(),stmp2.end());\n            // cout << s.substr(0,i) << \"\\t\" << stmp << endl;\n             if(s.substr(0,i) == stmp2){\n                idx = i;\n                move = 1;\n                break;\n            }\n            if(s.substr(0,i) == stmp){\n                idx = i;\n                break;\n            }\n            \n        }\n        if (idx >0){\n            stmp = s.substr(idx*2,s.length()-2*idx-move);\n            reverse(stmp.begin(),stmp.end());\n            return  stmp + s;\n        }else{\n            stmp = s.substr(1,s.length()-1);\n            reverse(stmp.begin(),stmp.end());\n            return stmp + s;\n        }\n        \n            \n            \n            \n    }\n};", "compare_result": "111111111111110000111111111111111111111111111111110111111111111111111111111111111111111111111111111111111111011111111111"}, {"id": 215188696, "lang": "cpp", "time": "9\u00a0months, 3\u00a0weeks", "timestamp": 1552729007, "status_display": "Accepted", "runtime": "44 ms", "url": "/submissions/detail/215188696/", "is_pending": "Not Pending", "title": "Word Break II", "memory": "18.2 MB", "code": "class Solution {\npublic:\n    \n    vector<string> wordBreak(string s, vector<string>& wordDict1) {\n        \n        unordered_set<string> wordDict = unordered_set<string>();\n        for(string t: wordDict1){\n            wordDict.insert(t);\n        }\n        unordered_map<int, vector<string>> memo {{s.size(), {\"\"}}};\n        function<vector<string>(int)> sentences = [&](int i) {\n            if (!memo.count(i))\n                for (int j=i+1; j<=s.size(); j++)\n                    if (wordDict.count(s.substr(i, j-i)))\n                        for (string tail : sentences(j))\n                            memo[i].push_back(s.substr(i, j-i) + (tail==\"\" ? \"\" : ' ' + tail));\n            return memo[i];\n        };\n        return sentences(0);\n}\n    \n    vector<string> wordBreak1(string s, vector<string>& wordDict) {\n        \n        map<string,int> mp = map<string,int>();\n        map<char,int> cmp = map<char,int>();\n        int minL = 0x7fffffff;\n        int maxL = 0;\n        vector<string> results = vector<string>();\n        \n        for(string &a : wordDict){\n            mp[a] = 1;\n            for (char &c : a){\n                cmp[c] = 1;\n            }\n            maxL = max((int)a.length(),maxL);\n            minL = min((int)a.length(),minL);\n        }\n        \n        for(char&c : s){\n            if(cmp[c]==0)\n                return results;\n        }\n        \n        \n        \n        vector<string> ivc = vector<string>();\n       \n        \n        wDFS(s,0,mp,ivc,results,minL,maxL);\n        return results;\n    }\n    \n    void wDFS(string s, int idx,map<string,int> &mp,vector<string> &ivc,vector<string>&results,int&minL,int &maxL){\n        if (idx >= s.length()){\n            // cout << idx << endl;\n            results.push_back(join(ivc));\n            return;\n        }\n        \n        for(int i = minL;i <= maxL; i++){\n            if((idx+i) <= s.length()){\n                if(mp[s.substr(idx,i)] >0){\n                    ivc.push_back(s.substr(idx,i));\n                    // cout << s.substr(idx,i) << \"\\t\" << idx << \"\\t\" << idx+i << endl;\n                    wDFS(s,idx+i,mp,ivc,results,minL,maxL);\n                    ivc.pop_back();\n                }\n            }\n        }\n    }\n    \n    \n    string join(vector<string>& vc){\n        string s=\"\";\n        for(int i =0;i < vc.size();i ++){\n            if (i > 0){\n                s = s + string(\" \");\n            }\n            s = s + vc[i];\n        }\n        // cout << s << \"  s \" << endl;\n        return s;\n    }\n    \n};", "compare_result": "111111111111111111111111111111111111111"}, {"id": 215188028, "lang": "cpp", "time": "9\u00a0months, 3\u00a0weeks", "timestamp": 1552728631, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/215188028/", "is_pending": "Not Pending", "title": "Word Break II", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\n        \n        map<string,int> mp = map<string,int>();\n        map<char,int> cmp = map<char,int>();\n        int minL = 0x7fffffff;\n        int maxL = 0;\n        vector<string> results = vector<string>();\n        \n        for(string &a : wordDict){\n            mp[a] = 1;\n            for (char &c : a){\n                cmp[c] = 1;\n            }\n            maxL = max((int)a.length(),maxL);\n            minL = min((int)a.length(),minL);\n        }\n        \n        for(char&c : s){\n            if(cmp[c]==0)\n                return results;\n        }\n        \n        \n        \n        vector<string> ivc = vector<string>();\n       \n        \n        wDFS(s,0,mp,ivc,results,minL,maxL);\n        return results;\n    }\n    \n    void wDFS(string s, int idx,map<string,int> &mp,vector<string> &ivc,vector<string>&results,int&minL,int &maxL){\n        if (idx >= s.length()){\n            // cout << idx << endl;\n            results.push_back(join(ivc));\n            return;\n        }\n        \n        for(int i = minL;i <= maxL; i++){\n            if((idx+i) <= s.length()){\n                if(mp[s.substr(idx,i)] >0){\n                    ivc.push_back(s.substr(idx,i));\n                    // cout << s.substr(idx,i) << \"\\t\" << idx << \"\\t\" << idx+i << endl;\n                    wDFS(s,idx+i,mp,ivc,results,minL,maxL);\n                    ivc.pop_back();\n                }\n            }\n        }\n    }\n    \n    \n    string join(vector<string>& vc){\n        string s=\"\";\n        for(int i =0;i < vc.size();i ++){\n            if (i > 0){\n                s = s + string(\" \");\n            }\n            s = s + vc[i];\n        }\n        // cout << s << \"  s \" << endl;\n        return s;\n    }\n    \n};", "compare_result": "111111111111111111111111111111110000000"}, {"id": 215187044, "lang": "cpp", "time": "9\u00a0months, 3\u00a0weeks", "timestamp": 1552728110, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/215187044/", "is_pending": "Not Pending", "title": "Word Break II", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\n        \n        map<string,int> mp = map<string,int>();\n        int minL = 0x7fffffff;\n        int maxL = 0;\n        for(string &a : wordDict){\n            mp[a] = 1;\n            maxL = max((int)a.length(),maxL);\n            minL = min((int)a.length(),minL);\n        }\n        vector<string> ivc = vector<string>();\n        vector<string> results = vector<string>();\n        wDFS(s,0,mp,ivc,results,minL,maxL);\n        return results;\n    }\n    \n    void wDFS(string s, int idx,map<string,int> &mp,vector<string> &ivc,vector<string>&results,int&minL,int &maxL){\n        if (idx >= s.length()){\n            // cout << idx << endl;\n            results.push_back(join(ivc));\n            return;\n        }\n        \n        for(int i = minL;i <= maxL; i++){\n            if((idx+i) <= s.length()){\n                if(mp[s.substr(idx,i)] >0){\n                    ivc.push_back(s.substr(idx,i));\n                    // cout << s.substr(idx,i) << \"\\t\" << idx << \"\\t\" << idx+i << endl;\n                    wDFS(s,idx+i,mp,ivc,results,minL,maxL);\n                    ivc.pop_back();\n                }\n            }\n        }\n        \n        \n        \n    }\n    \n    \n    string join(vector<string>& vc){\n        string s=\"\";\n        for(int i =0;i < vc.size();i ++){\n            if (i > 0){\n                s = s + string(\" \");\n            }\n            s = s + vc[i];\n        }\n        // cout << s << \"  s \" << endl;\n        return s;\n    }\n    \n};", "compare_result": "111111111111111111111111111111100000000"}, {"id": 215179339, "lang": "cpp", "time": "9\u00a0months, 3\u00a0weeks", "timestamp": 1552724387, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/215179339/", "is_pending": "Not Pending", "title": "K-th Smallest in Lexicographical Order", "memory": "8.5 MB", "code": "class Solution {\npublic:\n    int findKthNumber(int n, int k) {\n        int ans = 1;\n        // int sp = 1;\n        k = k-1;\n        while(k>0){\n            int gap = steps(n,ans,ans+1);\n            // cout << gap << \"\\t\" << k << endl;\n            if (gap <= k){\n                ans += 1;\n                k -= gap;\n            }else{\n                ans *= 10;\n                k = k-1;\n            }\n        }\n        return ans;\n        \n    }\n    int steps(long n,long n1,long n2){\n        int ms = 0;\n        while(n1 <= n){\n            ms  += min(n+1,n2)-n1;\n            n1 *= 10;\n            n2 *= 10;\n        }\n        return ms;\n    }\n    \n\n    \n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 215178848, "lang": "cpp", "time": "9\u00a0months, 3\u00a0weeks", "timestamp": 1552724169, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/215178848/", "is_pending": "Not Pending", "title": "K-th Smallest in Lexicographical Order", "memory": "N/A", "code": "class Solution {\npublic:\n    int findKthNumber(int n, int k) {\n        int ans = 1;\n        // int sp = 1;\n        while(k>1){\n            int gap = steps(n,ans,ans+1);\n            // cout << gap << \"\\t\" << k << endl;\n            if (gap <= k){\n                ans += 1;\n                k -= gap;\n            }else{\n                ans *= 10;\n                k = k-1;\n            }\n        }\n        return ans;\n        \n    }\n    int steps(long n,long n1,long n2){\n        int ms = 0;\n        while(n1 <= n){\n            ms  += min(n+1,n2)-n1;\n            n1 *= 10;\n            n2 *= 10;\n        }\n        return ms;\n    }\n    \n\n    \n};", "compare_result": "111111111111011100111011111111011111110000111111111111111110001111111"}, {"id": 215167932, "lang": "cpp", "time": "9\u00a0months, 3\u00a0weeks", "timestamp": 1552719772, "status_display": "Accepted", "runtime": "328 ms", "url": "/submissions/detail/215167932/", "is_pending": "Not Pending", "title": "Best Time to Buy and Sell Stock IV", "memory": "9.3 MB", "code": "class Solution {\npublic:\n    int maxProfit(int k, vector<int>& prices) {\n        if (k <=0 || prices.size() <= 0) return 0;\n        if (k >= prices.size()){\n            // int TA[prices.size()];\n            int total = 0;\n            for(int i = 1;i < prices.size();i ++){\n                if((prices[i]- prices[i-1] )> 0){\n                    total += (prices[i]- prices[i-1] );\n                }\n            }\n            return total;\n        }\n        \n        int A[k+1][prices.size()];\n        for(int i =0;i < prices.size();i ++){\n            A[0][i] = 0;\n        }\n        for(int i = 0;i <= k;i ++){\n            A[i][0] = 0;\n        }\n        \n        \n        \n        for(int i =1;i <= k;i ++){\n            int maxj = 0;\n            for(int j =1;j < prices.size();j ++){\n                int tmpk = 0;\n                for(int k = 0;k < j;k ++){\n                    int pk = A[i-1][k] + prices[j] - prices[k];\n                    if(tmpk < pk){\n                        tmpk = pk;\n                    }\n                }\n                A[i][j] = max(tmpk,maxj);\n                maxj = max(maxj,A[i][j]);\n            }\n        }\n        \n        return A[k][prices.size()-1];\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 215167836, "lang": "cpp", "time": "9\u00a0months, 3\u00a0weeks", "timestamp": 1552719738, "status_display": "Compile Error", "runtime": "N/A", "url": "/submissions/detail/215167836/", "is_pending": "Not Pending", "title": "Best Time to Buy and Sell Stock IV", "memory": "N/A", "code": "class Solution {\npublic:\n    int maxProfit(int k, vector<int>& prices) {\n        if (k <=0 || prices.size() <= 0) return 0;\n        int A[k+1][prices.size()];\n        for(int i =0;i < prices.size();i ++){\n            A[0][i] = 0;\n        }\n        for(int i = 0;i <= k;i ++){\n            A[i][0] = 0;\n        }\n        \n        if (k >= prices.size()){\n            // int TA[prices.size()];\n            int total = 0\n            for(int i = 1;i < prices.size()){\n                if((prices[i]- prices[i-1] )> 0){\n                    total += (prices[i]- prices[i-1] );\n                }\n            }\n            return total;\n        }\n        \n        for(int i =1;i <= k;i ++){\n            int maxj = 0;\n            for(int j =1;j < prices.size();j ++){\n                int tmpk = 0;\n                for(int k = 0;k < j;k ++){\n                    int pk = A[i-1][k] + prices[j] - prices[k];\n                    if(tmpk < pk){\n                        tmpk = pk;\n                    }\n                }\n                A[i][j] = max(tmpk,maxj);\n                maxj = max(maxj,A[i][j]);\n            }\n        }\n        \n        return A[k][prices.size()-1];\n    }\n};", "compare_result": null}, {"id": 215167083, "lang": "cpp", "time": "9\u00a0months, 3\u00a0weeks", "timestamp": 1552719451, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/215167083/", "is_pending": "Not Pending", "title": "Best Time to Buy and Sell Stock IV", "memory": "N/A", "code": "class Solution {\npublic:\n    int maxProfit(int k, vector<int>& prices) {\n        if (k <=0 || prices.size() <= 0) return 0;\n        int A[k+1][prices.size()];\n        for(int i =0;i < prices.size();i ++){\n            A[0][i] = 0;\n        }\n        for(int i = 0;i <= k;i ++){\n            A[i][0] = 0;\n        }\n        \n        for(int i =1;i <= k;i ++){\n            int maxj = 0;\n            for(int j =1;j < prices.size();j ++){\n                int tmpk = 0;\n                for(int k = 0;k < j;k ++){\n                    int pk = A[i-1][k] + prices[j] - prices[k];\n                    if(tmpk < pk){\n                        tmpk = pk;\n                    }\n                }\n                A[i][j] = max(tmpk,maxj);\n                maxj = max(maxj,A[i][j]);\n            }\n        }\n        \n        return A[k][prices.size()-1];\n    }\n};", "compare_result": null}, {"id": 215161712, "lang": "cpp", "time": "9\u00a0months, 3\u00a0weeks", "timestamp": 1552717481, "status_display": "Accepted", "runtime": "256 ms", "url": "/submissions/detail/215161712/", "is_pending": "Not Pending", "title": "Largest Component Size by Common Factor", "memory": "28.4 MB", "code": "\n\nclass Solution {\n    class UnionFindSet {\npublic:\n    UnionFindSet(int n) : _parent(n) {\n        for (int i=0; i<n; i++) {\n            _parent[i] = i;\n        }\n    }\n    \n    void Union(int x, int y) {\n        _parent[Find(x)] = _parent[Find(y)];\n    }\n    \n    int Find(int x) {\n        if (_parent[x] != x) {\n            _parent[x] = Find(_parent[x]);\n        }\n        return _parent[x];\n    }\n    \nprivate:\n    vector<int> _parent;\n};\npublic:\n    int largestComponentSize(vector<int>& A) {\n        int n = *max_element(A.begin(), A.end());\n        UnionFindSet ufs(n+1);\n        for (int &a : A) {\n            for (int k = 2; k <= sqrt(a); k++) {\n                if (a % k == 0) {\n                    ufs.Union(a, k);\n                    ufs.Union(a, a / k);\n                }\n            }\n        }\n        \n        unordered_map<int, int> mp;\n        int ans = 1;\n        for (int &a : A) {\n            ans = max(ans, ++mp[ufs.Find(a)]);\n        }\n        return ans;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 215159630, "lang": "cpp", "time": "9\u00a0months, 3\u00a0weeks", "timestamp": 1552716725, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/215159630/", "is_pending": "Not Pending", "title": "Largest Component Size by Common Factor", "memory": "N/A", "code": "class Solution {\npublic:\n    int largestComponentSize(vector<int>& A) {\n        \n        map<int,int >used = map<int,int>();\n        map<int,int >left = map<int,int>();\n        map<int,int >all = map<int,int>();\n        \n        map<int,vector<int> *>* pmap = getConnectMap(A);\n        int maxSize = 0;\n        \n        for(int i =0;i < A.size();i ++){\n            if (all.find(A[i]) == all.end()){\n                // cout << A[i] <<endl;\n                used.clear();\n                left.clear();\n                findDFS(used,A[i],left,pmap);\n                \n                if(maxSize < used.size()){\n                    maxSize = used.size();\n                }\n                \n                for(map<int,int>::iterator it = used.begin();it != used.end();it ++){\n                    all.insert(pair<int,int>(it->first,1));\n                }\n            }\n        }\n        \n        return maxSize;\n    }\n    \n    \n    void findDFS(map<int,int>&used,int val,map<int,int> &left,map<int,vector<int> *>* pmap){\n        map<int,int>::iterator it = used.find(val);\n        // cout << val <<endl;\n        if(it == used.end()){\n            used.insert(pair<int,int>(val,1));\n        }\n        \n        it = left.find(val);\n        if (it != left.end()){\n            left.erase(it);\n        }\n        map<int,vector<int> *>::iterator pit = pmap->find(val);\n        vector<int> *pvc = pit->second;\n        \n        // cout << \"a\" << endl;\n        for (int i =0;i < pvc->size();i ++){\n            if (used.find(pvc->at(i)) == used.end()){\n                left.insert(pair<int,int>(pvc->at(i),1));\n            }\n        }\n        // cout << \"b\" << endl;\n        if (left.size() > 0){\n            map<int,int >::iterator pfirst = left.begin();\n            int fv = pfirst->first;\n            left.erase(pfirst);\n            // cout << \"c\" << endl;\n            findDFS(used,fv,left,pmap);\n            // cout << \"d\" << endl;\n        }\n        \n    }\n    \n    map<int,vector<int>* >* getConnectMap(vector<int>&A){\n        map<int,vector<int>* > *pmap = new map<int,vector<int>* >();\n        // map<pair<int,int>,int> cache = map<pairt<int,int>,int>();\n        for(int i =0;i < A.size();i ++){\n            vector<int> *vic  = new vector<int>();\n            pmap->insert(pair<int,vector<int>*>(A[i],vic));\n        }\n        for(int i =0;i < A.size();i ++){            \n            vector<int> *vic  = pmap->find(A[i])->second;\n            for(int j =i+1;j < A.size();j ++){\n                if(i != j){\n                    int gcd = getGcd(max(A[i],A[j]),min(A[i],A[j]));\n                    if (gcd > 1){\n                        vic->push_back(A[j]);\n                        vector<int>* jvic = pmap->find(A[j])->second;\n                        jvic->push_back(A[i]);\n                    }\n                }\n            }\n            \n            // pmap->insert(pair<int,vector<int>*>(A[i],vic));\n        }\n        \n        return pmap;\n    }\n    \n    \n    \n    int getGcd(int a,int b){\n        if (b == 0) return a;\n        return getGcd(b,a%b);\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111110000000000000000000000000000"}, {"id": 215157145, "lang": "cpp", "time": "9\u00a0months, 3\u00a0weeks", "timestamp": 1552715878, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/215157145/", "is_pending": "Not Pending", "title": "Largest Component Size by Common Factor", "memory": "N/A", "code": "class Solution {\npublic:\n    int largestComponentSize(vector<int>& A) {\n        \n        map<int,int >used = map<int,int>();\n        map<int,int >left = map<int,int>();\n        map<int,int >all = map<int,int>();\n        \n        map<int,vector<int> *>* pmap = getConnectMap(A);\n        int maxSize = 0;\n        \n        for(int i =0;i < A.size();i ++){\n            if (all.find(A[i]) == all.end()){\n                // cout << A[i] <<endl;\n                used.clear();\n                left.clear();\n                findDFS(used,A[i],left,pmap);\n                \n                if(maxSize < used.size()){\n                    maxSize = used.size();\n                }\n                \n                for(map<int,int>::iterator it = used.begin();it != used.end();it ++){\n                    all.insert(pair<int,int>(it->first,1));\n                }\n            }\n        }\n        \n        return maxSize;\n    }\n    \n    \n    void findDFS(map<int,int>&used,int val,map<int,int> &left,map<int,vector<int> *>* pmap){\n        map<int,int>::iterator it = used.find(val);\n        // cout << val <<endl;\n        if(it == used.end()){\n            used.insert(pair<int,int>(val,1));\n        }\n        \n        it = left.find(val);\n        if (it != left.end()){\n            left.erase(it);\n        }\n        map<int,vector<int> *>::iterator pit = pmap->find(val);\n        vector<int> *pvc = pit->second;\n        \n        // cout << \"a\" << endl;\n        for (int i =0;i < pvc->size();i ++){\n            if (used.find(pvc->at(i)) == used.end()){\n                left.insert(pair<int,int>(pvc->at(i),1));\n            }\n        }\n        // cout << \"b\" << endl;\n        if (left.size() > 0){\n            map<int,int >::iterator pfirst = left.begin();\n            int fv = pfirst->first;\n            left.erase(pfirst);\n            // cout << \"c\" << endl;\n            findDFS(used,fv,left,pmap);\n            // cout << \"d\" << endl;\n        }\n        \n    }\n    \n    \n    \n    \n    \n    map<int,vector<int>* >* getConnectMap(vector<int>&A){\n        map<int,vector<int>* > *pmap = new map<int,vector<int>* >();\n        for(int i =0;i < A.size();i ++){            \n            vector<int> *vic  = new vector<int>();\n            for(int j =0;j < A.size();j ++){\n                if(i != j){\n                    int gcd = getGcd(max(A[i],A[j]),min(A[i],A[j]));\n                    if (gcd > 1){\n                        vic->push_back(A[j]);\n                    }\n                }\n            }\n            \n            pmap->insert(pair<int,vector<int>*>(A[i],vic));\n        }\n        \n        return pmap;\n    }\n    \n    \n    \n    int getGcd(int a,int b){\n        if (b == 0) return a;\n        return getGcd(b,a%b);\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111110000000000000000000000000000"}, {"id": 213750106, "lang": "cpp", "time": "9\u00a0months, 4\u00a0weeks", "timestamp": 1552227473, "status_display": "Accepted", "runtime": "40 ms", "url": "/submissions/detail/213750106/", "is_pending": "Not Pending", "title": "Median of Two Sorted Arrays", "memory": "21.4 MB", "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        \n        int l = (nums1.size() + nums2.size()+1)/2;\n        int r = (nums1.size() + nums2.size()+2)/2;\n        \n        return (1.0*getK(nums1,0,nums2,0,l) + 1.0*getK(nums1,0,nums2,0,r))/2;\n        \n    }\n    \n    int getK(vector<int>&nums1,int startA,vector<int>& nums2,int startB,int k){\n        if(startA > ((int)nums1.size()-1)) return nums2[startB+k-1];\n        if(startB > ((int)nums2.size()-1)) return nums1[startA+k-1];\n\n        if (k == 1) return min(nums1[startA],nums2[startB]);\n       \n        int midA = 0x7fffffff;\n        int midB = 0x7fffffff;\n        \n        if((startA+k/2-1) < nums1.size()) midA = nums1[startA+k/2-1];\n        if((startB+k/2-1) < nums2.size()) midB = nums2[startB+k/2-1];\n        \n        if(midA < midB){\n            return getK(nums1,startA+k/2,nums2,startB,k-k/2);\n        }else{\n            return getK(nums1,startA,nums2,startB+k/2,k-k/2);\n        }\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 213735352, "lang": "cpp", "time": "9\u00a0months, 4\u00a0weeks", "timestamp": 1552219947, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/213735352/", "is_pending": "Not Pending", "title": "Median of Two Sorted Arrays", "memory": "N/A", "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        \n        int l = (nums1.size() + nums2.size()+1)/2;\n        int r = (nums1.size() + nums2.size()+2)/2;\n        \n        return (1.0*getK(nums1,0,nums2,0,l) + 1.0*getK(nums1,0,nums2,0,r))/2;\n        \n    }\n    \n    int getK(vector<int>&nums1,int startA,vector<int>& nums2,int startB,int k){\n        if(startA > nums1.size()-1) return nums2[startB+k-1];\n        if(startB > nums2.size()-1) return nums1[startA+k-1];\n        if (k == 1) return min(nums1[startA],nums2[startB]);\n        \n        int midA = 0x7fffffff;\n        int midB = 0x7fffffff;\n        \n        if((startA+k/2-1) < nums1.size()) midA = nums1[startA+k/2-1];\n        if((startB+k/2-1) < nums2.size()) midB = nums2[startB+k/2-1];\n        \n        if(midA < midB){\n            return getK(nums1,startA+k/2,nums2,startB,k-k/2);\n        }else{\n            return getK(nums1,startA,nums2,startB+k/2,k-k/2);\n        }\n    }\n};", "compare_result": null}, {"id": 213501260, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1552146463, "status_display": "Accepted", "runtime": "128 ms", "url": "/submissions/detail/213501260/", "is_pending": "Not Pending", "title": "Create Maximum Number", "memory": "136.6 MB", "code": "class Solution {\npublic:\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\n        \n        vector<vector<int> > nv1 = max1(nums1);\n        vector<vector<int> > nv2 = max1(nums2);\n        vector<int> r = vector<int>(k);\n        fill(r.begin(),r.end(),0);\n        \n        for(int i = 0;i <= k/2;i ++){\n            \n            if(i <= nums1.size() && (k-i) <= nums2.size()){\n                vector<int> tp = merge(nv1[i],nv2[k-i]);\n                r = max2(r,tp);\n            }\n            \n            \n            if(i <= nums2.size() && (k-i) <= nums1.size()){\n                vector<int> tp = merge(nv2[i],nv1[k-i]);\n                r = max2(r,tp);\n            }\n        }\n        \n        return r;\n    }\n    \n    vector<int> max2(vector<int> &v1, vector<int>&v2){\n        for(int i = 0;i < v2.size();i ++){\n            if(v2[i] < v1[i]){\n                return v1;\n            }else if(v2[i] > v1[i]){\n                return v2;\n            }\n            \n        }\n        return v2;\n    }\n    \n    vector<vector<int> > max1(vector<int>&nums){\n        vector<vector<int> > vret = vector<vector<int> >(nums.size());\n        vector<int> tmp = nums;\n        vret.push_back(vector<int>(tmp));\n        int vlen = nums.size();\n        \n        for(int i = 0;i < vlen-1;i ++){\n            bool status = true;\n            for(int j =1;j < tmp.size();j ++){\n                if (tmp[j-1]  < tmp[j]){\n                    tmp.erase(tmp.begin()+j-1);\n                    status = false;\n                    break;\n                }\n            }\n            if(status){\n                tmp.pop_back();\n            }\n            vret.push_back(vector<int>(tmp));\n        }\n        vret.push_back(vector<int>());\n        return vector<vector<int> >(vret.rbegin(),vret.rend());\n    }\n    \n    vector<int> merge(vector<int> &num1,vector<int>&num2){\n        int j = 0;\n        vector<int> r = vector<int>();\n        int i = 0;\n        while(i < num1.size()){\n            if(j < num2.size() && num1[i] < num2[j]){\n                r.push_back(num2[j++]);\n            }else if (j < num2.size() && num1[i] == num2[j]){\n                bool cc = max3(vector<int>(num1.begin()+i,num1.end()),vector<int>(num2.begin()+j,num2.end()));\n                if(!cc){\n                    r.push_back(num1[i++]);\n                }else{\n                    r.push_back(num2[j++]);\n                }\n                \n            }else{\n                r.push_back(num1[i++]);\n            }\n        }\n        while(j < num2.size()){\n            r.push_back(num2[j++]);\n        }\n        return r;\n    }\n    \n    // v1 < v2 ?\n    bool max3(vector<int>v1,vector<int>v2){\n        int l = v1.size() < v2.size() ? v1.size():v2.size();\n        bool r = v1.size() < v2.size();\n        \n        for(int i =0; i < l;i ++){\n            if (v1[i] < v2[i]){\n                r = true;\n                break;\n            }else if (v1[i] > v2[i]){\n                r = false;\n                break;\n            }\n        }\n        return r;\n    }\n    \n    \n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 213500178, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1552145985, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/213500178/", "is_pending": "Not Pending", "title": "Create Maximum Number", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\n        \n        vector<vector<int> > nv1 = max1(nums1);\n        vector<vector<int> > nv2 = max1(nums2);\n        vector<int> r = vector<int>(k);\n        fill(r.begin(),r.end(),0);\n        \n        for(int i = 0;i <= k/2;i ++){\n            \n            if(i <= nums1.size() && (k-i) <= nums2.size()){\n                vector<int> tp = merge(nv1[i],nv2[k-i]);\n                r = max2(r,tp);\n            }\n            \n            \n            if(i <= nums2.size() && (k-i) <= nums1.size()){\n                vector<int> tp = merge(nv2[i],nv1[k-i]);\n                r = max2(r,tp);\n            }\n        }\n        \n        return r;\n    }\n    \n    vector<int> max2(vector<int> &v1, vector<int>&v2){\n        for(int i = 0;i < v2.size();i ++){\n            if(v2[i] < v1[i]){\n                return v1;\n            }else if(v2[i] > v1[i]){\n                return v2;\n            }\n            \n        }\n        return v2;\n    }\n    \n    vector<vector<int> > max1(vector<int>&nums){\n        vector<vector<int> > vret = vector<vector<int> >(nums.size());\n        vector<int> tmp = nums;\n        vret.push_back(vector<int>(tmp));\n        int vlen = nums.size();\n        \n        for(int i = 0;i < vlen-1;i ++){\n            bool status = true;\n            for(int j =1;j < tmp.size();j ++){\n                if (tmp[j-1]  < tmp[j]){\n                    tmp.erase(tmp.begin()+j-1);\n                    status = false;\n                    break;\n                }\n            }\n            if(status){\n                tmp.pop_back();\n            }\n            vret.push_back(vector<int>(tmp));\n        }\n        vret.push_back(vector<int>());\n        return vector<vector<int> >(vret.rbegin(),vret.rend());\n    }\n    \n    vector<int> merge(vector<int> &num1,vector<int>&num2){\n        int j = 0;\n        vector<int> r = vector<int>();\n        int i = 0;\n        while(i < num1.size()){\n            if(j < num2.size() && num1[i] < num2[j]){\n                r.push_back(num2[j++]);\n            }else if (j < num2.size() && num1[i] == num2[j]){\n                int n1  = (i +1 < num1.size()) ? num1[i+1]:-1;\n                int n2  = (j +1 < num2.size()) ? num2[j+1]:-1;\n                if(n1 > n2){\n                    r.push_back(num1[i++]);\n                }else{\n                    r.push_back(num2[j++]);\n                }\n                \n            }else{\n                r.push_back(num1[i++]);\n            }\n        }\n        while(j < num2.size()){\n            r.push_back(num2[j++]);\n        }\n        return r;\n    }\n    \n};", "compare_result": "111111111111111111111111111111111111111111110111111111111111111111111111111111111111111111000000000111"}, {"id": 213499585, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1552145684, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/213499585/", "is_pending": "Not Pending", "title": "Create Maximum Number", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\n        \n        vector<vector<int> > nv1 = max1(nums1);\n        vector<vector<int> > nv2 = max1(nums2);\n        vector<int> r = vector<int>(k);\n        fill(r.begin(),r.end(),0);\n        \n        for(int i = 0;i <= k/2;i ++){\n            \n            if(i <= nums1.size() && (k-i) <= nums2.size()){\n                vector<int> tp = merge(nv1[i],nv2[k-i]);\n                r = max2(r,tp);\n            }\n            \n            \n            if(i <= nums2.size() && (k-i) <= nums1.size()){\n                vector<int> tp = merge(nv2[i],nv1[k-i]);\n                r = max2(r,tp);\n            }\n        }\n        \n        return r;\n    }\n    \n    vector<int> max2(vector<int> &v1, vector<int>&v2){\n        for(int i = 0;i < v2.size();i ++){\n            if(v2[i] < v1[i]){\n                return v1;\n            }else if(v2[i] > v1[i]){\n                return v2;\n            }\n            \n        }\n        return v2;\n    }\n    \n    vector<vector<int> > max1(vector<int>&nums){\n        vector<vector<int> > vret = vector<vector<int> >(nums.size());\n        vector<int> tmp = nums;\n        vret.push_back(vector<int>(tmp));\n        int vlen = nums.size();\n        \n        for(int i = 0;i < vlen-1;i ++){\n            bool status = true;\n            for(int j =1;j < tmp.size();j ++){\n                if (tmp[j-1]  < tmp[j]){\n                    tmp.erase(tmp.begin()+j-1);\n                    status = false;\n                    break;\n                }\n            }\n            if(status){\n                tmp.pop_back();\n            }\n            vret.push_back(vector<int>(tmp));\n        }\n        vret.push_back(vector<int>());\n        return vector<vector<int> >(vret.rbegin(),vret.rend());\n    }\n    \n    vector<int> merge(vector<int> &num1,vector<int>&num2){\n        int j = 0;\n        vector<int> r = vector<int>();\n        int i = 0;\n        while(i < num1.size()){\n            if(j < num2.size() && num1[i] < num2[j]){\n                r.push_back(num2[j++]);\n            }else if (j < num2.size() && num1[i] == num2[j]){\n                int n1  = (i +1 < num1.size()) ? num1[i+1]:-1;\n                int n2  = (i +1 < num2.size()) ? num2[i+1]:-1;\n                if(n1 > n2){\n                    r.push_back(num1[i++]);\n                }else{\n                    r.push_back(num2[j++]);\n                }\n                \n            }else{\n                r.push_back(num1[i++]);\n            }\n        }\n        while(j < num2.size()){\n            r.push_back(num2[j++]);\n        }\n        return r;\n    }\n    \n};", "compare_result": "111111111111111111111111111111111100101111010010010111010100011111110111101011110010101110000000000111"}, {"id": 213498652, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1552145270, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/213498652/", "is_pending": "Not Pending", "title": "Create Maximum Number", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\n        \n        vector<vector<int> > nv1 = max1(nums1);\n        vector<vector<int> > nv2 = max1(nums2);\n        vector<int> r = vector<int>(k);\n        fill(r.begin(),r.end(),0);\n        \n        for(int i = 0;i <= k/2;i ++){\n            \n            if(i <= nums1.size() && (k-i) <= nums2.size()){\n                vector<int> tp = merge(nv1[i],nv2[k-i]);\n                r = max2(r,tp);\n            }\n            \n            \n            if(i <= nums2.size() && (k-i) <= nums1.size()){\n                vector<int> tp = merge(nv2[i],nv1[k-i]);\n                r = max2(r,tp);\n            }\n        }\n        \n        return r;\n    }\n    \n    vector<int> max2(vector<int> &v1, vector<int>&v2){\n        for(int i = 0;i < v2.size();i ++){\n            if(v2[i] < v1[i]){\n                return v1;\n            }else if(v2[i] > v1[i]){\n                return v2;\n            }\n            \n        }\n        return v2;\n    }\n    \n    vector<vector<int> > max1(vector<int>&nums){\n        vector<vector<int> > vret = vector<vector<int> >(nums.size());\n        vector<int> tmp = nums;\n        vret.push_back(vector<int>(tmp));\n        int vlen = nums.size();\n        \n        for(int i = 0;i < vlen-1;i ++){\n            bool status = true;\n            for(int j =1;j < tmp.size();j ++){\n                if (tmp[j-1]  < tmp[j]){\n                    tmp.erase(tmp.begin()+j-1);\n                    status = false;\n                    break;\n                }\n            }\n            if(status){\n                tmp.pop_back();\n            }\n            vret.push_back(vector<int>(tmp));\n        }\n        vret.push_back(vector<int>());\n        return vector<vector<int> >(vret.rbegin(),vret.rend());\n    }\n    \n    vector<int> merge(vector<int> &num1,vector<int>&num2){\n        int j = 0;\n        vector<int> r = vector<int>();\n        int i = 0;\n        while(i < num1.size()){\n            if(j < num2.size() && num1[i] <= num2[j]){\n                r.push_back(num2[j++]);\n            }else{\n                r.push_back(num1[i++]);\n            }\n        }\n        while(j < num2.size()){\n            r.push_back(num2[j++]);\n        }\n        return r;\n    }\n    \n};", "compare_result": "101111111111111111111111111111111000001110010010000110000100011110100110100011010010100010000000000111"}, {"id": 213498302, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1552145115, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/213498302/", "is_pending": "Not Pending", "title": "Create Maximum Number", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\n        \n        vector<vector<int> > nv1 = max1(nums1);\n        vector<vector<int> > nv2 = max1(nums2);\n        vector<int> r = vector<int>(k);\n        fill(r.begin(),r.end(),0);\n        \n        for(int i = 0;i <= k/2;i ++){\n            \n            if(i <= nums1.size() && (k-i) <= nums2.size()){\n                vector<int> tp = merge(nv1[i],nv2[k-i]);\n                r = max2(r,tp);\n            }\n            \n            \n            if(i <= nums2.size() && (k-i) <= nums1.size()){\n                vector<int> tp = merge(nv2[i],nv1[k-i]);\n                r = max2(r,tp);\n            }\n        }\n        \n        return r;\n    }\n    \n    vector<int> max2(vector<int> &v1, vector<int>&v2){\n        for(int i = 0;i < v2.size();i ++){\n            if(v2[i] < v1[i]){\n                return v1;\n            }else if(v2[i] > v1[i]){\n                return v2;\n            }\n            \n        }\n        return v2;\n    }\n    \n    vector<vector<int> > max1(vector<int>&nums){\n        vector<vector<int> > vret = vector<vector<int> >(nums.size());\n        vector<int> tmp = nums;\n        vret.push_back(vector<int>(tmp));\n        int vlen = nums.size();\n        \n        for(int i = 0;i < vlen-1;i ++){\n            bool status = true;\n            for(int j =1;j < tmp.size();j ++){\n                if (tmp[j-1]  < tmp[j]){\n                    tmp.erase(tmp.begin()+j-1);\n                    status = false;\n                    break;\n                }\n            }\n            if(status){\n                tmp.pop_back();\n            }\n            vret.push_back(vector<int>(tmp));\n        }\n        vret.push_back(vector<int>());\n        return vector<vector<int> >(vret.rbegin(),vret.rend());\n    }\n    \n    vector<int> merge(vector<int> &num1,vector<int>&num2){\n        int j = 0;\n        vector<int> r = vector<int>();\n        int i = 0;\n        while(i < num1.size()){\n            if(j < num2.size() && num1[i] < num2[j]){\n                r.push_back(num2[j++]);\n            }else{\n                r.push_back(num1[i++]);\n            }\n        }\n        while(j < num2.size()){\n            r.push_back(num2[j++]);\n        }\n        return r;\n    }\n    \n};", "compare_result": "111111111111111111111111111101111101111100010010011101010001010111111001001001111011101110000000000111"}, {"id": 213488118, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1552140173, "status_display": "Accepted", "runtime": "20 ms", "url": "/submissions/detail/213488118/", "is_pending": "Not Pending", "title": "Longest Valid Parentheses", "memory": "11.9 MB", "code": "class Solution {\npublic:\n    int longestValidParentheses(string s) {\n        stack<pair<char,int> > cstack = stack<pair<char,int> >();\n        vector<int> svec= vector<int>(s.length());\n        fill(svec.begin(),svec.end(),0);\n        int mx = 0;\n        int cr = 0;\n        for(int i =0;i < s.length();i ++){\n            if(s[i] == '('){\n                cstack.push(pair<char,int>(s[i],i));\n            }else{\n                if(cstack.empty() || cstack.top().first != '('){\n                    cstack.push(pair<char,int>(s[i],i));\n                    cr = 0;\n                }else{\n                    pair<char,int> bt = cstack.top();\n                    svec[bt.second] = 1;\n                    svec[i] = 1;\n                    cstack.pop();\n                }\n            }\n        }\n        for(int i = 0; i < svec.size();i ++){\n            if(svec[i] == 1){\n                cr += 1;\n            }else{\n                if (mx < cr){\n                    mx = cr;\n                }\n                cr = 0;\n            }\n        }\n        if(mx < cr){\n            mx = cr;\n        }\n        return mx;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 213485020, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1552138581, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/213485020/", "is_pending": "Not Pending", "title": "Longest Valid Parentheses", "memory": "N/A", "code": "class Solution {\npublic:\n    int longestValidParentheses(string s) {\n        stack<char> cstack = stack<char>();\n        int mx = 0;\n        int cr = 0;\n        for(int i =0;i < s.length();i ++){\n            if(s[i] == '('){\n                cstack.push(s[i]);\n            }else{\n                if(cstack.empty() || cstack.top() != '('){\n                    if (mx < cr){\n                        mx = cr;\n                    }\n                    cr = 0;\n                }else{\n                    cstack.pop();\n                    cr += 2;\n                }\n            }\n        }\n        if(mx < cr){\n            mx = cr;\n        }\n        return mx;\n    }\n};", "compare_result": "11111111111011111111111111111111111110111111101110110111110111111110110011111110101101110101111111111011111111111111100101011011111000001110100000011010110100011010101010101100000111011100000101101011110010011110011000000000110101"}, {"id": 213481966, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1552136928, "status_display": "Accepted", "runtime": "476 ms", "url": "/submissions/detail/213481966/", "is_pending": "Not Pending", "title": "Decode Ways II", "memory": "16.4 MB", "code": "class Solution {\npublic:\n    int numDecodings(string s) {\n        int sum = 0;\n        map<string,int> dmap = map<string,int>();\n        char tmp[50];\n        for (int i =1;i <= 26;i ++){\n            sprintf(tmp,\"%d\",i);\n            dmap.insert(pair<string,int>(string(tmp),1));\n        }\n        dmap.insert(pair<string,int>(string(\"1*\"),9));\n        dmap.insert(pair<string,int>(string(\"2*\"),6));\n        for (int i =1;i <= 6;i ++){\n            sprintf(tmp,\"*%d\",i);\n            dmap.insert(pair<string,int>(string(tmp),2));\n        }\n        for (int i =7;i <= 9;i ++){\n            sprintf(tmp,\"*%d\",i);\n            dmap.insert(pair<string,int>(string(tmp),1));\n        }\n        // dmap.put()\n        dmap.insert(pair<string,int>(string(\"*\"),9));\n        dmap.insert(pair<string,int>(string(\"*0\"),2));\n        dmap.insert(pair<string,int>(string(\"**\"),15));\n        \n        long n0 =1;\n        long n1 = 1;\n        \n        for (int i = 0;i < s.length();i ++){\n            string st = s.substr(i,1);\n            long cr = getcount(n1,dmap,st);\n            if (i >=1){\n                st = s.substr(i-1,2);\n                cr += getcount(n0,dmap,st);\n            }\n            cr = cr%(long(1e9+7));\n            \n            n0 = n1;\n            n1 = cr;\n        }\n        return n1;\n    }\n    \n    long getcount(long n,map<string,int>&dmap,string&st){\n        map<string,int>::iterator it = dmap.find(st);\n        long cr = 0;\n        if(it != dmap.end()){\n            cr = it->second * n;\n        }\n        return cr;\n    }\n    \n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 213481628, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1552136729, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/213481628/", "is_pending": "Not Pending", "title": "Decode Ways II", "memory": "N/A", "code": "class Solution {\npublic:\n    int numDecodings(string s) {\n        int sum = 0;\n        map<string,int> dmap = map<string,int>();\n        char tmp[50];\n        for (int i =1;i <= 26;i ++){\n            sprintf(tmp,\"%d\",i);\n            dmap.insert(pair<string,int>(string(tmp),1));\n        }\n        dmap.insert(pair<string,int>(string(\"1*\"),9));\n        dmap.insert(pair<string,int>(string(\"2*\"),6));\n        for (int i =1;i <= 6;i ++){\n            sprintf(tmp,\"*%d\",i);\n            dmap.insert(pair<string,int>(string(tmp),2));\n        }\n        for (int i =7;i <= 9;i ++){\n            sprintf(tmp,\"*%d\",i);\n            dmap.insert(pair<string,int>(string(tmp),1));\n        }\n        // dmap.put()\n        dmap.insert(pair<string,int>(string(\"*\"),9));\n        dmap.insert(pair<string,int>(string(\"**\"),15));\n        \n        long n0 =1;\n        long n1 = 1;\n        \n        for (int i = 0;i < s.length();i ++){\n            string st = s.substr(i,1);\n            long cr = getcount(n1,dmap,st);\n            if (i >=1){\n                st = s.substr(i-1,2);\n                cr += getcount(n0,dmap,st);\n            }\n            cr = cr%(long(1e9+7));\n            \n            n0 = n1;\n            n1 = cr;\n        }\n        return n1;\n    }\n    \n    long getcount(long n,map<string,int>&dmap,string&st){\n        map<string,int>::iterator it = dmap.find(st);\n        long cr = 0;\n        if(it != dmap.end()){\n            cr = it->second * n;\n        }\n        return cr;\n    }\n    \n};", "compare_result": "111111111111001110011111111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110001111111111111111111111101111111111111111111111111"}, {"id": 213481383, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1552136592, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/213481383/", "is_pending": "Not Pending", "title": "Decode Ways II", "memory": "N/A", "code": "class Solution {\npublic:\n    int numDecodings(string s) {\n        int sum = 0;\n        map<string,int> dmap = map<string,int>();\n        char tmp[50];\n        for (int i =1;i <= 26;i ++){\n            sprintf(tmp,\"%d\",i);\n            dmap.insert(pair<string,int>(string(tmp),1));\n        }\n        dmap.insert(pair<string,int>(string(\"1*\"),9));\n        dmap.insert(pair<string,int>(string(\"2*\"),6));\n        for (int i =1;i <= 6;i ++){\n            sprintf(tmp,\"*%d\",i);\n            dmap.insert(pair<string,int>(string(tmp),2));\n        }\n        for (int i =7;i <= 9;i ++){\n            sprintf(tmp,\"*%d\",i);\n            dmap.insert(pair<string,int>(string(tmp),1));\n        }\n        // dmap.put()\n        dmap.insert(pair<string,int>(string(\"*\"),9));\n        dmap.insert(pair<string,int>(string(\"**\"),15));\n        \n        long n0 =1;\n        long n1 = 1;\n        \n        for (int i = 0;i < s.length();i ++){\n            string st = s.substr(i,1);\n            long cr = getcount(n1,dmap,st);\n            if (i >=1){\n                st = s.substr(i-1,2);\n                cr += getcount(n0,dmap,st);\n            }\n            cr = cr%(long(1e9+7));\n            \n            n0 = n1;\n            n1 = cr;\n        }\n        return n1;\n    }\n    \n    int getcount(int n,map<string,int>&dmap,string&st){\n        map<string,int>::iterator it = dmap.find(st);\n        int cr = 0;\n        if(it != dmap.end()){\n            cr = it->second * n;\n        }\n        return cr;\n    }\n    \n};", "compare_result": null}, {"id": 213447821, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1552118123, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/213447821/", "is_pending": "Not Pending", "title": "Nth Magical Number", "memory": "8.8 MB", "code": "class Solution {\npublic:\n    int nthMagicalNumber(int N, int A, int B) {\n        \n        long l = 2;\n        long r = 1e14;\n        int lcm = get_lcm(A,B);\n        \n        // cout << lcm << \"\\t\" << endl;\n        \n        int da = A*1.0;\n        int db = B * 1.0;\n        int dc =  lcm*1.0;\n        int dn = N * 1.0;\n        while (l < r){\n            long m = l + (r-l)/2;\n            double k = m/da + m/db - m/dc;\n            cout << k << '\\t' << m << endl;\n            if (k < dn){\n                l = m+1;\n            }else {\n                r = m;\n            }\n        }\n        // cout << l << endl;\n        return l%(long(1e9+7));\n    }\n    \n    int get_lcm(int A,int B){\n        int a = A > B ? A : B;\n        int b = A > B ? B : A;\n        \n        int gcd = get_gcd(a,b);\n        \n        return A*B/gcd;\n    }\n    int get_gcd(int A,int B){\n        if (B == 0) return A;\n        else return get_gcd(B,A%B);\n    }\n    \n};", "compare_result": "111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 213447368, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1552117954, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/213447368/", "is_pending": "Not Pending", "title": "Nth Magical Number", "memory": "N/A", "code": "class Solution {\npublic:\n    int nthMagicalNumber(int N, int A, int B) {\n        \n        long l = 2;\n        long r = 1e14;\n        int lcm = get_lcm(A,B);\n        \n        // cout << lcm << \"\\t\" << endl;\n        \n        int da = A*1.0;\n        int db = B * 1.0;\n        int dc =  lcm*1.0;\n        int dn = N * 1.0;\n        while (l < r){\n            long m = l + (r-l)/2;\n            double k = m/da + m/db - m/dc;\n            cout << k << '\\t' << m << endl;\n            if (k < dn){\n                l = m+1;\n            }else {\n                r = m-1;\n            }\n        }\n        // cout << l << endl;\n        return l%(long(1e9+7));\n    }\n    \n    int get_lcm(int A,int B){\n        int a = A > B ? A : B;\n        int b = A > B ? B : A;\n        \n        int gcd = get_gcd(a,b);\n        \n        return A*B/gcd;\n    }\n    int get_gcd(int A,int B){\n        if (B == 0) return A;\n        else return get_gcd(B,A%B);\n    }\n    \n};", "compare_result": "101111011001110111011011001001111111110011010111000011111111110101"}, {"id": 213446362, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1552117585, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/213446362/", "is_pending": "Not Pending", "title": "Nth Magical Number", "memory": "N/A", "code": "class Solution {\npublic:\n    int nthMagicalNumber(int N, int A, int B) {\n        \n        long l = 2;\n        long r = 1e14;\n        int lcm = get_lcm(A,B);\n        \n        // cout << lcm << \"\\t\" << endl;\n        \n        int da = A*1.0;\n        int db = B * 1.0;\n        int dc =  lcm*1.0;\n        int dn = N * 1.0;\n        while (l < r){\n            long m = l + (r-l)/2;\n            double k = m/da + m/db - m/dc;\n            if (k < dn){\n                l = m+1;\n            }else if (k > dn){\n                r = m-1;\n            }else{\n                l = m;\n                break;\n            }\n        }\n        // cout << l << endl;\n        return l%(long(1e9+7));\n    }\n    \n    int get_lcm(int A,int B){\n        int a = A > B ? A : B;\n        int b = A > B ? B : A;\n        \n        int gcd = get_gcd(a,b);\n        \n        return A*B/gcd;\n    }\n    int get_gcd(int A,int B){\n        if (B == 0) return A;\n        else return get_gcd(B,A%B);\n    }\n    \n};", "compare_result": "111010110110001000010110000000000000000000000000000000000000000000"}, {"id": 213445568, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1552117274, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/213445568/", "is_pending": "Not Pending", "title": "Nth Magical Number", "memory": "N/A", "code": "class Solution {\npublic:\n    int nthMagicalNumber(int N, int A, int B) {\n        \n        long l = 2;\n        long r = 1e14;\n        int lcm = get_lcm(A,B);\n        \n        // cout << lcm << \"\\t\" << endl;\n        \n        while (l < r){\n            long m = l + (r-l)/2;\n            long k = m/A + m/B - m/lcm;\n            if (k < N){\n                l = m+1;\n            }else{\n                r = m-1;\n            }\n        }\n        // cout << l << endl;\n        return l%(long(1e9+7));\n    }\n    \n    int get_lcm(int A,int B){\n        int a = A > B ? A : B;\n        int b = A > B ? B : A;\n        \n        int gcd = get_gcd(a,b);\n        \n        return A*B/gcd;\n    }\n    int get_gcd(int A,int B){\n        if (B == 0) return A;\n        else return get_gcd(B,A%B);\n    }\n    \n};", "compare_result": "101111011001110111011011001001111111110011010111000011111111110101"}, {"id": 212426620, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1551757271, "status_display": "Accepted", "runtime": "120 ms", "url": "/submissions/detail/212426620/", "is_pending": "Not Pending", "title": "LRU Cache", "memory": "38.1 MB", "code": "class LRUCache {\npublic:\n    \n    struct DLink{\n        DLink *left;\n        DLink *right;\n        pair<int,int> value;\n    };\n\n    DLink * remove(DLink* &head, DLink * tar){\n        // if head is target\n        if(tar == head){\n            head = head->right;\n        }\n\n        // remove tar\n        tar->right->left = tar->left;\n        tar->left->right = tar->right;\n\n        // if tar is head\n        if (tar == head){\n            head = NULL;\n            // delete tar;\n        }\n        return tar;\n    }\n\n\n    DLink * addToHead(DLink *head,DLink * tar){\n        if (head == NULL){\n            head = tar;\n            head->left = tar;\n            head->right = tar;\n        }else{\n            tar->right = head;\n            tar->left = head->left;\n            tar->left->right = tar;\n            tar->right->left = tar;\n            head = tar;\n        }\n        return head;\n    }\n\n    DLink* head = NULL;\n    int capacity = 0;\n    int current = 0;\n    map<int,DLink*> dmap = map<int,DLink*>();\n    LRUCache(int capacity) {\n        this->capacity = capacity;\n    }\n    \n    int get(int key) {\n        map<int,DLink*>::iterator it = dmap.find(key);\n        if( it == dmap.end()){\n            return -1;\n        }else{\n            // move to the head\n            remove(this->head,it->second);\n            this->head = addToHead(this->head,it->second);\n            return it->second->value.second;\n        }\n    }\n    \n    void put(int key, int value) {\n        map<int,DLink*>::iterator it = dmap.find(key);\n        if( it == dmap.end()){\n            // need add one\n            DLink *p = new DLink();\n            p->value.first = key;\n            p->value.second = value;\n\n            if (current == capacity){\n                // need to remove the last one\n                dmap.erase(dmap.find(head->left->value.first));\n                delete remove(this->head,this->head->left);\n            }else{\n                current += 1;\n            }\n            this->head = addToHead(this->head,p);\n            //add to map\n            dmap.insert(pair<int,DLink*>(key,p));\n            return ;\n        }else{\n            // move that to the head\n            remove(this->head,it->second);\n            it->second->value.second = value;\n            this->head = addToHead(this->head,it->second);\n            // return it->second.value.second;\n        }\n        return;\n    }\n};", "compare_result": "111111111111111111"}, {"id": 212426285, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1551757201, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/212426285/", "is_pending": "Not Pending", "title": "LRU Cache", "memory": "N/A", "code": "class LRUCache {\npublic:\n    \n    struct DLink{\n        DLink *left;\n        DLink *right;\n        pair<int,int> value;\n    };\n\n    DLink * remove(DLink* &head, DLink * tar){\n        // if head is target\n        if(tar == head){\n            head = head->right;\n        }\n\n        // remove tar\n        tar->right->left = tar->left;\n        tar->left->right = tar->right;\n\n        // if tar is head\n        if (tar == head){\n            head = NULL;\n            // delete tar;\n        }\n        return tar;\n    }\n\n\n    DLink * addToHead(DLink *head,DLink * tar){\n        if (head == NULL){\n            head = tar;\n            head->left = tar;\n            head->right = tar;\n        }else{\n            tar->right = head;\n            tar->left = head->left;\n            tar->left->right = tar;\n            tar->right->left = tar;\n            head = tar;\n        }\n        return head;\n    }\n\n    DLink* head = NULL;\n    int capacity = 0;\n    int current = 0;\n    map<int,DLink*> dmap = map<int,DLink*>();\n    LRUCache(int capacity) {\n        this->capacity = capacity;\n    }\n    \n    int get(int key) {\n        map<int,DLink*>::iterator it = dmap.find(key);\n        if( it == dmap.end()){\n            return -1;\n        }else{\n            // move to the head\n            remove(this->head,it->second);\n            this->head = addToHead(this->head,it->second);\n            return it->second->value.second;\n        }\n    }\n    \n    void put(int key, int value) {\n        map<int,DLink*>::iterator it = dmap.find(key);\n        if( it == dmap.end()){\n            // need add one\n            DLink *p = new DLink();\n            p->value.first = key;\n            p->value.second = value;\n\n            if (current == capacity){\n                // need to remove the last one\n                dmap.erase(dmap.find(head->left->value.first));\n                delete remove(this->head,this->head->left);\n            }else{\n                current += 1;\n            }\n            this->head = addToHead(this->head,p);\n            //add to map\n            dmap.insert(pair<int,DLink*>(key,p));\n            return ;\n        }else{\n            // move that to the head\n            remove(this->head,it->second);\n            this->head = addToHead(this->head,it->second);\n            // return it->second.value.second;\n        }\n        return;\n    }\n};", "compare_result": "111110100110000000"}, {"id": 212265857, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1551702446, "status_display": "Accepted", "runtime": "8 ms", "url": "/submissions/detail/212265857/", "is_pending": "Not Pending", "title": "Split Array With Same Average", "memory": "8.9 MB", "code": "class Solution {\npublic:\n    bool splitArraySameAverage(vector<int>& A) {\n        int sumA = 0;\n        for (int i = 0;i < A.size(); i ++){\n            sumA += A[i];\n        }\n        sort(A.begin(),A.end());\n        for(int i = 1;i <= A.size()/2;i ++){\n            if((sumA*i)%A.size() == 0){\n                if(check(A,sumA*i/A.size(),i,0)) return true;\n            }\n        }\n        return false;\n    }\n    \n    bool check(vector<int>&A,int sumB,int numB,int indexStart){\n        if (numB == 0) return sumB == 0;\n        if(A[indexStart] > sumB/numB) return false;\n        for(int i = indexStart;i < A.size()- numB + 1;i ++){\n            if(i > indexStart && A[i] == A[i-1]) continue;\n            if(check(A,sumB-A[i],numB-1,i+1)){\n                return true;\n            }\n        }\n        return false;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 212265799, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1551702414, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/212265799/", "is_pending": "Not Pending", "title": "Split Array With Same Average", "memory": "N/A", "code": "class Solution {\npublic:\n    bool splitArraySameAverage(vector<int>& A) {\n        int sumA = 0;\n        for (int i = 0;i < A.size(); i ++){\n            sumA += A[i];\n        }\n        sort(A.begin(),A.end());\n        for(int i = 1;i <= A.size()/2;i ++){\n            if((sumA*i)%A.size() == 0){\n                if(check(A,sumA*i/A.size(),i,0)) return true;\n            }\n        }\n        return false;\n    }\n    \n    bool check(vector<int>&A,int sumB,int numB,int indexStart){\n        if (numB == 0) return sumB == 0;\n        if(A[indexStart] > sumB/numB) return false;\n        for(int i = indexStart;i < A.size()- numB + 1;i ++){\n            // if(i > indexStart && A[i] == A[i-1]) continue;\n            if(check(A,sumB-A[i],numB-1,i+1)){\n                return true;\n            }\n        }\n        return false;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111110000000000000000000000000000"}, {"id": 212265755, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1551702396, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/212265755/", "is_pending": "Not Pending", "title": "Split Array With Same Average", "memory": "8.9 MB", "code": "class Solution {\npublic:\n    bool splitArraySameAverage(vector<int>& A) {\n        int sumA = 0;\n        for (int i = 0;i < A.size(); i ++){\n            sumA += A[i];\n        }\n        sort(A.begin(),A.end());\n        for(int i = 1;i <= A.size()/2;i ++){\n            if((sumA*i)%A.size() == 0){\n                if(check(A,sumA*i/A.size(),i,0)) return true;\n            }\n        }\n        return false;\n    }\n    \n    bool check(vector<int>&A,int sumB,int numB,int indexStart){\n        if (numB == 0) return sumB == 0;\n        if(A[indexStart] > sumB/numB) return false;\n        for(int i = indexStart;i < A.size()- numB + 1;i ++){\n            if(i > indexStart && A[i] == A[i-1]) continue;\n            if(check(A,sumB-A[i],numB-1,i+1)){\n                return true;\n            }\n        }\n        return false;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 212265595, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1551702322, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/212265595/", "is_pending": "Not Pending", "title": "Split Array With Same Average", "memory": "N/A", "code": "class Solution {\npublic:\n    bool splitArraySameAverage(vector<int>& A) {\n        int sumA = 0;\n        for (int i = 0;i < A.size(); i ++){\n            sumA += A[i];\n        }\n        sort(A.begin(),A.end());\n        for(int i = 1;i < A.size()/2;i ++){\n            if((sumA*i)%A.size() == 0){\n                if(check(A,sumA*i/A.size(),i,0)) return true;\n            }\n        }\n        return false;\n    }\n    \n    bool check(vector<int>&A,int sumB,int numB,int indexStart){\n        if (numB == 0) return sumB == 0;\n        if(A[indexStart] > sumB*1.0/numB) return false;\n        for(int i = indexStart;i < A.size()- numB + 1;i ++){\n            if(i > indexStart && A[i] == A[i-1]) continue;\n            if(check(A,sumB-A[i],numB-1,i+1)){\n                return true;\n            }\n        }\n        return false;\n    }\n};", "compare_result": "1111111111001111111111111101111101111101111111111111111110111111111111101111111111111111"}, {"id": 212265346, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1551702200, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/212265346/", "is_pending": "Not Pending", "title": "Split Array With Same Average", "memory": "N/A", "code": "class Solution {\npublic:\n    bool splitArraySameAverage(vector<int>& A) {\n        int sumA = 0;\n        for (int i = 0;i < A.size(); i ++){\n            sumA += A[i];\n        }\n        sort(A.begin(),A.end());\n        for(int i = 1;i < A.size()/2;i ++){\n            if((sumA*i)%A.size() == 0){\n                if(check(A,sumA*i/A.size(),i,0)) return true;\n            }\n        }\n        return false;\n    }\n    \n    bool check(vector<int>&A,int sumB,int numB,int indexStart){\n        if (numB == 0) return sumB == 0;\n        if(A[indexStart] > sumB*1.0/numB) return false;\n        for(int i = indexStart;i < A.size();i ++){\n            if(check(A,sumB-A[i],numB-1,i+1)){\n                return true;\n            }\n        }\n        return false;\n    }\n};", "compare_result": null}, {"id": 212262589, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1551700819, "status_display": "Time Limit Exceeded", "runtime": "N/A", "url": "/submissions/detail/212262589/", "is_pending": "Not Pending", "title": "Split Array With Same Average", "memory": "N/A", "code": "class Solution {\npublic:\n    bool splitArraySameAverage(vector<int>& A) {\n        int sum = 0;\n        sort(A.begin(),A.end());\n        for (int i = 0;i < A.size();i ++){\n            sum += A[i];\n        }\n        double avg = sum*1.0/A.size();\n        // cout << avg << endl;\n        vector<bool> status = vector<bool>(A.size());\n        fill(status.begin(),status.end(),true);\n        return check(A,avg,status,0,0);\n    }\n\n    bool check(vector<int>&A,double avg,vector<bool> &status,int counts,int sum ){\n        if (counts*avg == sum && counts >0 && counts < A.size()){\n            // cout << counts << sum << endl;\n            return true;\n        }\n\n        for (int i = 0;i < status.size();i ++){\n            if(status[i]){\n                status[i] = false;\n                if(check(A,avg,status,counts+1,sum+A[i])){\n                    return true;\n                }\n                status[i] = true;\n            }\n        }\n        return false;\n    }\n\n\n};\n", "compare_result": "1111111111111111111111111111111111111100000000000000000000000000000000000000000000000000"}, {"id": 212260995, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1551700002, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/212260995/", "is_pending": "Not Pending", "title": "Split Array With Same Average", "memory": "N/A", "code": "class Solution {\npublic:\n    bool splitArraySameAverage(vector<int>& A) {\n        int sum = 0;\n        sort(A.begin(),A.end());\n        for (int i = 0;i < A.size();i ++){\n            sum += A[i];\n        }\n        if(sum %2 != 0) return false;\n        sum = sum/2;\n        vector<bool> status = vector<bool>(A.size());\n        fill(status.begin(),status.end(),true);\n        return check(A,sum,status,A.size());\n    }\n\n    bool check(vector<int>&A,int sum,vector<bool> &status,int counts){\n        if(counts <= 0 || sum <= 0){\n            return sum == 0&&counts>0;\n        } \n        for (int i = 0;i < status.size();i ++){\n            if(status[i]){\n                status[i] = false;\n                if(check(A,sum-A[i],status,counts-1)){\n                    return true;\n                }\n                status[i] = true;\n            }\n        }\n        return false;\n    }\n\n\n};", "compare_result": "1111011011011011000011010111010010101010101111101101101011100000000000000000000000000000"}, {"id": 212260924, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1551699961, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/212260924/", "is_pending": "Not Pending", "title": "Split Array With Same Average", "memory": "N/A", "code": "class Solution {\npublic:\n    bool splitArraySameAverage(vector<int>& A) {\n        int sum = 0;\n        sort(A.begin(),A.end());\n        for (int i = 0;i < A.size();i ++){\n            sum += A[i];\n        }\n        if(sum %2 != 0) return false;\n        sum = sum/2;\n        vector<bool> status = vector<bool>(A.size());\n        fill(status.begin(),status.end(),true);\n        return check(A,sum,status,A.size());\n    }\n\n    bool check(vector<int>&A,int sum,vector<bool> &status,int counts){\n        if(counts <= 0 || sum <= 0){\n            return sum == 0;\n        } \n        for (int i = 0;i < status.size();i ++){\n            if(status[i]){\n                status[i] = false;\n                if(check(A,sum-A[i],status,counts-1)){\n                    return true;\n                }\n                status[i] = true;\n            }\n        }\n        return false;\n    }\n\n\n};", "compare_result": "1111011011011011000011010111010010101010101111101101101011100000000000000000000000000000"}, {"id": 212025355, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1551629852, "status_display": "Accepted", "runtime": "840 ms", "url": "/submissions/detail/212025355/", "is_pending": "Not Pending", "title": "Substring with Concatenation of All Words", "memory": "249.5 MB", "code": "class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        int alphas[256];\n        int inits[256];\n        vector<int> locations = vector<int>();\n        if(words.size() == 0 ||s.length() ==0)  return locations;\n        int swlen = words[0].length();\n        fill(alphas,alphas+256,0);\n        fill(inits,inits+256,0);\n        int wlen = 0;\n        map<string,int> wmps = map<string,int>();\n        for(int i = 0;i < words.size(); i ++){\n            for (int j = 0; j < words[i].length(); j ++){\n                alphas[words[i][j]-'A'] += 1;\n            }\n            map<string,int>::iterator it = wmps.find(words[i]);\n            if (it == wmps.end()){\n                wmps.insert(pair<string,int>(words[i],1));\n            }else{\n                it->second += 1;\n            }\n            wlen += words[i].length();\n        }\n        \n        string wstring = \"\";\n        sort(words.begin(),words.end());\n        for(int i = 0;i < words.size();i ++){\n            wstring += words[i];\n        }\n        \n        // for(map<string,int>::iterator it = wmps.)\n        cout << wmps.size() << endl;\n        if (s.length() < wlen){\n            return locations;\n        }\n        long results = 0;\n        for(int i = 0;i < wlen;i ++){\n            inits[s[i]-'A'] += 1; \n            // cout << s[i] << '\\t' ;\n            // cout << inits[i]\n        }\n        \n        for (int i = 0;i < 256; i ++){\n            // cout << inits[i]  <<'\\t'<< alphas[i] << endl; \n            results += (inits[i] ^ alphas[i]);\n        }\n        // cout << results << endl;\n        int i = wlen;\n        for (i =wlen;i < s.length();i ++){\n            if (results == 0){\n                int status = 1;\n                \n                string subs = s.substr(i-wlen,wlen);\n                // cout << i-wlen << ' ' << i << endl;\n                // cout << subs << wlen << endl;\n                vector<string> stmp = vector<string>();\n                for(int k = 0;k < words.size();k ++){   \n                   // cout << subs.substr(k*swlen,swlen) << '\\t';\n                    stmp.push_back(subs.substr(k*swlen,swlen));\n                   if ( wmps.find(subs.substr(k*swlen,swlen)) == wmps.end()){\n                       \n                       status = 0;\n                       break;\n                   }\n                }\n                // cout << status << endl;\n                if (status == 1){\n                    sort(stmp.begin(),stmp.end());\n                    string ss = \"\";\n                    for(int i = 0;i < stmp.size();i ++){\n                        ss += stmp[i];\n                    }\n                    \n                    if (wstring == ss){\n                        locations.push_back(i-wlen);\n                    }\n                    \n                }\n            }\n            int idx1 = int(s[i]-'A');\n            int idx2 = int(s[i-wlen]-'A');\n            results -= (inits[idx1] ^ alphas[idx1]);\n            results -= (inits[idx2] ^ alphas[idx2]);\n            inits[idx1] += 1;\n            inits[idx2] -= 1;\n            // results += \n            results += (inits[idx1] ^ alphas[idx1]);\n            results += (inits[idx2] ^ alphas[idx2]);\n        }\n        if (results == 0){\n                int status = 1;\n                string subs = s.substr(i-wlen,wlen);\n                vector<string> stmp = vector<string>();\n                // cout << 'result 1' << endl;\n                for(int k = 0;k < words.size();k ++){   \n                  stmp.push_back(subs.substr(k*swlen,swlen));\n                   \n                  if ( wmps.find(subs.substr(k*swlen,swlen)) == wmps.end()){\n                       status = 0;\n                       \n                       break;\n                   }\n                }\n                // cout << status << endl;\n                if (status == 1){\n                    sort(stmp.begin(),stmp.end());\n                    string ss = \"\";\n                    for(int i = 0;i < stmp.size();i ++){\n                        ss += stmp[i];\n                    }\n                    // cout << wstring << ' ' << ss << endl;\n                    if (wstring == ss){\n                    locations.push_back(i-wlen);\n                    }\n                }\n        }\n        \n        return locations;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 212023718, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1551629122, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/212023718/", "is_pending": "Not Pending", "title": "Substring with Concatenation of All Words", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        int alphas[256];\n        int inits[256];\n        vector<int> locations = vector<int>();\n        if(words.size() == 0 ||s.length() ==0)  return locations;\n        int swlen = words[0].length();\n        fill(alphas,alphas+256,0);\n        fill(inits,inits+256,0);\n        int wlen = 0;\n        map<string,int> wmps = map<string,int>();\n        for(int i = 0;i < words.size(); i ++){\n            for (int j = 0; j < words[i].length(); j ++){\n                alphas[words[i][j]-'A'] += 1;\n            }\n            map<string,int>::iterator it = wmps.find(words[i]);\n            if (it == wmps.end()){\n                wmps.insert(pair<string,int>(words[i],1));\n            }else{\n                it->second += 1;\n            }\n            wlen += words[i].length();\n        }\n        // for(map<string,int>::iterator it = wmps.)\n        cout << wmps.size() << endl;\n        if (s.length() < wlen){\n            return locations;\n        }\n        long results = 0;\n        for(int i = 0;i < wlen;i ++){\n            inits[s[i]-'A'] += 1; \n            // cout << s[i] << '\\t' ;\n            // cout << inits[i]\n        }\n        \n        for (int i = 0;i < 256; i ++){\n            // cout << inits[i]  <<'\\t'<< alphas[i] << endl; \n            results += (inits[i] ^ alphas[i]);\n        }\n        // cout << results << endl;\n        int i = wlen;\n        for (i =wlen;i < s.length();i ++){\n            if (results == 0){\n                int status = 1;\n                \n                string subs = s.substr(i-wlen,wlen);\n                // cout << i-wlen << ' ' << i << endl;\n                // cout << subs << wlen << endl;\n                for(int k = 0;k < words.size();k ++){   \n                   // cout << subs.substr(k*swlen,swlen) << '\\t';\n                   if ( wmps.find(subs.substr(k*swlen,swlen)) == wmps.end()){\n                       status = 0;\n                       break;\n                   }\n                }\n                // cout << status << endl;\n                if (status == 1){\n                    locations.push_back(i-wlen);\n                }\n            }\n            int idx1 = int(s[i]-'A');\n            int idx2 = int(s[i-wlen]-'A');\n            results -= (inits[idx1] ^ alphas[idx1]);\n            results -= (inits[idx2] ^ alphas[idx2]);\n            inits[idx1] += 1;\n            inits[idx2] -= 1;\n            // results += \n            results += (inits[idx1] ^ alphas[idx1]);\n            results += (inits[idx2] ^ alphas[idx2]);\n        }\n        if (results == 0){\n                int status = 1;\n                \n                string subs = s.substr(i-wlen,wlen);\n                // cout << i-wlen << ' ' << i << endl;\n                // cout << subs << wlen << endl;\n                for(int k = 0;k < words.size();k ++){   \n                   \n                   if ( wmps.find(subs.substr(k*swlen,swlen)) == wmps.end()){\n                       status = 0;\n                       break;\n                   }\n                }\n                // cout << status << endl;\n                if (status == 1){\n                    locations.push_back(i-wlen);\n                }\n        }\n        \n        return locations;\n    }\n};", "compare_result": "11111111111111111111011011110111111100111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111111111111111111111111110"}, {"id": 212022853, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1551628745, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/212022853/", "is_pending": "Not Pending", "title": "Substring with Concatenation of All Words", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        int alphas[256];\n        int inits[256];\n        vector<int> locations = vector<int>();\n        if(words.size() == 0 ||s.length() ==0)  return locations;\n        int swlen = words[0].length();\n        fill(alphas,alphas+256,0);\n        fill(inits,inits+256,0);\n        int wlen = 0;\n        map<string,int> wmps = map<string,int>();\n        for(int i = 0;i < words.size(); i ++){\n            for (int j = 0; j < words[i].length(); j ++){\n                alphas[words[i][j]-'A'] += 1;\n            }\n            map<string,int>::iterator it = wmps.find(words[i]);\n            if (it == wmps.end()){\n                wmps.insert(pair<string,int>(words[i],1));\n            }else{\n                it->second += 1;\n            }\n            wlen += words[i].length();\n        }\n        // for(map<string,int>::iterator it = wmps.)\n        cout << wmps.size() << endl;\n        if (s.length() < wlen){\n            return locations;\n        }\n        long results = 0;\n        for(int i = 0;i < wlen;i ++){\n            inits[s[i]-'A'] += 1; \n            // cout << s[i] << '\\t' ;\n            // cout << inits[i]\n        }\n        \n        for (int i = 0;i < 256; i ++){\n            // cout << inits[i]  <<'\\t'<< alphas[i] << endl; \n            results += (inits[i] ^ alphas[i]);\n        }\n        if (results == 0 && s.length() == wlen){\n                int status = 1;\n                \n                string subs = s.substr(0,wlen);\n                // cout << i-wlen << ' ' << i << endl;\n                // cout << subs << wlen << endl;\n                for(int k = 0;k < words.size();k ++){   \n                   \n                   if ( wmps.find(subs.substr(k*swlen,swlen)) == wmps.end()){\n                       status = 0;\n                       break;\n                   }\n                }\n                // cout << status << endl;\n                if (status == 1){\n                    locations.push_back(0);\n                }\n        }\n        \n        // cout << results << endl;\n        \n        for (int i =wlen;i < s.length();i ++){\n            if (results == 0){\n                int status = 1;\n                \n                string subs = s.substr(i-wlen,wlen);\n                // cout << i-wlen << ' ' << i << endl;\n                cout << subs << wlen << endl;\n                for(int k = 0;k < words.size();k ++){   \n                   cout << subs.substr(k*swlen,swlen) << '\\t';\n                   if ( wmps.find(subs.substr(k*swlen,swlen)) == wmps.end()){\n                       status = 0;\n                       break;\n                   }\n                }\n                // cout << status << endl;\n                if (status == 1){\n                    locations.push_back(i-wlen);\n                }\n            }\n            int idx1 = int(s[i]-'A');\n            int idx2 = int(s[i-wlen]-'A');\n            results -= (inits[idx1] ^ alphas[idx1]);\n            results -= (inits[idx2] ^ alphas[idx2]);\n            inits[idx1] += 1;\n            inits[idx2] -= 1;\n            // results += \n            results += (inits[idx1] ^ alphas[idx1]);\n            results += (inits[idx2] ^ alphas[idx2]);\n        }\n        return locations;\n    }\n};", "compare_result": "11101011111011100010010101110111111100001000110111100011100010111111111001110111111111111110111110101011111010111011101111011111111111111111111110111111111111111111111111110"}, {"id": 212018498, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1551626823, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/212018498/", "is_pending": "Not Pending", "title": "Substring with Concatenation of All Words", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        int alphas[256];\n        int inits[256];\n        vector<int> locations = vector<int>();\n        if(words.size() == 0 ||s.length() ==0)  return locations;\n        int swlen = words[0].length();\n        fill(alphas,alphas+256,0);\n        fill(inits,inits+256,0);\n        int wlen = 0;\n        map<string,int> wmps = map<string,int>();\n        for(int i = 0;i < words.size(); i ++){\n            for (int j = 0; j < words[i].length(); j ++){\n                alphas[words[i][j]-'A'] += 1;\n            }\n            map<string,int>::iterator it = wmps.find(words[i]);\n            if (it == wmps.end()){\n                wmps.insert(pair<string,int>(words[i],1));\n            }else{\n                it->second += 1;\n            }\n            wlen += words[i].length();\n        }\n        if (s.length() < wlen){\n            return locations;\n        }\n        long results = 0;\n        for(int i = 0;i < wlen;i ++){\n            inits[s[i]-'A'] += 1; \n            // cout << inits[i]\n        }\n        \n        for (int i = 0;i < 256; i ++){\n            // cout << inits[i]  <<'\\t'<< alphas[i] << endl; \n            results += (inits[i] ^ alphas[i]);\n        }\n        if (results == 0 && s.length() == wlen){\n                int status = 1;\n                \n                string subs = s.substr(0,wlen);\n                // cout << i-wlen << ' ' << i << endl;\n                // cout << subs << wlen << endl;\n                for(int k = 0;k < words.size();k ++){   \n                   if ( wmps.find(subs.substr(k*swlen,(k+1)*swlen)) == wmps.end()){\n                       status = 0;\n                       break;\n                   }\n                }\n                // cout << status << endl;\n                if (status == 1){\n                    locations.push_back(0);\n                }\n        }\n        \n        // cout << results << endl;\n        for (int i =wlen;i < s.length();i ++){\n            if (results == 0){\n                int status = 1;\n                \n                string subs = s.substr(i-wlen,wlen);\n                // cout << i-wlen << ' ' << i << endl;\n                // cout << subs << wlen << endl;\n                for(int k = 0;k < words.size();k ++){   \n                   if ( wmps.find(subs.substr(k*swlen,(k+1)*swlen)) == wmps.end()){\n                       status = 0;\n                       break;\n                   }\n                }\n                // cout << status << endl;\n                if (status == 1){\n                    locations.push_back(i-wlen);\n                }\n            }\n            int idx1 = int(s[i]-'A');\n            int idx2 = int(s[i-wlen]-'A');\n            results -= (inits[idx1] ^ alphas[idx1]);\n            results -= (inits[idx2] ^ alphas[idx2]);\n            alphas[idx1] += 1;\n            alphas[idx2] -= 1;\n            // results += \n            results += (inits[idx1] ^ alphas[idx1]);\n            results += (inits[idx2] ^ alphas[idx2]);\n        }\n        return locations;\n    }\n};", "compare_result": "11000011111011100000010001110110010100000000100101100000100010010101100001110011000100010110011010101000111000111010100000000000000000000001010000000000000000000000000000011"}, {"id": 212018247, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1551626707, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/212018247/", "is_pending": "Not Pending", "title": "Substring with Concatenation of All Words", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        int alphas[256];\n        int inits[256];\n        int swlen = words[0].length();\n        fill(alphas,alphas+256,0);\n        fill(inits,inits+256,0);\n        int wlen = 0;\n        vector<int> locations = vector<int>();\n        map<string,int> wmps = map<string,int>();\n        for(int i = 0;i < words.size(); i ++){\n            for (int j = 0; j < words[i].length(); j ++){\n                alphas[words[i][j]-'A'] += 1;\n            }\n            map<string,int>::iterator it = wmps.find(words[i]);\n            if (it == wmps.end()){\n                wmps.insert(pair<string,int>(words[i],1));\n            }else{\n                it->second += 1;\n            }\n            wlen += words[i].length();\n        }\n        if (s.length() < wlen){\n            return locations;\n        }\n        long results = 0;\n        for(int i = 0;i < wlen;i ++){\n            inits[s[i]-'A'] += 1; \n            // cout << inits[i]\n        }\n        \n        for (int i = 0;i < 256; i ++){\n            // cout << inits[i]  <<'\\t'<< alphas[i] << endl; \n            results += (inits[i] ^ alphas[i]);\n        }\n        if (results == 0 && s.length() == wlen){\n                int status = 1;\n                \n                string subs = s.substr(0,wlen);\n                // cout << i-wlen << ' ' << i << endl;\n                // cout << subs << wlen << endl;\n                for(int k = 0;k < words.size();k ++){   \n                   if ( wmps.find(subs.substr(k*swlen,(k+1)*swlen)) == wmps.end()){\n                       status = 0;\n                       break;\n                   }\n                }\n                // cout << status << endl;\n                if (status == 1){\n                    locations.push_back(0);\n                }\n        }\n        \n        // cout << results << endl;\n        for (int i =wlen;i < s.length();i ++){\n            if (results == 0){\n                int status = 1;\n                \n                string subs = s.substr(i-wlen,wlen);\n                // cout << i-wlen << ' ' << i << endl;\n                // cout << subs << wlen << endl;\n                for(int k = 0;k < words.size();k ++){   \n                   if ( wmps.find(subs.substr(k*swlen,(k+1)*swlen)) == wmps.end()){\n                       status = 0;\n                       break;\n                   }\n                }\n                // cout << status << endl;\n                if (status == 1){\n                    locations.push_back(i-wlen);\n                }\n            }\n            int idx1 = int(s[i]-'A');\n            int idx2 = int(s[i-wlen]-'A');\n            results -= (inits[idx1] ^ alphas[idx1]);\n            results -= (inits[idx2] ^ alphas[idx2]);\n            alphas[idx1] += 1;\n            alphas[idx2] -= 1;\n            // results += \n            results += (inits[idx1] ^ alphas[idx1]);\n            results += (inits[idx2] ^ alphas[idx2]);\n        }\n        return locations;\n    }\n};", "compare_result": null}, {"id": 211988246, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1551611378, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/211988246/", "is_pending": "Not Pending", "title": "Text Justification", "memory": "9.3 MB", "code": "class Solution\n{\n  public:\n    vector<string> fullJustify(vector<string> &words, int maxWidth)\n    {\n        // vector<vector<string> > vectors = vector<vector<string> > ();\n        vector<string> rvec = vector<string>();\n        int idx = 0;\n        while (idx < words.size())\n        {\n            int clen = 0;\n            int rlen = 0;\n            vector<string> svec = vector<string>();\n            while (idx < words.size() && clen <= maxWidth)\n            {\n                if (words[idx].length() + clen <= maxWidth)\n                {\n                    clen += words[idx].length();\n                    rlen += words[idx].length();\n                    svec.push_back(words[idx]);\n                    idx += 1;\n                }\n                clen += 1;\n            }\n            int ss = svec.size();\n            string sresult(\"\");\n            cout << words.size()-1 << endl;\n            if (idx < words.size())\n            {\n                if (ss == 1)\n                {\n                    sresult += svec[0] + string(maxWidth - rlen, ' ');\n                }\n                else\n                {\n                    int savg = (maxWidth - rlen) / (ss - 1);\n                    int srest = (maxWidth - rlen) % (ss - 1);\n                    // cout << savg << ' ' << srest << endl;\n                    for (int i = 0; i < ss; i++)\n                    {\n                        int spacelen = 0;\n                        if (i < ss - 1)\n                        {\n                            spacelen = savg;\n                        }\n                        if (srest > 0)\n                        {\n                            srest -= 1;\n                            spacelen += 1;\n                        }\n                        sresult += svec[i] + string(spacelen, ' ');\n                    }\n                }\n            }else{\n                // cout << idx << endl;\n                for(int i = 0; i < ss-1;i ++){\n                    sresult += svec[i] + string(1,' ');\n                }\n                sresult += svec[ss-1];\n                sresult += string(maxWidth-sresult.length(),' ');\n            }\n            rvec.push_back(sresult);\n        }\n\n        return rvec;\n    }\n};", "compare_result": "111111111111111111111111111"}, {"id": 211987545, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1551610951, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/211987545/", "is_pending": "Not Pending", "title": "Text Justification", "memory": "N/A", "code": "class Solution\n{\n  public:\n    vector<string> fullJustify(vector<string> &words, int maxWidth)\n    {\n        // vector<vector<string> > vectors = vector<vector<string> > ();\n        vector<string> rvec = vector<string>();\n        int idx = 0;\n        while (idx < words.size())\n        {\n            int clen = 0;\n            int rlen = 0;\n            vector<string> svec = vector<string>();\n            while (idx < words.size() && clen <= maxWidth)\n            {\n                if (words[idx].length() + clen <= maxWidth)\n                {\n                    clen += words[idx].length();\n                    rlen += words[idx].length();\n                    svec.push_back(words[idx]);\n                    idx += 1;\n                }\n                clen += 1;\n            }\n            int ss = svec.size();\n            string sresult(\"\");\n            if (idx < words.size() - 1)\n            {\n                if (ss == 1)\n                {\n                    sresult += svec[0] + string(maxWidth - rlen, ' ');\n                }\n                else\n                {\n                    int savg = (maxWidth - rlen) / (ss - 1);\n                    int srest = (maxWidth - rlen) % (ss - 1);\n                    for (int i = 0; i < ss; i++)\n                    {\n                        int spacelen = 0;\n                        if (i < ss - 1)\n                        {\n                            spacelen = savg;\n                        }\n                        if (srest > 0)\n                        {\n                            srest -= 1;\n                            spacelen += 1;\n                        }\n                        sresult += svec[i] + string(spacelen, ' ');\n                    }\n                }\n            }else{\n                for(int i = 0; i < ss-1;i ++){\n                    sresult += svec[i] + string(1,' ');\n                }\n                sresult += svec[ss-1];\n                sresult += string(maxWidth-sresult.length(),' ');\n            }\n            rvec.push_back(sresult);\n        }\n\n        return rvec;\n    }\n};", "compare_result": "010010111111011111111100111"}, {"id": 211987462, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1551610906, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/211987462/", "is_pending": "Not Pending", "title": "Text Justification", "memory": "N/A", "code": "class Solution\n{\n  public:\n    vector<string> fullJustify(vector<string> &words, int maxWidth)\n    {\n        // vector<vector<string> > vectors = vector<vector<string> > ();\n        vector<string> rvec = vector<string>();\n        int idx = 0;\n        while (idx < words.size())\n        {\n            int clen = 0;\n            int rlen = 0;\n            vector<string> svec = vector<string>();\n            while (idx < words.size() && clen <= maxWidth)\n            {\n                if (words[idx].length() + clen <= maxWidth)\n                {\n                    clen += words[idx].length();\n                    rlen += words[idx].length();\n                    svec.push_back(words[idx]);\n                    idx += 1;\n                }\n                clen += 1;\n            }\n            int ss = svec.size();\n            string sresult(\"\");\n            if (idx < words.size() - 1)\n            {\n                if (ss == 1)\n                {\n                    sresult += svec[0] + string(maxWidth - rlen, ' ');\n                }\n                else\n                {\n                    int savg = (maxWidth - rlen) / (ss - 1);\n                    int srest = (maxWidth - rlen) % (ss - 1);\n                    for (int i = 0; i < ss; i++)\n                    {\n                        int spacelen = 0;\n                        if (i < ss - 1)\n                        {\n                            spacelen = savg;\n                        }\n                        if (srest > 0)\n                        {\n                            srest -= 1;\n                            spacelen += 1;\n                        }\n                        sresult += svec[i] + string(spacelen, ' ');\n                    }\n                }\n            }else{\n                for(int i = 0; i < ss-1;i ++){\n                    sresult += svec[i] + string(1,' ');\n                }\n                sresult += svec[ss-1];\n                sresult += string(maxWidth-sresult.length(),' ');\n            }\n            rvec.push_back(sresult);\n        }\n\n        return rvec;\n    }\n};", "compare_result": "010010111111011111111100111"}, {"id": 211986435, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1551610408, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/211986435/", "is_pending": "Not Pending", "title": "Text Justification", "memory": "N/A", "code": "class Solution {\npublic:\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\n        // vector<vector<string> > vectors = vector<vector<string> > ();   \n        vector<string> rvec = vector<string>();\n        int idx = 0;\n        while (idx < words.size()){\n            int clen = 0;\n            int rlen = 0;\n            vector<string> svec = vector<string>();\n            while(idx < words.size() && clen <=maxWidth){\n                if (words[idx].length() + clen <=maxWidth){\n                    clen += words[idx].length();\n                    rlen += words[idx].length();\n                    svec.push_back(words[idx]);\n                    idx += 1;\n                }\n                clen += 1;\n            }\n            int ss = svec.size();\n            string sresult(\"\");\n            if (ss == 1){\n                sresult += svec[0] + string(maxWidth-rlen,' ');\n            }else{\n                int savg = (maxWidth-rlen)/(ss-1);\n                int srest = (maxWidth-rlen)%(ss-1);\n                for(int i = 0;i < ss;i ++){\n                    int spacelen = 0;\n                    if(i < ss-1){\n                        spacelen = savg;\n                    }\n                    if (srest >0){\n                        srest -= 1;\n                        spacelen += 1;\n                    }\n                    sresult += svec[i] + string(spacelen,' ');\n                }\n            }\n            rvec.push_back(sresult);\n        }\n        return rvec;\n    }\n};", "compare_result": "101111111110111111001011000"}, {"id": 211980417, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1551607204, "status_display": "Accepted", "runtime": "4 ms", "url": "/submissions/detail/211980417/", "is_pending": "Not Pending", "title": "Reaching Points", "memory": "9.2 MB", "code": "class Solution {\npublic:\n    bool reachingPoints(int sx, int sy, int tx, int ty) {\n        if (tx < sx || ty < sy){\n            return false;\n        }\n        if(tx == sx && ty == sy){\n            return true;\n        }\n        if (tx == sx ){\n            return (ty-sy)%tx == 0;\n        }\n        if (ty == sy){\n            return (tx - sx)%ty == 0;\n        }\n\n        if (tx > ty){\n            return reachingPoints(sx,sy,tx%ty,ty);\n        }\n        return reachingPoints(sx,sy,tx,ty%tx);\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 211980053, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1551607028, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/211980053/", "is_pending": "Not Pending", "title": "Reaching Points", "memory": "N/A", "code": "class Solution {\npublic:\n    bool reachingPoints(int sx, int sy, int tx, int ty) {\n        if (tx < sx || ty < sy){\n            return false;\n        }\n        if (tx == sx ){\n            return (ty-tx)%sy == 0;\n        }\n        if (ty == sy){\n            return (tx - ty)%sx == 0;\n        }\n\n        if (tx > ty){\n            return reachingPoints(sx,sy,tx%ty,ty);\n        }\n        return reachingPoints(sx,sy,tx,ty%tx);\n    }\n};", "compare_result": "1111111111111111111111111011111111110111111111111111101111111110111010101010101010111011111010101111111110111010111011101011110010111010111111111110111111111111111111111101000001000000000001"}, {"id": 211979879, "lang": "cpp", "time": "10\u00a0months", "timestamp": 1551606949, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/211979879/", "is_pending": "Not Pending", "title": "Reaching Points", "memory": "N/A", "code": "class Solution {\npublic:\n    bool reachingPoints(int sx, int sy, int tx, int ty) {\n        if (tx < sx || ty < sy){\n            return false;\n        }\n        if (tx == sx ){\n            return (ty-tx)%tx == 0;\n        }\n        if (ty == sy){\n            return (tx - ty)%ty == 0;\n        }\n\n        if (tx > ty){\n            return reachingPoints(sx,sy,tx%ty,ty);\n        }\n        return reachingPoints(sx,sy,tx,ty%tx);\n    }\n};", "compare_result": "1110101100101110101011111111101010101010101110101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101000000000000000000000111110111111111111"}, {"id": 211751172, "lang": "cpp", "time": "10\u00a0months, 1\u00a0week", "timestamp": 1551540713, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/211751172/", "is_pending": "Not Pending", "title": "Max Points on a Line", "memory": "N/A", "code": "/**\n * Definition for a point.\n * struct Point {\n *     int x;\n *     int y;\n *     Point() : x(0), y(0) {}\n *     Point(int a, int b) : x(a), y(b) {}\n * };\n */\nclass Solution {\npublic:\n    int maxPoints(vector<Point>& points) {\n        map<double,map<double,int> > mp = map<double,map<double,int> > ();\n        map<int,int> inf = map<int,int>();\n        if (points.size() < 2){\n            return points.size();\n        }\n        for(int i = 0;i < points.size(); i ++){\n            for (int j = i+1; j < points.size(); j ++){\n                if (points[i].x == points[j].x){\n                    map<int,int>::iterator it = inf.find(points[i].x);\n                    if (it == inf.end()){\n                        inf.insert(pair<int,int>(points[i].x,0));\n                    }\n                    it = inf.find(points[i].x);\n                    it->second += 2;\n                }else{\n                    double k = 1.0*(points[i].y-points[j].y)/(points[i].x-points[j].x);\n                    double b = points[i].y-points[i].x*k;\n                    map<double,map<double,int> >::iterator mit = mp.find(k);\n                    map<double,int> *kmp = NULL;\n                    if (mit == mp.end()){\n                        kmp = new map<double,int>();\n                        mp.insert(pair<double,map<double,int> >(k,*kmp));\n                    }\n                    mit = mp.find(k);\n                    kmp = &(mit->second);\n                    map<double,int>::iterator bit = kmp->find(b);\n                    if (bit == kmp->end()){\n                        kmp->insert(pair<double,int>(b,0));\n                    }\n                    bit = kmp->find(b);\n                    bit->second += 2;\n                }\n            }\n        }    \n        int mx = 0;\n        for (map<int,int>::iterator it = inf.begin();it != inf.end();it ++){\n            if (mx < it->second){\n                mx = it->second;\n            }\n        }\n        map<double,map<double,int> >::iterator mit ;\n\n        for (mit = mp.begin();mit != mp.end();mit ++){\n            map<double,int>::iterator kit ;\n            map<double,int> kmp = mit->second;\n            // cout << mit->first << endl;\n            for (kit = kmp.begin();kit != kmp.end();kit ++){\n               // cout << kit->second <<\" \"<< mit->first << \"   \" <<  kit->first << endl; \n                if (mx < kit->second){\n                    mx = kit->second;\n                }\n            }\n        }\n        if(mx >0){\n            mx = (1+sqrt(1+4*mx))/2;\n        }\n        return mx;\n    }\n\n};\n", "compare_result": "111111111011100001111101000000001111"}, {"id": 211750899, "lang": "cpp", "time": "10\u00a0months, 1\u00a0week", "timestamp": 1551540584, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/211750899/", "is_pending": "Not Pending", "title": "Max Points on a Line", "memory": "N/A", "code": "/**\n * Definition for a point.\n * struct Point {\n *     int x;\n *     int y;\n *     Point() : x(0), y(0) {}\n *     Point(int a, int b) : x(a), y(b) {}\n * };\n */\nclass Solution {\npublic:\n    int maxPoints(vector<Point>& points) {\n        map<double,map<double,int> > mp = map<double,map<double,int> > ();\n        map<int,int> inf = map<int,int>();\n        for(int i = 0;i < points.size(); i ++){\n            for (int j = i+1; j < points.size(); j ++){\n                if (points[i].x == points[j].x){\n                    map<int,int>::iterator it = inf.find(points[i].x);\n                    if (it == inf.end()){\n                        inf.insert(pair<int,int>(points[i].x,0));\n                    }\n                    it = inf.find(points[i].x);\n                    it->second += 2;\n                }else{\n                    double k = 1.0*(points[i].y-points[j].y)/(points[i].x-points[j].x);\n                    double b = points[i].y-points[i].x*k;\n                    map<double,map<double,int> >::iterator mit = mp.find(k);\n                    map<double,int> *kmp = NULL;\n                    if (mit == mp.end()){\n                        kmp = new map<double,int>();\n                        mp.insert(pair<double,map<double,int> >(k,*kmp));\n                    }\n                    mit = mp.find(k);\n                    kmp = &(mit->second);\n                    map<double,int>::iterator bit = kmp->find(b);\n                    if (bit == kmp->end()){\n                        kmp->insert(pair<double,int>(b,0));\n                    }\n                    bit = kmp->find(b);\n                    bit->second += 2;\n                }\n            }\n        }    \n        int mx = 0;\n        for (map<int,int>::iterator it = inf.begin();it != inf.end();it ++){\n            if (mx < it->second){\n                mx = it->second;\n            }\n        }\n        map<double,map<double,int> >::iterator mit ;\n\n        for (mit = mp.begin();mit != mp.end();mit ++){\n            map<double,int>::iterator kit ;\n            map<double,int> kmp = mit->second;\n            // cout << mit->first << endl;\n            for (kit = kmp.begin();kit != kmp.end();kit ++){\n               // cout << kit->second <<\" \"<< mit->first << \"   \" <<  kit->first << endl; \n                if (mx < kit->second){\n                    mx = kit->second;\n                }\n            }\n        }\n        if(mx >0){\n            mx = (1+sqrt(1+4*mx))/2;\n        }\n        return mx;\n    }\n\n};\n", "compare_result": "111011111011100001111101000000001111"}, {"id": 211750754, "lang": "cpp", "time": "10\u00a0months, 1\u00a0week", "timestamp": 1551540506, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/211750754/", "is_pending": "Not Pending", "title": "Max Points on a Line", "memory": "N/A", "code": "/**\n * Definition for a point.\n * struct Point {\n *     int x;\n *     int y;\n *     Point() : x(0), y(0) {}\n *     Point(int a, int b) : x(a), y(b) {}\n * };\n */\nclass Solution {\npublic:\n    int maxPoints(vector<Point>& points) {\n        map<double,map<double,int> > mp = map<double,map<double,int> > ();\n        map<int,int> inf = map<int,int>();\n        for(int i = 0;i < points.size(); i ++){\n            for (int j = i+1; j < points.size(); j ++){\n                if (points[i].x == points[j].x){\n                    map<int,int>::iterator it = inf.find(points[i].x);\n                    if (it == inf.end()){\n                        inf.insert(pair<int,int>(points[i].x,0));\n                    }\n                    it = inf.find(points[i].x);\n                    it->second += 2;\n                }else{\n                    double k = 1.0*(points[i].y-points[j].y)/(points[i].x-points[j].x);\n                    double b = points[i].y-points[i].x*k;\n                    map<double,map<double,int> >::iterator mit = mp.find(k);\n                    map<double,int> *kmp = NULL;\n                    if (mit == mp.end()){\n                        kmp = new map<double,int>();\n                        mp.insert(pair<double,map<double,int> >(k,*kmp));\n                    }\n                    mit = mp.find(k);\n                    kmp = &(mit->second);\n                    map<double,int>::iterator bit = kmp->find(b);\n                    if (bit == kmp->end()){\n                        kmp->insert(pair<double,int>(b,0));\n                    }\n                    bit = kmp->find(b);\n                    bit->second += 2;\n                }\n            }\n        }    \n        int mx = 0;\n        for (map<int,int>::iterator it = inf.begin();it != inf.end();it ++){\n            if (mx < it->second){\n                mx = it->second;\n            }\n        }\n        map<double,map<double,int> >::iterator mit ;\n\n        for (mit = mp.begin();mit != mp.end();mit ++){\n            map<double,int>::iterator kit ;\n            map<double,int> kmp = mit->second;\n            // cout << mit->first << endl;\n            for (kit = kmp.begin();kit != kmp.end();kit ++){\n               // cout << kit->second <<\" \"<< mit->first << \"   \" <<  kit->first << endl; \n                if (mx < kit->second){\n                    mx = kit->second;\n                }\n            }\n        }\n        return (1+sqrt(1+4*mx))/2;\n    }\n\n};\n", "compare_result": "110111111011100001111101000000001111"}, {"id": 211741147, "lang": "cpp", "time": "10\u00a0months, 1\u00a0week", "timestamp": 1551535186, "status_display": "Accepted", "runtime": "104 ms", "url": "/submissions/detail/211741147/", "is_pending": "Not Pending", "title": "Count of Range Sum", "memory": "41.4 MB", "code": "class Solution {\npublic:\n    int countRangeSum(vector<int>& nums, int lower, int upper) {\n        vector<long> sums = vector<long>();\n        sums.push_back(0);\n        for(int i= 0;i < nums.size() ;i ++){\n            sums.push_back((long)sums[i] + nums[i]);\n        } \n        // return 1;\n        return countRange(sums,lower,upper,0,sums.size()-1);\n    }\n\n    int countRange(vector<long>&nums,int lower,int upper,int start,int end){\n        int iret = 0;\n        if (start >= end){\n            return 0;   \n        }\n        \n        int m = start + ((end-start) >>1);\n        iret += countRange(nums,lower,upper,start,m) + countRange(nums,lower,upper,m+1,end);\n        int i = start;\n        int j = m+1;\n        int k = m+1;\n        int t = m+1;\n        // cout << start << \" \" <<end << \"\\t\";\n        vector<long> tmp = vector<long>();\n        while(i <= m){\n            while(k <= end && (nums[k] - nums[i]) < lower)  k ++;\n            while(j <= end && (nums[j] - nums[i]) <= upper)  j ++;\n            iret += j-k;\n            while(t <= end&&nums[i] >= nums[t] ) {\n                tmp.push_back(nums[t++]);\n            }\n            tmp.push_back(nums[i++]);\n        }\n        while(t<=end){\n            tmp.push_back(nums[t++]);\n        }\n        // cout << tmp.size() << endl;\n        for(int i = 0;i <tmp.size();i ++){\n            nums[i+start] = tmp[i];\n        }\n        return iret;\n    }\n};", "compare_result": "1111111111111111111111111111111111111111111111111111111111111"}, {"id": 211740903, "lang": "cpp", "time": "10\u00a0months, 1\u00a0week", "timestamp": 1551535065, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/211740903/", "is_pending": "Not Pending", "title": "Count of Range Sum", "memory": "N/A", "code": "class Solution {\npublic:\n    int countRangeSum(vector<int>& nums, int lower, int upper) {\n        vector<int> sums = vector<int>();\n        sums.push_back(0);\n        for(int i= 0;i < nums.size() ;i ++){\n            sums.push_back(sums[i] + nums[i]);\n        } \n        // return 1;\n        return countRange(sums,lower,upper,0,sums.size()-1);\n    }\n\n    int countRange(vector<int>&nums,int lower,int upper,int start,int end){\n        int iret = 0;\n        if (start >= end){\n            return 0;   \n        }\n        \n        int m = start + ((end-start) >>1);\n        iret += countRange(nums,lower,upper,start,m) + countRange(nums,lower,upper,m+1,end);\n        int i = start;\n        int j = m+1;\n        int k = m+1;\n        int t = m+1;\n        // cout << start << \" \" <<end << \"\\t\";\n        vector<int> tmp = vector<int>();\n        while(i <= m){\n            while(k <= end && (nums[k] - nums[i]) < lower)  k ++;\n            while(j <= end && (nums[j] - nums[i]) <= upper)  j ++;\n            iret += j-k;\n            while(t <= end&&nums[i] >= nums[t] ) {\n                tmp.push_back(nums[t++]);\n            }\n            tmp.push_back(nums[i++]);\n        }\n        while(t<=end){\n            tmp.push_back(nums[t++]);\n        }\n        // cout << tmp.size() << endl;\n        for(int i = 0;i <tmp.size();i ++){\n            nums[i+start] = tmp[i];\n        }\n        return iret;\n    }\n};", "compare_result": null}, {"id": 211734401, "lang": "cpp", "time": "10\u00a0months, 1\u00a0week", "timestamp": 1551531849, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/211734401/", "is_pending": "Not Pending", "title": "Count of Range Sum", "memory": "N/A", "code": "class Solution {\npublic:\n    int countRangeSum(vector<int>& nums, int lower, int upper) {\n        vector<int> sums = vector<int>(nums.size());\n        sums.push_back(0);\n        for(int i= 0;i < nums.size() ;i ++){\n            sums.push_back(sums[i] + nums[i]);\n        } \n        // return 1;\n        return countRange(sums,lower,upper,0,nums.size()-1);\n    }\n\n    int countRange(vector<int>&nums,int lower,int upper,int start,int end){\n        int iret = 0;\n        if (start >= end){\n            return 0;   \n        }\n        int m = start + ((end-start) >>1);\n        iret += countRange(nums,lower,upper,start,m) + countRange(nums,lower,upper,m+1,end);\n        int i = start;\n        int j = m+1;\n        int k = m+1;\n        int t = m+1;\n        vector<int> tmp = vector<int>(end-start+1);\n        while(i <= m){\n            while(k <= end && (nums[k] - nums[i]) < lower)  k ++;\n            while(j <= end && (nums[j] - nums[i] <= upper))  j ++;\n            iret += j-k;\n            while(nums[i] >= nums[t] && t <= end) {\n                tmp.push_back(nums[t++]);\n            }\n            tmp.push_back(nums[i++]);\n        }\n        while(t<=end){\n            tmp.push_back(nums[t++]);\n        }\n        for(int i = 0;i <tmp.size();i ++){\n            nums[i+start] = tmp[i];\n        }\n        return iret;\n    }\n};\n", "compare_result": "1100101000000001110110000000001111100000000000000011111000000"}, {"id": 211721013, "lang": "cpp", "time": "10\u00a0months, 1\u00a0week", "timestamp": 1551523448, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/211721013/", "is_pending": "Not Pending", "title": "Count of Smaller Numbers After Self", "memory": "N/A", "code": "class Solution\n{\n  public:\n    vector<int> countSmaller(vector<int> &nums)\n    {\n        vector<int> ivc = vector<int>();\n        AVLTree avl = AVLTree();\n        for (int i = nums.size()-1;i >= 0;i --){\n            ivc.push_back(avl.search(nums[i]));\n            avl.insert(nums[i]); \n        }\n        return vector<int>(ivc.rbegin(),ivc.rend());\n    }\n\n    class AVLTree\n    {\n      private:\n        struct TreeNode\n        {\n            int val;\n            int height;\n            TreeNode *left;\n            TreeNode *right;\n        };\n        TreeNode *head = NULL;\n\n      public:\n        int height(TreeNode * root){\n            if (root != NULL) return root->height;\n            return 0;\n        }\n        TreeNode * leftleftR(TreeNode *root){\n            TreeNode *nrt =  root->left;\n            root->left = nrt->right;\n            nrt->right = root;\n            root->height = max(height(root->left),height(root->right)) +1;\n            nrt->height = max(height(nrt->left),height(nrt->right)) +1;\n            return nrt;\n        }\n\n        TreeNode * rightrightR(TreeNode * root){\n            TreeNode *nrt = root->right;\n            root-> right = nrt->left;\n            nrt->left = root;\n            root->height = max(height(root->left),height(root->right)) +1;\n            nrt->height = max(height(nrt->left),height(nrt->right)) +1;\n            return nrt;\n        }\n\n        TreeNode *leftRightR(TreeNode *root){\n            root->left = rightrightR(root->left);\n            return leftleftR(root);\n        }\n\n        TreeNode * rightleftR(TreeNode * root){\n            root->right = leftleftR(root->right);\n            return rightrightR(root);\n        }\n\n        TreeNode * insert(TreeNode * &root,int val)\n        {\n            if (root == NULL){\n                root = new TreeNode();\n                root->val = val;\n                root->left = NULL;\n                root->right = NULL;\n                root->height = 0;\n            }else if (val < root->val){\n                root->left = insert(root->left,val);\n                if (height(root->left) - height(root->right) == 2){\n                    if (val < root->left->val){\n                        root = leftleftR(root);   \n                    }else{\n                        root = leftRightR(root);\n                    }\n                }\n            }else{\n                root->right = insert(root->right,val);\n                if(height(root->right) - height(root->left) == 2){\n                    if (val < root->right->val){\n                        root = rightleftR(root);\n                    }else{\n                        // cout << \"right\";\n                        root = rightrightR(root);\n                    }\n                }\n            }\n            root->height = max(height(root->left),height(root->right)) +1;\n            return root;\n        }\n        void insert(int val){\n            head = insert(head,val);\n            \n        }\n\n        void print(){\n            print(this->head);\n        }\n        void print(TreeNode *root){\n            if (root == NULL){\n                return;\n            }\n            cout << root->val << '\\t';\n            print(root->left);\n            print(root->right);\n        }\n\n        int search(int val){\n            return search(head,val);\n        }\n\n        int search(TreeNode * root, int val){\n            if (root == NULL) return 0;\n            int iret = 0;\n            if (val < root->val) {\n                iret += search(root->left,val);\n            }\n            else{\n                iret += treeSize(root->left);\n                // cout << iret << endl;\n                if (val > root->val){\n                    iret += 1;\n                }\n                iret += search(root->right,val);\n            } \n            return iret;\n\n        }\n\n        int treeSize(TreeNode *root){\n            if(root == NULL)  return 0;\n            return treeSize(root->left) + treeSize(root->right) + 1;\n        }\n\n        int treeSize(){\n            return treeSize(head);\n        }\n\n    };\n};\n", "compare_result": "1111111111111110"}, {"id": 211553630, "lang": "cpp", "time": "10\u00a0months, 1\u00a0week", "timestamp": 1551457092, "status_display": "Accepted", "runtime": "828 ms", "url": "/submissions/detail/211553630/", "is_pending": "Not Pending", "title": "Reverse Pairs", "memory": "185.8 MB", "code": "class Solution {\npublic:\n    int reversePairs(vector<int>& nums) {\n        return findReversePairs(nums,0,nums.size()-1);\n    }\n\n    int findReversePairs(vector<int> & nums,int start,int end){\n        if (start >= end ) return 0;\n        int m = start + ((end-start) >> 1);\n\n        // cout << start << '\\t' << end << '\\t' << m << endl;\n        int res = findReversePairs(nums,start,m) + findReversePairs(nums,m+1,end);\n        vector<int> tvc = vector<int>();\n        int i = start;\n        int p = m+1;\n        int j = m+1;\n        while (i <= m){\n            // cout << i << endl;\n            while (p <= end && nums[i] > 2L* nums[p]) p ++;\n            res += p-(m+1);\n            while (j <= end && nums[i] >= nums[j]) tvc.push_back(nums[j++]);\n            tvc.push_back(nums[i++]);\n        }\n        while(j <= end){\n            tvc.push_back(nums[j++]);\n        }\n        // cout << tvc.size() << endl;\n        for (int i = 0; i < tvc.size(); i ++){\n            nums[start+i] = tvc[i];\n        }\n        // cout << res << endl;\n        return res;\n    }\n};", "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}, {"id": 211553459, "lang": "cpp", "time": "10\u00a0months, 1\u00a0week", "timestamp": 1551457020, "status_display": "Wrong Answer", "runtime": "N/A", "url": "/submissions/detail/211553459/", "is_pending": "Not Pending", "title": "Reverse Pairs", "memory": "N/A", "code": "class Solution {\npublic:\n    int reversePairs(vector<int>& nums) {\n        return findReversePairs(nums,0,nums.size()-1);\n    }\n\n    int findReversePairs(vector<int> & nums,int start,int end){\n        if (start >= end ) return 0;\n        int m = start + ((end-start) >> 1);\n\n        // cout << start << '\\t' << end << '\\t' << m << endl;\n        int res = findReversePairs(nums,start,m) + findReversePairs(nums,m+1,end);\n        vector<int> tvc = vector<int>();\n        int i = start;\n        int p = m+1;\n        int j = m+1;\n        while (i <= m){\n            // cout << i << endl;\n            while (p <= end && (nums[i]-1)/2 >= nums[p]) p ++;\n            res += p-(m+1);\n            while (j <= end && nums[i] >= nums[j]) tvc.push_back(nums[j++]);\n            tvc.push_back(nums[i++]);\n        }\n        while(j <= end){\n            tvc.push_back(nums[j++]);\n        }\n        // cout << tvc.size() << endl;\n        for (int i = 0; i < tvc.size(); i ++){\n            nums[start+i] = tvc[i];\n        }\n        // cout << res << endl;\n        return res;\n    }\n};", "compare_result": "11111111111110000000000000000000000001111111111101111111111111111111110111111111111111111011111011111110010101111011001011001111101111111"}, {"id": 211553303, "lang": "cpp", "time": "10\u00a0months, 1\u00a0week", "timestamp": 1551456949, "status_display": "Runtime Error", "runtime": "N/A", "url": "/submissions/detail/211553303/", "is_pending": "Not Pending", "title": "Reverse Pairs", "memory": "N/A", "code": "class Solution {\npublic:\n    int reversePairs(vector<int>& nums) {\n        return findReversePairs(nums,0,nums.size()-1);\n    }\n\n    int findReversePairs(vector<int> & nums,int start,int end){\n        if (start >= end ) return 0;\n        int m = start + ((end-start) >> 1);\n\n        // cout << start << '\\t' << end << '\\t' << m << endl;\n        int res = findReversePairs(nums,start,m) + findReversePairs(nums,m+1,end);\n        vector<int> tvc = vector<int>();\n        int i = start;\n        int p = m+1;\n        int j = m+1;\n        while (i <= m){\n            // cout << i << endl;\n            while (p <= end && nums[i] > 2*nums[p]) p ++;\n            res += p-(m+1);\n            while (j <= end && nums[i] >= nums[j]) tvc.push_back(nums[j++]);\n            tvc.push_back(nums[i++]);\n        }\n        while(j <= end){\n            tvc.push_back(nums[j++]);\n        }\n        // cout << tvc.size() << endl;\n        for (int i = 0; i < tvc.size(); i ++){\n            nums[start+i] = tvc[i];\n        }\n        // cout << res << endl;\n        return res;\n    }\n};", "compare_result": null}]